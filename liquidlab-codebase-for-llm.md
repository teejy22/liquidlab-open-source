# LiquidLab Codebase

## Project Overview

# LiquidLab - Trading Platform Builder

## Overview

LiquidLab is a full-stack web application that allows users to build custom trading platforms on the Hyperliquid DEX using a drag-and-drop interface. Users can create professional trading interfaces without coding, generate revenue through builder codes, and deploy their platforms with custom domains. The main website domain is liquidlab.trade.

## User Preferences

Preferred communication style: Simple, everyday language.

## System Architecture

### Frontend Architecture
- **Framework**: React 18 with TypeScript
- **Routing**: Wouter for lightweight client-side routing
- **State Management**: TanStack Query for server state management
- **Styling**: Tailwind CSS with shadcn/ui component library
- **Build Tool**: Vite for fast development and optimized builds
- **Drag & Drop**: @dnd-kit for building the visual platform builder

### Backend Architecture
- **Runtime**: Node.js with Express.js
- **Language**: TypeScript with ES modules
- **Database**: PostgreSQL with Drizzle ORM
- **Database Provider**: Neon serverless PostgreSQL
- **API Style**: RESTful API with Express routes
- **Development**: Hot module replacement via Vite middleware

### Key Components

#### Database Schema
- **Users**: Wallet addresses, usernames, builder codes, referral codes
- **Trading Platforms**: User-created platforms with configs and templates
- **Templates**: Pre-built platform layouts and designs
- **Revenue Records**: Tracking builder fees and referral commissions
- **Referrals**: User referral system for additional revenue

#### Trading Integration
- **Hyperliquid Service**: Direct API integration for market data, orderbooks, and trade execution
- **Real-time Data**: WebSocket connections for live market updates
- **Wallet Integration**: MetaMask/Web3 wallet connection for user authentication

#### Visual Builder
- **Single Template System**: Simplified builder with one professional Hyperliquid-style template
- **Configuration Panel**: Platform name, custom domain, and builder code generation
- **Automatic Features**: All trading features pre-included (no assembly required)
- **Preview Modes**: Desktop and mobile preview capabilities
- **Revenue Tracking**: Built-in builder code system for fee distribution

## Data Flow

1. **User Authentication**: Wallet connection establishes user identity
2. **Platform Creation**: Users select templates or build from scratch
3. **Component Configuration**: Drag-and-drop interface for layout design
4. **Trading Integration**: Real-time data from Hyperliquid API
5. **Revenue Tracking**: Builder codes generate fees, stored in revenue records
6. **Deployment**: Platforms can be published with custom domains

## External Dependencies

### Core Dependencies
- **@neondatabase/serverless**: PostgreSQL database connection
- **drizzle-orm**: Type-safe database operations
- **@tanstack/react-query**: Server state management
- **@dnd-kit/core**: Drag and drop functionality
- **@radix-ui/react-***: Accessible UI components
- **wouter**: Lightweight routing
- **zod**: Runtime type validation

### Trading & Web3
- **Hyperliquid API**: Direct trading and market data integration
- **MetaMask/Ethereum**: Wallet connection and user authentication

### Development Tools
- **Vite**: Build tool and development server
- **TypeScript**: Type safety across the stack
- **Tailwind CSS**: Utility-first styling
- **ESBuild**: Production bundling

## Deployment Strategy

### Development Environment
- **Local Development**: Vite dev server with hot module replacement
- **Database**: Neon serverless PostgreSQL with connection pooling
- **API Development**: Express server with TypeScript compilation via tsx

### Production Build
- **Frontend**: Vite builds optimized React bundle to `dist/public`
- **Backend**: ESBuild compiles server TypeScript to `dist/index.js`
- **Database Migrations**: Drizzle Kit handles schema migrations
- **Static Assets**: Served directly from Express in production

### Environment Configuration
- **DATABASE_URL**: Required environment variable for PostgreSQL connection
- **NODE_ENV**: Determines development vs production behavior
- **REPL_ID**: Replit-specific environment detection
- **VITE_BUILDER_WALLET_ADDRESS**: Builder wallet address for Hyperliquid fee collection (must have 100+ USDC in perps account)

The application uses a monorepo structure with shared types and schemas, enabling type safety between frontend and backend while maintaining clear separation of concerns.

## Recent Changes (January 18, 2025)

### Centralized SaaS Architecture Implementation
- **Platform Architecture Transformation**: Migrated from "platform builder" to "trading platform network" model
  - Single codebase serves all trading platforms (Shopify-style architecture)
  - Platforms accessed via subdomains: platform-name.liquidlab.trade
  - Custom domains supported via CNAME pointing to app.liquidlab.trade
  - Automatic updates: All platforms instantly receive new features and security patches
- **Technical Implementation**: 
  - Added platformResolver middleware to identify platforms by domain
  - Added subdomain field to tradingPlatforms table with automatic generation
  - Created /api/platform/current endpoint for platform data resolution
  - Updated App.tsx to detect platform subdomains and render trading interface
  - Storage layer automatically generates subdomains during platform creation
- **Benefits**: 
  - Zero deployment complexity for platform owners
  - Instant security updates across all platforms
  - Centralized monitoring and management
  - Reduced infrastructure costs

### Critical Security Vulnerabilities Fixed
- **Fixed Reflected XSS in Hyperliquid Webhook**: Resolved security vulnerability where challenge parameter was returned without sanitization
  - Added HTML entity encoding for all special characters (&, <, >, ", ', /)
  - Set response type to 'text/plain' to prevent HTML interpretation
  - Prevents attackers from injecting malicious scripts via webhook verification endpoint
  - Identified by automated security scanning and fixed immediately
- **Fixed Missing CSRF Protection**: Re-enabled CSRF protection that was temporarily disabled
  - CSRF tokens now required for all state-changing requests (POST, PUT, DELETE)
  - Client-side automatically includes X-CSRF-Token header from cookie
  - Webhooks and GET requests exempt from CSRF protection
  - Prevents attackers from submitting forged requests on behalf of authenticated users
- **Fixed Client-Side XSS in Image Display**: Resolved DOM-based XSS vulnerability in platform logo rendering
  - validateImageUrl function now called once and result stored in variable
  - Eliminates double function call that could bypass validation
  - React's built-in XSS protection properly enforced
  - Prevents injection of malicious URLs through platform logo field

## Recent Changes (January 14, 2025)

### Admin Dashboard Implementation
- **Admin Authentication**: Created separate admin login system at `/admin/login`
  - Admin email: `admin@liquidlab.trade`
  - Admin password: Stored as bcrypt hash in `ADMIN_PASSWORD` environment variable
  - Separate session management from regular user authentication
- **Admin Dashboard Features**: Comprehensive admin panel at `/admin/dashboard`
  - Total revenue display showing combined earnings from all platforms
  - Revenue breakdown: 30% LiquidLab / 70% Platform Owners clearly displayed
  - Platform management: View all created platforms with owner details and status
  - Transaction history: Complete fee transaction log with volumes and earnings
  - Key metrics: Total users, active platforms, transaction counts
  - Tabbed interface for easy navigation between data views
- **User Management Tab** (January 16, 2025): Added comprehensive user management functionality
  - View all registered users with username, email, wallet address, and builder codes
  - Searchable user table with real-time filtering by username or email
  - Password reset capability for any user with confirmation dialog
  - Secure password reset with minimum 8 character requirement
  - Admin-only endpoints: GET /api/admin/users, POST /api/admin/users/:userId/reset-password
  - Storage layer enhanced with getAllUsers() and updateUserPassword() methods
- **Wallet Management Tab** (January 17, 2025): Added dedicated wallet management functionality
  - Main Collection Wallet: Shows builder wallet address and total collected revenue
  - Payout Wallet Configuration: Displays Arbitrum network, USDC currency, weekly schedule
  - Real-time USDC balance display with 30-second auto-refresh
  - Revenue Distribution: Visual breakdown of LiquidLab (30%) vs Platform Owners (70%) shares
  - Manual Actions: Process payouts and export revenue reports buttons
  - Pending payouts display for tracking outstanding platform owner payments
- **Security**: Admin routes protected with requireAdmin middleware
- **Visual Design**: Red-themed admin interface to distinguish from regular user dashboard

## Recent Changes (January 14, 2025)

### Mobile Experience Optimization
- **Trading Interface**: Implemented mobile-responsive tabs for Chart, Order Book, and Trade sections
  - Touch-friendly tab navigation with clear visual indicators
  - Full-width components on mobile devices
  - Proper spacing and padding adjustments
  - Fixed markets tab auto-switching issue with autoSelectBTC prop
- **Header Optimization**: Optimized header elements for better visual hierarchy
  - Header height: 144px mobile / 96px desktop (mobile large, desktop compact)
  - Logo height: 128px mobile / 144px desktop (desktop logo larger than header for bold impact)
  - Verification badge: Compact mode with smaller icons and minimal padding
  - Mobile shows wallet connect button and simplified back arrow
  - Compact spacing on mobile devices (space-x-2 vs space-x-6)
- **TrustIndicators Component**: Enhanced mobile layout with compact design
  - Reduced to minimal height with px-2 py-1 padding
  - Tiny text size (text-[10px]) for all elements
  - Smaller icons (w-3 h-3) throughout
  - Compact Details button (h-5 with px-2)
  - More efficient use of screen space on mobile
- **Example Trading Page**: Complete mobile overhaul
  - Tabbed interface for space-efficient navigation (Markets, Chart, Trade, AI)
  - Mobile-optimized market selector that stays open when selected
  - Responsive position details cards
  - Proper price display spacing
  - Full-screen height on mobile (h-screen) vs fixed desktop height
- **Navigation**: Added mobile hamburger menu with improved UX
  - Smooth transitions and hover states
  - Touch-friendly tap targets
  - Auto-close on navigation

### MoonPay Affiliate Revenue Update
- **Additional Revenue Stream**: Added MoonPay affiliate commission information to pricing page
- **Revenue Split**: 1% affiliate commission on fiat purchases split 50/50 between platform owner and LiquidLab
- **Earnings Example**: $100,000 in monthly crypto purchases generates $500 for platform owner
- **FAQ Updates**: Added detailed explanations about dual revenue streams (trading fees + MoonPay commissions)
- **Automatic Integration**: MoonPay already built into every platform, no additional setup required

### MoonPay Revenue Dashboard Implementation
- **Database Schema**: Added moonpayTransactions table to track all MoonPay affiliate transactions
  - Tracks purchase amounts, affiliate fees, and revenue splits
  - Separate earnings fields for platform owners and LiquidLab
  - Status tracking for pending/completed transactions
- **API Endpoints**: Created MoonPay revenue tracking endpoints
  - GET /api/moonpay/revenue/:platformId - Platform-specific MoonPay stats
  - GET /api/moonpay/revenue - Total MoonPay revenue across all platforms
  - POST /api/moonpay/record - Record new MoonPay transactions
- **Regular Dashboard Updates**: Platform owners can now see:
  - Trading Fee Earnings (70% share)
  - MoonPay Earnings (50% share)
  - Total Combined Earnings
  - Revenue split breakdown showing both income streams
- **Admin Dashboard Updates**: Comprehensive MoonPay section showing:
  - Total fiat purchases through MoonPay
  - Total affiliate fees generated (1% of purchases)
  - LiquidLab's 50% share of MoonPay revenue
  - Platform owners' 50% share of MoonPay revenue

### Builder Fee Update (January 16, 2025)
- **Fee Structure**: Updated builder fee to 0.1% (10 basis points) for perpetual trading
  - This is the maximum allowed fee for perps on Hyperliquid
  - Fee format in code: `{"b": wallet_address, "f": 100}` where 100 = 10 basis points = 0.1%
  - Updated all UI displays to show 0.1% instead of 0.01%
  - Revenue split remains 70% platform owner / 30% LiquidLab

### Privy Wallet Authentication Integration (January 15, 2025)
- **Automatic Privy Integration**: All trading platforms now include Privy wallet authentication by default
  - Social logins (email, SMS) alongside wallet connections
  - Dark theme customization matching Hyperliquid style
  - Enterprise-grade wallet infrastructure at no additional cost
- **Component Implementation**:
  - Created PrivyProvider component that wraps trading interface
  - WalletConnect button shows connected wallet address with logout functionality
  - Integrated into example trading page template
  - API endpoint `/api/privy/config` securely passes Privy app ID from backend
- **User Benefits**:
  - Traders can connect with MetaMask, WalletConnect, or social accounts
  - Embedded wallet creation for users without existing wallets
  - Secure authentication without platform owners managing private keys
- **Technical Details**:
  - Uses @privy-io/react-auth for frontend integration
  - Privy app ID fetched from server environment variables (PRIVY_APP_ID)
  - PrivyProvider dynamically loads configuration from backend
  - Production platforms will use unique Privy App IDs per platform

### Logo Upload Feature
- **File Upload Implementation**: Added multer-based logo upload system with 5MB size limit
- **Supported Formats**: PNG, JPG, JPEG, GIF, and WebP images
- **Upload UI**: Drag-and-drop style upload interface in builder configuration panel
- **Real-time Preview**: Uploaded logos display immediately in platform preview header
- **File Storage**: Logos stored in 'uploads' directory and served statically via Express
- **API Endpoint**: POST /api/upload-logo endpoint handles file uploads
- **Visual Integration**: Logo appears alongside platform name in the preview section

### Trading Interface Layout Updates (January 14, 2025)
- **Layout Simplification**: Reverted from dropdown market selector back to markets sidebar
  - Markets sidebar remains on the left side with BTC/ETH/SOL pairs
  - Chart positioned in the center with market stats bar
  - Trading form on the right side (orderbook temporarily removed for repositioning)
  - Fixed height containers (450px) to ensure positions area is visible
- **Compact Trading Form**: Streamlined trading interface
  - Removed tabs for spot/cross/isolated trading
  - Smaller input fields and buttons for space efficiency
  - Buy/sell buttons with clear green/red visual states with dark backgrounds
  - Compact leverage selector and order type controls with dark theme
- **Dynamic Logo Display**: Connected uploaded logos to example trading page
  - Example page now fetches the most recent platform data
  - Displays uploaded logo from builder instead of hardcoded logo
  - Platform name and ID are dynamically displayed in verification badge
  - Fallback to default logo if no platform exists

### CORS Fix and Builder Preview Update (January 15, 2025)
- **Builder Preview Enhancement**: Updated builder page to display uploaded logo in the main preview area
  - Replaced static template preview with uploaded logo when available
  - Logo displays on dark background for better visibility
  - Maintains template preview as fallback when no logo is uploaded
- **Market Data CORS Fix**: Resolved runtime error on example trading page
  - Switched from direct CoinGecko API calls to proxy endpoint `/api/prices`
  - Eliminates CORS errors by routing through backend
  - Existing backend endpoint handles all CoinGecko API requests

### Platform Verification System Auto-Approval (January 17, 2025)
- **Development Mode Auto-Approval**: Fixed verification failing for new platforms
  - New platforms now automatically get approval_status='approved' in development mode
  - Previously all new platforms started as 'pending', preventing verification
  - Updated all existing pending platforms to approved status (6 platforms)
  - Created security records for all platforms missing them
  - Verification now works immediately after platform creation for easier testing

### Rate Limiting Adjustment (January 17, 2025)
- **Authentication Rate Limit**: Increased from 5 to 20 attempts per 15 minutes
  - Previous limit was too restrictive for development and testing
  - Users were frequently hitting 429 errors during normal testing workflows
  - Still maintains security while allowing reasonable testing patterns
- **General API Rate Limit**: Increased from 100 to 500 requests per 15 minutes
  - Trading interface makes many API calls for real-time market data
  - Previous limit caused "too many requests" errors when viewing platforms
  - New limit accommodates the high-frequency nature of trading applications

### EIP-712 Wallet Signing Infrastructure Implementation (January 16, 2025)
- **Complete Hyperliquid Trading Integration**: Implemented full EIP-712 signing infrastructure for real trading
  - Created `hyperliquid-signing.ts` with complete order signing logic using EIP-712 standard
  - Supports all Hyperliquid asset indices (120+ trading pairs)
  - Proper time-in-force options: ALO (Post Only), IOC, GTC
  - Accurate decimal handling for different assets (BTC: 5 decimals, ETH: 5 decimals, etc.)
- **Privy Wallet Integration**: Connected Privy authentication to trading functionality
  - `useHyperliquidTrading` hook manages wallet connection and order signing
  - Fetches real-time user positions and open orders
  - Handles order submission with proper error handling and user feedback
- **Trading Form Component**: Built new `HyperliquidTradeForm` with professional features
  - Buy/Sell toggle with visual states (green/red)
  - Limit/Market order types with Post Only option
  - Leverage selector (1x to 100x)
  - Real-time order value and margin calculations
  - Reduce Only checkbox for position management
- **Live Positions Display**: Created `HyperliquidPositions` component showing real account data
  - Account summary: Total value, margin used, free collateral, total PnL
  - Positions table: Entry/mark/liquidation prices, unrealized PnL, margin usage
  - Real-time updates every 2 seconds
  - Proper formatting for all numeric values
- **Full Trading Flow**: Complete order placement workflow now functional
  - User connects wallet via Privy → Selects market → Sets order parameters
  - Order signed with wallet (EIP-712) → Submitted to Hyperliquid API
  - Positions and account data update automatically
  - Toast notifications for order success/failure
- **Full Trading Flow**: Complete order placement workflow now functional
  - User connects wallet via Privy → Selects market → Sets order parameters
  - Order signed with wallet (EIP-712) → Submitted to Hyperliquid API
  - Positions and account data update automatically
  - Toast notifications for order success/failure

### Builder Simplification
- **Removed Drag-and-Drop**: Eliminated complex drag-and-drop builder functionality
- **Single Template System**: Now offers one professional Hyperliquid-style template
- **Streamlined Configuration**: Simple form for platform name, custom domain, and builder code
- **Automatic Features**: All trading features are pre-included (TradingView, Order Book, Privy, MoonPay)
- **Preview Modes**: Desktop and mobile preview capabilities retained
- **Revenue Display**: Clear 70/30 revenue share information displayed

### Critical Hyperliquid Integration Fix (January 15, 2025)
- **Price Data Issue Resolved**: Fixed critical issue where Hyperliquid's "allMids" endpoint was returning incorrect price units
  - ETH was showing $26 instead of $3,000+
  - BTC was completely missing from the price response
  - All prices were off by significant factors making the platform unusable
- **Solution Implemented**: Created new `/api/hyperliquid/market-prices` endpoint that fetches real-time orderbook data
  - Uses orderbook mid-prices (average of best bid/ask) for accurate USD pricing
  - Fetches prices for main markets: BTC, ETH, SOL, ARB, MATIC, AVAX, BNB, DOGE, SUI, APT
  - Returns properly formatted USD prices (BTC ~$119k, ETH ~$3k, SOL ~$163)
- **HyperliquidMarkets Component**: Updated to use the new accurate pricing endpoint
- **Full DEX Integration**: All platforms now have access to complete Hyperliquid market data and trading functionality
  - Real-time price updates from actual orderbooks
  - Accurate market selection with correct USD values
  - Ready for production trading with real money

### Two-Factor Authentication Implementation (January 17, 2025)
- **Complete 2FA System**: Added enterprise-grade 2FA support for both regular users and admins
  - TOTP-based authentication using industry-standard authenticator apps (Google Authenticator, Authy, etc.)
  - QR code generation for easy setup with any authenticator app
  - 8 backup codes generated for account recovery
  - Secure storage of 2FA secrets and backup codes in database
- **Backend Implementation**: Comprehensive 2FA API endpoints and auth flow
  - `/api/auth/2fa/setup` - Generate QR code and backup codes
  - `/api/auth/2fa/enable` - Verify TOTP and enable 2FA
  - `/api/auth/2fa/disable` - Disable 2FA with password verification
  - `/api/auth/2fa/status` - Check current 2FA status
  - Authentication endpoints now return `requiresTwoFactor` flag when 2FA is enabled
- **Database Updates**: Added 2FA fields to users table
  - `twoFactorSecret` - Encrypted TOTP secret
  - `twoFactorEnabled` - Boolean flag for 2FA status
  - `twoFactorBackupCodes` - JSON array of hashed backup codes
  - Successfully migrated schema with `npm run db:push`
- **UI Components**: User-friendly 2FA management interface
  - TwoFactorSetup component for dashboard with QR code display
  - Login pages updated to handle 2FA verification flow
  - Backup code display with copy functionality
  - Clear instructions and error handling throughout
- **Security Features**: Bank-level authentication security
  - Time-based one-time passwords (30-second window)
  - Backup codes for emergency access
  - Password verification required to disable 2FA
  - Rate limiting on authentication attempts

### TradingView Chart Integration (January 16, 2025)
- **Professional Charting Solution**: Replaced all custom chart implementations with real TradingView advanced chart widget
  - Full professional charting tools including drawing tools, indicators, and technical analysis
  - Dark theme matching Hyperliquid style with automatic symbol mapping to Binance format
  - Support for all time intervals from 1 minute to daily charts
  - Removed default RSI and MACD indicators for cleaner initial view
  - Users can still add any indicators they want through TradingView's built-in interface
- **Enhanced Chart Features** (January 16, 2025): Re-enabled full TradingView advanced tools
  - Drawing tools toolbar: Lines, trend lines, channels, Fibonacci tools, shapes
  - Indicators menu: Hundreds of technical analysis indicators available
  - Chart toolbar: Symbol search, timeframes, chart types, compare symbols
  - Save/export features: Screenshot charts and save analysis templates
  - Popup mode: Expand chart to larger window for detailed analysis

### Markets Sidebar Improvements (January 16, 2025)
- **Compact Design**: Made perp markets column thinner (w-44) and more compact
  - Reduced text sizes to xs and text-[10px] for maximum space efficiency
  - Tighter padding (p-2 and space-y-0.5) throughout
  - Simplified leverage display showing just "5x" instead of "5x leverage"
- **Search Functionality**: Added real-time market search
  - Search input with icon at top of markets list
  - Filters markets by symbol name as you type
- **Hover Effects**: Fixed hover states to change both background and text colors
  - Group hover classes ensure all text elements change color together
- **Custom Scrollbar**: Added black scrollbar styling
  - Thin 6px width scrollbar
  - Black track with dark gray thumb
  - Hover state for better visibility
- **Volume-Based Sorting**: Successfully implemented sorting by 24h trading volume
  - Markets automatically sorted from highest to lowest volume (BTC ~$5.7B, ETH ~$3B, SOL ~$770M)
  - Volume displayed in millions format (e.g., Vol: $5717.3M)
  - Markets without price data show $0.00 instead of loading indicator
  - Fixed volume data extraction from Hyperliquid API using `dayNtlVlm` field
- **Market Data Integration**: Enhanced price fetching from Hyperliquid
  - Fetches mark prices from asset contexts for all markets
  - Orderbook prices for major markets (BTC, ETH, SOL, etc.) for accuracy
  - Volume data properly extracted from `dayNtlVlm` field in asset contexts
- **Text Color Fixes**: Improved visibility of unselected markets
  - Removed light gray text color from unselected markets for better readability
  - Unselected markets now use default white text with hover effects
  - Selected markets maintain white text with blue background highlight

### Centralized Fee Tracking System
- **Builder Code System**: Uses Hyperliquid's native builder fee system
  - Builder wallet address must have 100+ USDC in perps account
  - Users must approve builder address via ApproveBuilderFee action
  - Fee format: `{"b": builder_wallet_address, "f": fee_in_tenths_of_bps}`
  - Current fee: 10 = 1 basis point = 0.01% (max 0.1% for perps)
- **Fee Collection**: Fees collected through Hyperliquid's onchain fee logic
- **Database Schema**: Added feeTransactions and platformRevenueSummary tables
- **Storage Implementation**: Added comprehensive fee tracking methods:
  - recordFeeTransaction: Records individual trade fees
  - getFeeTransactions: Retrieves platform-specific transactions
  - updateRevenueSummary: Aggregates revenue data by period
  - getAllPlatformRevenues: Returns platform earnings summaries
- **API Endpoints**: New fee tracking endpoints:
  - POST /api/fees/record: Records new fee transactions
  - GET /api/fees/platform/:platformId: Gets platform transactions
  - GET /api/fees/summary/:platformId/:period: Gets revenue summaries
  - GET /api/fees/all-platforms: Gets all platform revenues
- **Revenue Distribution**: Automatic calculation of 70% platform / 30% LiquidLab split

## Recent Changes (January 2025)

### Platform Trust & Security Implementation (January 14, 2025)
- **Trust Indicators Component**: Created comprehensive trust display showing:
  - SSL security status
  - Privy wallet infrastructure
  - LiquidLab verification badge
  - Platform ID for verification
  - Detailed security features and verification instructions
- **Platform Verification Badge**: Hoverable badge showing platform verification status
  - Displays platform name, ID, and verification status
  - Links to liquidlab.com/verify for independent verification
- **Security Footer**: Comprehensive footer with security information
  - Platform details and verification links
  - Trust & compliance indicators
  - Support and documentation links
- **Security Documentation Page**: Created /security page explaining:
  - How to verify trading platforms before connecting wallets
  - Non-custodial architecture details
  - Infrastructure security measures
  - How to report suspicious platforms
- **Database Schema Update**: Added platform verification fields
  - isVerified: Boolean flag for platform verification status
  - verificationDate: Timestamp of verification
  - verificationNotes: Admin notes about verification
- **API Endpoints**: Added platform verification endpoints
  - GET /api/platforms/verify/:platformId - Public verification check
  - POST /api/admin/platforms/:platformId/verify - Admin verification action
- **Example Trading Page Integration**: Updated example page to demonstrate trust features
  - Trust indicators banner at top of page
  - Verification badge in header
  - Security footer with platform details

### Pricing Model Update (January 13, 2025)
- **Fee Structure Redesign**: Updated pricing page to emphasize zero upfront costs with revenue sharing model
  - Spot Trading: 0.2% builder fee (70% to platform owner, 30% to LiquidLab)
  - Perp Trading: 0.1% builder fee (70% to platform owner, 30% to LiquidLab)
  - No setup fees, monthly charges, or hidden costs
  - Platform owners only pay when they earn from actual trades
- **Enhanced FAQ**: Added detailed explanations about earnings potential and fee structures
- **Privy Wallet Infrastructure**: Added prominent section highlighting enterprise wallet integration at $0 extra cost
- **MoonPay Integration**: Added section showcasing automatic fiat on-ramp integration with every platform
  - Supports credit cards, bank transfers in 170+ countries
  - Built-in KYC/AML compliance
  - Platform owners can earn affiliate revenue from transactions

## Recent Changes (January 2025)

### Example Trading Page Enhancements
- **Position Details Section**: Added comprehensive leverage trading information including:
  - Total collateral and free collateral amounts
  - Unrealized PnL with percentage changes
  - Margin ratio with visual progress bar
  - Individual positions table with entry/mark/liquidation prices
  - Mobile-responsive card layout for positions on smaller screens

- **YouTube Video Integration**: Embedded compact MarketBeat video player in trading sidebar
  - Space-efficient design with one main video and quick list
  - Allows traders to watch market analysis while trading
  - Positioned in right column alongside order placement

- **Navigation Improvements**: Added LiquidLab navigation bar to example page
  - Quick links back to main platform (Home, Builder, Templates, Pricing, Dashboard)
  - "Powered by LiquidLab" branding with back arrow for easy return
  - Mobile-friendly responsive design

- **Price Display Fixes**: Resolved mobile spacing issues
  - Asset selector now full width on mobile devices
  - Chart time intervals wrap properly on small screens
  - Responsive padding adjustments across all breakpoints

- **Live Market Data**: Integrated CoinGecko API for real-time prices
  - 30-second auto-refresh intervals
  - Loading states and visual update indicators
  - Proper error handling for API failures

- **UI Refinements**: 
  - Reduced markets column width from w-64 to w-48 for more trading space
  - Reduced order book/trading panel width from w-[420px] to w-[340px] for better balance
  - Fixed buy/sell button styling with consistent green/red color scheme
  - Updated footer logo to new LiquidLab branding with larger size (h-40)

### Domain Migration (January 16, 2025)
- **Updated All Domain References**: Changed all instances of liquidlab.com to liquidlab.trade
  - Main site: liquidlab.trade  
  - App subdomain: app.liquidlab.trade
  - API endpoints: api.liquidlab.trade
  - Platform subdomains: [platform-name].liquidlab.trade
- **Admin Email Update**: Changed admin login email to admin@liquidlab.trade
- **Webhook URLs**: Updated Hyperliquid webhook endpoints to use .trade domain
- **Verification Links**: All platform verification links now point to liquidlab.trade/verify
- **Production Checklist**: Added domain configuration notes with SSL certificate requirements

### Trade Batch Processing Implementation (January 16, 2025)
- **Replaced Webhooks with Batch Processing**: Due to Hyperliquid only offering WebSocket streaming (not webhooks), implemented cost-effective batch processing
  - Automatic processing every 10 minutes via scheduler
  - Manual trigger endpoint at `/api/trades/process-batch` (admin only)
  - Status monitoring at `/api/trades/batch-status`
  - Avoids expensive 24/7 WebSocket connection costs
- **TradeBatchProcessor Service**: Created comprehensive trade processing system
  - Fetches recent trades from Hyperliquid API using getUserFills endpoint
  - Filters for LIQUIDLAB2025 builder code in cloid field
  - Calculates 70/30 revenue split automatically
  - Prevents duplicate processing with timestamp checks
  - Updates platform revenue summaries for all periods
- **Scheduler Service**: Automated job scheduling system
  - Runs trade batch processing every 10 minutes
  - Handles errors gracefully with audit logging
  - Starts automatically when server launches
  - Initial run 5 seconds after server startup
- **Development Mode**: Generates sample trades for testing
  - Creates demo trades with realistic fee calculations
  - Processes trades from 1 hour ago to ensure sample trades are captured
  - Successfully records fee transactions and updates revenue summaries
- **Production Requirements**:
  - Integrate with Privy to fetch wallet addresses for platform owners
  - Connect actual Hyperliquid user fills to LIQUIDLAB2025 builder code
  - Store wallet addresses when users connect through Privy authentication
- **Admin API Endpoints**: 
  - POST `/api/trades/process-batch` - Manually trigger batch processing
  - GET `/api/trades/batch-status` - View recent processing logs

### Spot Trading Re-Implementation (January 17, 2025)
- **Simple Spot Trading Added**: Created a simplified spot trading interface for available Hyperliquid spot tokens
  - Built new SimpleSpotTrading component with clean card-based design
  - **Discovery**: Hyperliquid uses "Universal" tokens for major assets:
    * BTC is available as UBTC/USDC (Universal BTC) - 1 UBTC = 1 BTC
    * ETH is available as UETH/USDC (Universal ETH) - 1 UETH = 1 ETH
    * SOL is available as USOL/USDC (Universal SOL) - 1 USOL = 1 SOL
  - **Pricing Fix (January 17, 2025)**: Fixed critical spot price display bug
    * Hyperliquid API returns raw prices that must be multiplied by 10^szDecimals
    * Each token has a specific szDecimals value (HYPE: 2, UBTC: 5, UETH: 4, USOL: 3)
    * Implemented decimal adjustment: actualPrice = rawPrice * (10 ^ token.szDecimals)
    * HYPE now correctly shows ~$44.77 instead of $0.44
    * All spot prices now display accurate USD values
  - **Available Tokens**: BTC (UBTC), ETH (UETH), SOL (USOL), PUMP, HYPE
  - **Not Available**: FARTCOIN (shows "Coming Soon" in UI)
  - Removed charts to prevent past integration issues - uses price cards instead
  - Added as "Spot" tab in both desktop and mobile interfaces
- **Backend Integration**: Implemented complete spot trading API support
  - GET /api/hyperliquid/spot-prices - Fetches real-time spot prices for HYPE and PUMP
  - POST /api/hyperliquid/spot-order - Handles spot order placement (requires wallet signature)
  - Added getSpotMetaAndAssetCtxs() to hyperliquidService for spot data fetching
  - Cleaned up debug logs for production-ready code
- **User Interface Features**:
  - 2-card grid showing HYPE and PUMP with price, 24h change, and volume
  - Selected market highlighted with green border
  - Buy/Sell toggle with green/red color coding
  - Real-time balance display for authenticated users
  - Total calculation showing USDC value of order
  - Info card explaining spot trading fees (0.2%)
  - White text styling for better readability on dark backgrounds
  - Volume displayed in millions format (e.g., $123.4M)
- **Security**: Spot orders require authentication and wallet signature for execution
- **UI Layout Improvements**: Trading interface optimizations remain
  - Constrained trading interface height to 600px to prevent overflow
  - Scrollable markets sidebar with proper overflow handling
  - Market stats bar above chart showing live prices and volume
  - Markets sidebar width at w-44 for optimal chart space
- **TradingView Chart**: Using iframe embed implementation
  - Reliable iframe embed for TradingView charts
  - No complex widget loading or "invalid signal" errors
  - Maintains dark theme and professional appearance

### Critical Hyperliquid Signing Fix (January 17, 2025)
- **Address Lowercasing Implementation**: Fixed critical signing issue where wallet addresses must be lowercased
  - All wallet addresses are now lowercased before signing to prevent "User or API Wallet does not exist" errors
  - Updated signOrder() to lowercase builder wallet address
  - Updated signTriggerOrder() to lowercase builder wallet address
  - Updated useHyperliquidTrading hook to lowercase user address before formatting order request
  - Updated SimpleSpotTrading component to lowercase wallet address before API calls
- **Technical Details**: Based on Hyperliquid documentation requirements
  - Addresses must be lowercased for proper signature recovery
  - Applies to both user addresses and builder wallet addresses
  - Critical for both perpetual and spot trading orders
- **Impact**: Resolves signature verification failures that prevented order placement

### Client Order ID Implementation (January 17, 2025)
- **Added Client Order ID (cloid) Support**: Implemented unique order tracking system for better order management
  - Generated unique 128-bit hex strings using timestamp + random bytes for each order
  - Added generateCloid() function that creates IDs like "0x000001945ab12345789abcdef0123456"
  - Updated SignedOrder interface to include cloid field for tracking
- **Complete Integration Across Order Types**:
  - Regular perpetual orders: cloid generated in signOrder()
  - Spot trading orders: cloid included in order structure
  - Trigger orders (TP/SL): cloid generated in signTriggerOrder()
  - All cloids automatically included in API submissions via order object
- **Benefits**: 
  - Enables order cancellation by cloid instead of needing order ID
  - Better tracking of orders across different trading sessions
  - Unique identifiers for audit trails and debugging
  - Future support for cancelByCloid endpoint

### Automatic Verification Code Rotation (January 16, 2025)
- **Enhanced Security Implementation**: Added automatic 24-hour verification code rotation for all trading platforms
  - New scheduler job runs every 24 hours to automatically regenerate all verification codes
  - Old codes are properly expired when new ones are generated
  - On server startup, system checks for and regenerates any expired codes
  - Ensures all platforms always have valid, fresh verification codes
- **Security Benefits**: 
  - Limited exposure window - compromised codes only valid for maximum 24 hours
  - Prevents code reuse attacks - old codes become invalid after rotation
  - Reduces social engineering risks - attackers can't use old screenshots or saved codes
  - Aligns with security best practices for time-limited authentication tokens
- **Implementation Details**:
  - Added `rotateAllCodes()` method to rotate all platform codes every 24 hours
  - Added `rotateExpiredCodes()` method to check and refresh expired codes on startup
  - Scheduler job 'verification-code-rotation' runs daily at same time
  - All rotation activities are logged for security audit trails

### Stable Checkpoint - Binance Charts Working (January 17, 2025)
- **Working State**: All trading functionality operational with Binance TradingView charts
- **Chart Implementation**: Using iframe embed of TradingView advanced chart widget
- **Data Source**: BINANCE exchange data for all trading pairs (e.g., BTCUSDT)
- **Features Working**: 
  - Full TradingView tools (drawing, indicators, analysis)
  - Real-time price updates from Hyperliquid for market stats
  - Trading interface with order placement
  - Positions display with live data
  - AI assistant integration
- **Known Limitation**: Charts show Binance prices instead of Hyperliquid's actual DEX prices
- **Reason for Checkpoint**: Before implementing toggle system for Hyperliquid charts

### Platform Verification System Fix (January 17, 2025)
- **Mobile UX Improvements**: Fixed critical mobile display issues
  - Reduced logo size from h-40 to h-24 on mobile screens for better fit
  - Added 5-second timeout to wallet connect button to prevent infinite loading state
  - Improved mobile responsiveness across all trading interface components
- **Verification Code Generation**: Fixed verification system not displaying codes
  - Added automatic verification code generation to platform creation process
  - Enhanced createTradingPlatform endpoint to call VerificationService.generateToken()
  - Created admin endpoint `/api/admin/generate-verification-codes` for existing platforms
  - Successfully generated 8-character alphanumeric codes for all 7 existing platforms
- **Verification Display**: Codes now properly show in UI components
  - PlatformVerificationBadge displays platform name, ID, and verification code
  - TrustIndicators component shows verification status with hoverable details
  - Verification codes enable users to independently verify platform authenticity
- **Example Codes Generated**:
  - Platform 1 (Marketbeat Trading): AC6408F1
  - Platform 8 (Marketbeat Trading): AEE08D54
  - All platforms now have unique verification codes for security
- **Verification Process Fix**: Resolved verification failing due to approval status and missing security record
  - Verification requires platforms to have `approval_status = 'approved'`
  - Example platform (ID 8) was in 'pending' status, preventing verification
  - Updated platform to 'approved' status
  - Created missing platform_security record with status = 'active' 
  - All three verification requirements now met: valid code, security clearance, and approval
  - Verification now works with code AEE08D54 for the example platform
- **Enhanced Verification Code Display** (January 17, 2025): Made verification codes prominently visible on trading platforms
  - Added dedicated blue-themed verification code section below trust indicators bar
  - Large, bold font display of the 8-character code with shield icon
  - One-click copy button for easy sharing
  - Clear instructions pointing to liquidlab.trade/verify
  - Fixed duplicate verification code display in builder Revenue tab
  - Verification codes now clearly visible to all platform visitors before they connect wallets

### TradingView UDF Server Implementation (January 16, 2025)
- **UDF Server Endpoints**: Implemented complete TradingView Universal Data Feed for Hyperliquid data
  - `/api/udf/config` - Configuration endpoint with supported resolutions and features
  - `/api/udf/symbols` - Symbol information endpoint for all Hyperliquid perpetual markets
  - `/api/udf/history` - Historical candle data endpoint with time range support
  - `/api/udf/search` - Symbol search endpoint for finding trading pairs
  - `/api/udf/time` - Server time endpoint for synchronization
- **Removed Chart Toggle System (January 17, 2025)**: Temporarily removed Hyperliquid charts
  - Deleted SimpleHyperliquidChart.tsx and TradingViewUDFChart.tsx components
  - Removed chart toggle functionality from trading interface
  - Keeping only TradingView Binance charts while waiting for TradingView license approval
  - Applied for TradingView Charting Library (1-2 week approval timeline)
- **Market Display**: Confirmed market cards show prices with 2 decimal places for accuracy
- **Trade Confirmation**: Verified trade confirmation dialog is fully implemented and working
  - Shows order details, leverage, margin requirements, and liquidation price
  - High leverage warning for positions ≥10x leverage
  - Color-coded buy/sell buttons with proper confirmation flow

### Crypto Payout System Implementation (January 16, 2025)
- **Complete Blockchain-Based Revenue Distribution**: Built comprehensive crypto payout system for platform owners
  - CryptoPayoutService using ethers.js for Arbitrum network integration
  - USDC transfers for stable, low-fee payouts to platform owners
  - Combined payouts include both trading fees (70%) and MoonPay commissions (50%)
  - Automatic payout processing with minimum threshold of $10
- **MoonPay Revenue Integration**: Enhanced payout system to include MoonPay earnings
  - Crypto payout service now calculates total earnings from both revenue streams
  - Single USDC transfer includes trading fees + MoonPay affiliate commissions
  - Payout records show breakdown: "Trading fees: $X, MoonPay: $Y"
  - Platform owners receive all earnings in one convenient crypto payment
- **Database Schema**: Added payoutRecords table to track all crypto payments
  - Tracks platform ID, amount, currency (USDC), transaction hash
  - Status tracking: pending → processing → completed
  - Notes field shows revenue breakdown between trading and MoonPay
  - Audit trail for all payout attempts and completions
- **Dashboard Integration**: Added dedicated Payouts tab showing:
  - Pending payouts with amounts and periods
  - Payout history with Arbiscan transaction links
  - Payout settings showing USDC on Arbitrum configuration
  - Weekly payout schedule information
- **API Endpoints**: Created payout management endpoints
  - GET `/api/payouts/platform/:platformId` - View payout history
  - GET `/api/payouts/pending/:platformId` - Check pending payouts
  - POST `/api/payouts/process` - Admin-only payout processing
- **Production Requirements**:
  - PAYOUT_WALLET_PRIVATE_KEY environment variable for payout wallet
  - ARBITRUM_RPC_URL for network connection
  - USDC funding in payout wallet for distributions

### Trust Indicators Enhancement (January 16, 2025)
- **Added Hyperliquid Connection Status**: Enhanced the security bar (TrustIndicators component) to show "Connected to Hyperliquid"
  - Live connection indicator with green pill background
  - Pulsing animation on the connection status icon
  - Clear visual confirmation that the platform is connected to Hyperliquid DEX
  - Tooltip explains "Live connection to Hyperliquid DEX established"

### Anti-Scam Security System Implementation (January 17, 2025)
- **Complete Security Infrastructure**: Built comprehensive anti-scam system to protect users from malicious platforms
  - SecurityService handles all security operations: platform monitoring, risk scoring, suspension/ban actions
  - Automatic security initialization when new platforms are created
  - Real-time content scanning for suspicious keywords and patterns on platform creation/updates
  - Risk score tracking with automatic suspension threshold (>100 points)
- **Database Schema Additions**: Added security-focused tables for complete monitoring
  - `platformSecurity`: Tracks security status, risk scores, and review states for each platform
  - `suspiciousActivity`: Records all security-related incidents and reports
  - Both tables have proper relations defined for database integrity
- **Automated Content Monitoring**: Proactive detection of scam patterns
  - Scans platform names, configs, and logos for suspicious content
  - Keywords detection: "guaranteed returns", "investment opportunity", "crypto mining", etc.
  - URL pattern matching for known phishing domains
  - Automatic risk score increases when suspicious content is detected
- **Admin Security Management**: Complete admin tools for platform moderation
  - GET /api/admin/platforms/suspicious - View all reported suspicious platforms
  - GET /api/admin/platforms/:id/security - Get detailed security status for a platform
  - POST /api/admin/platforms/:id/review - Review and approve/reject platforms
  - POST /api/admin/platforms/:id/suspend - Temporarily suspend platforms
  - POST /api/admin/platforms/:id/ban - Permanently ban malicious platforms
- **Integration with Core Features**: Security checks integrated throughout the platform
  - Platform creation automatically initializes security monitoring
  - Platform updates check if platform is allowed (not suspended/banned)
  - Content scanning on all platform modifications
  - Verification service checks security status before allowing verification
  - Dynamic imports used throughout routes.ts for proper async security handling

### Enhanced Security Implementation (January 17, 2025)
- **Rate Limiting**: Implemented comprehensive rate limiting to prevent API abuse
  - General API: 100 requests per 15 minutes per IP
  - Authentication: 5 attempts per 15 minutes with successful requests not counting
  - Trading endpoints: 30 requests per minute per user/IP
  - Memory-based storage for simple deployment (Redis-ready architecture)
- **CSRF Protection**: Added Cross-Site Request Forgery protection
  - Configured csurf middleware with secure cookies
  - Exempted webhook endpoints from CSRF checks
  - Token validation on all state-changing requests
- **Security Headers**: Implemented helmet.js with custom CSP policies
  - Content Security Policy allowing only trusted sources (TradingView, Hyperliquid, MoonPay)
  - HSTS with preloading for forced HTTPS
  - X-Frame-Options, X-Content-Type-Options, and other security headers
- **Input Validation & Sanitization**: Built comprehensive input sanitization
  - DOMPurify-based XSS prevention for all user inputs
  - Wallet address validation with regex patterns
  - Platform name validation (alphanumeric, 50 char limit)
  - URL and domain validation using validator.js
  - SQL injection prevention helpers
- **Anti-Phishing System**: Created multi-layer phishing protection
  - Anti-phishing code generation for users
  - Domain legitimacy verification
  - Suspicious URL pattern detection (homograph attacks, URL shorteners)
  - Email signature verification with HMAC
  - Security warning banner generation for compromised platforms
- **Enhanced Authentication Security**: Strengthened authentication system
  - Password strength validation (12+ chars, uppercase, lowercase, numbers, special)
  - Common password detection
  - 2FA support with TOTP (speakeasy integration)
  - QR code generation for 2FA setup
  - Login attempt tracking with lockout after 5 failures
  - Higher bcrypt cost factor (12) for password hashing
  - Suspicious IP detection based on proxy headers
- **Security Audit Logging**: Comprehensive event tracking system
  - Tracks all security events: logins, logouts, trades, admin actions
  - Captures IP addresses, user agents, and request metadata
  - Placeholder for anomaly detection algorithms
  - Structured logging for future SIEM integration
- **Webhook Security**: Implemented webhook verification
  - Signature verification for Hyperliquid, MoonPay, and Stripe
  - Timing-safe comparison to prevent timing attacks
  - Replay attack prevention with webhook ID tracking
  - 5-minute webhook age validation
- **Platform Security Service**: Advanced security monitoring
  - Automatic security initialization for new platforms
  - Content scanning with regex pattern matching
  - Risk scoring system (0-100) with auto-suspension at 80+
  - Platform suspension and ban functionality
  - API key generation and verification with SHA-256 hashing
  - Admin review queue for suspicious platforms
- **Integrated Security Configuration**: Centralized security setup
  - All security middleware applied in correct order
  - Error handling to prevent information leakage
  - Generic error messages for production
  - Session security with enhanced configuration

### Custom Domain Support System (January 16, 2025)
- **Domain Management Service**: Created comprehensive domain management system for platform owners
  - domainManager service handles domain operations (add, verify, remove)
  - Domain ownership verification via DNS TXT records
  - Active/pending status tracking for each domain
  - Platform mapping to allow custom domains instead of liquidlab.trade subdomains
- **API Endpoints**: Added domain management endpoints
  - POST /api/platforms/:id/domains - Add custom domain with verification token
  - POST /api/platforms/:id/domains/verify - Check DNS verification status
  - GET /api/platforms/:id/domains - List all domains for a platform
  - DELETE /api/platforms/:id/domains/:domain - Remove custom domain
- **CORS Middleware Update**: Enhanced platformCors to check custom domains
  - Checks static allowed origins first (liquidlab.trade and subdomains)
  - Falls back to database lookup for custom domains
  - Automatic CORS headers for verified custom domains
- **Builder Interface**: Added dedicated Domain tab in platform builder
  - CustomDomainManager component for managing domains
  - Clear instructions for DNS verification process
  - Shows pending/active status for each domain
  - Copy-to-clipboard functionality for DNS records
  - Requires platform to be saved before domain management
- **User Flow**:
  1. Platform owner adds custom domain in builder Domain tab
  2. System generates unique verification token
  3. Owner adds TXT record "_liquidlab" with token to their DNS
  4. Owner clicks "Verify Domain" after DNS propagation
  5. Once verified, platform accessible at custom domain

### PWA (Progressive Web App) Implementation (January 17, 2025)
- **Complete PWA Support**: Trading platforms can now be installed as native apps on mobile and desktop devices
  - Created web app manifest with LiquidLab branding and configuration
  - Implemented service worker for offline functionality and caching
  - Added install prompt that appears after 30 seconds of usage
  - Created offline fallback page for when users lose connectivity
- **Service Worker Features**: Advanced caching and offline capabilities
  - Static asset caching for faster load times
  - API response caching with network-first strategy
  - Background sync for offline trade submission
  - Push notification support for price alerts
  - Automatic cache updates every hour
- **User Experience Enhancements**: 
  - App icon with LiquidLab branding (SVG format for crisp display)
  - Standalone display mode removes browser UI for app-like experience
  - Theme color matches LiquidLab green (#1dd1a1)
  - Shortcuts for quick access to BTC and ETH trading
- **Installation Flow**: Simple process for traders
  - Banner appears after 30 seconds inviting installation
  - One-click install adds icon to home screen
  - Dismissing banner delays next prompt for 7 days
  - Automatic detection if app is already installed
- **Technical Implementation**:
  - PWAInstaller component handles installation prompts
  - Service worker registered on all pages
  - Meta tags for iOS and Android compatibility
  - Icons in 192x192 and 512x512 sizes

### PWA Security Hardening (January 17, 2025)
- **Fixed Critical Security Vulnerabilities**: Comprehensive security audit and fixes for PWA infrastructure
  - **Removed API Response Caching**: Service worker no longer caches sensitive endpoints like `/api/auth/`, `/api/trades/`, `/api/hyperliquid/`
  - **Cache Clearing on Logout**: Integrated PWA cache clearing into logout process to prevent data leakage
  - **Static-Only Caching**: Service worker now only caches static assets (JS, CSS, images), never user data
  - **Authentication Checks**: Added proper session validation before serving any cached content
  - **Cache Expiration**: Implemented 24-hour cache expiration with periodic checks every 30 minutes
- **Security Utilities**: Created `pwa-security.ts` with comprehensive security functions
  - `clearPWACachesOnLogout()`: Clears all caches, sessionStorage, and sensitive localStorage on logout
  - Integrated into both regular user logout and admin logout flows
  - Dispatches custom events for PWA components to handle cleanup
- **Removed Insecure Features**: 
  - Removed mentions of background sync for offline trades (could allow replay attacks)
  - Removed push notification references (could leak trading positions)
  - No longer caching API responses that could contain sensitive trading data
- **Data Protection Measures**:
  - Service worker message listener for 'CLEAR_CACHE' events
  - Automatic cache purging on service worker activation
  - Sensitive endpoint blocklist preventing accidental caching
  - All API requests now use network-only strategy

### Wallet Address Storage for Real Trade Processing (January 16, 2025)
- **Database Update**: Added walletAddress field to users table for storing Privy-connected wallet addresses
- **API Endpoint**: Created `/api/privy/wallet` endpoint to save wallet addresses when users connect
  - Automatically creates or updates user records with wallet addresses
  - Triggered when users connect through Privy authentication
- **WalletConnect Component**: Enhanced to automatically save wallet addresses on connection
  - Sends wallet address and email to backend when user authenticates
  - Enables real trade tracking for each platform owner
- **Trade Batch Processor**: Updated to use real wallet addresses for production
  - Fetches wallet addresses from database for each platform owner
  - Queries Hyperliquid API using actual wallet addresses
  - Filters trades with builder wallet configuration
  - Processes real trading fees with 70/30 revenue split
- **Automatic Builder Code Integration**: Fixed critical UX issue where users had to manually enter builder code
  - Updated hyperliquid-signing.ts to automatically include builder wallet with fee structure
  - All trades placed through any LiquidLab platform now automatically include the builder configuration
  - Trade batch processor detects and processes fees without any user action required
- **Production Ready**: System now ready to process real trades automatically
  - Users simply connect wallets and trade normally
  - Builder wallet address is automatically included in all orders
  - Trade batch runs every 10 minutes to check for new trades
  - Real-time revenue tracking and distribution enabled

### Privy Wallet Connection Fix (January 17, 2025)
- **Content Security Policy Update**: Fixed wallet connection issues by adding Privy's API domains to CSP
  - Added `https://auth.privy.io` and `https://*.privy.io` to connectSrc directive
  - Resolves "Refused to connect" errors when initializing Privy authentication
  - Applied fix to both main repository and open source repository

### Security Vulnerabilities Fixed (January 16, 2025)
- **CVE-2023-42282 SSRF Vulnerability**: Replaced express-rate-limit with custom rate limiting solution to avoid vulnerable dependency
- **ReDoS Vulnerability**: Fixed polynomial time complexity regex patterns in security scanner
  - Replaced complex regex patterns with simple string matching
  - Added input size limits (10KB max) to prevent DoS attacks
  - Created antiRedos.ts with safe pattern matching implementation
- **Missing Rate Limiting**: Added rate limiting middleware to expensive operations
  - Platform verification endpoint (uses auth limiter)
  - File upload endpoint (10 uploads per 15 minutes)
  - Applied rate limiting BEFORE expensive operations like database queries
- **Clear-text Logging of Sensitive Information**: Removed all instances of sensitive data logging
  - Removed admin password hash details and actual passwords from logs
  - Replaced platform content logging with content length only
  - Redacted API keys to show only prefix (first 8 chars) in audit logs
  - Sanitized security event logging to exclude sensitive details
- **Security Documentation**: Created comprehensive security resources
  - SECURITY_CHANGELOG.md documents all security fixes
  - SECURITY_BEST_PRACTICES.md provides secure development guidelines
  - Updated open source repository README with security references
- **Progress**: Fixed 9 of 14 security vulnerabilities identified by GitHub security scan

### Helmet Security Configuration Fix (January 17, 2025)
- **Fixed Critical Clickjacking Vulnerability**: Resolved insecure Helmet configuration that disabled frameguard
  - Previously: `frameguard: false` exposed application to clickjacking attacks
  - Fixed: `frameguard: { action: 'deny' }` now protects against clickjacking
  - Maintains CSP frameAncestors for granular iframe control
  - Applied fix to both server/security/headers.ts and liquidlab-open-source version
- **Security Benefits**: 
  - X-Frame-Options header now set to DENY
  - Prevents malicious sites from embedding the application in iframes
  - Works alongside Content Security Policy for defense in depth

### CORS Security Fix (January 17, 2025)
- **Fixed CORS Credential Vulnerability**: Resolved security issue with dynamic origin validation when credentials are allowed
  - Added protection against "null" origin attacks which could lead to credential theft
  - Enforced HTTPS-only origins in production when using credentials
  - Enhanced validation for custom domains from database
- **Security Improvements**:
  - Explicitly rejects "null" and "file://" origins to prevent local file attacks
  - Only allows HTTPS origins in production when Access-Control-Allow-Credentials is true
  - Maintains whitelist validation for all origins before allowing credentialed requests
  - Prevents attackers from stealing user credentials through malicious origins
- **Development Mode Fix (January 17, 2025)**: Enhanced CORS security in development mode
  - Added origin validation even in development to prevent credential leaks
  - Only allows http/https protocols when credentials are enabled
  - Prevents malicious origins from accessing credentials in development environments

### Multer Security Fix (January 17, 2025)
- **Fixed DoS Vulnerability in Multer**: Upgraded multer from 2.0.1 to 2.0.2 to fix critical security vulnerability
  - Vulnerability allowed attackers to trigger Denial of Service by sending malformed requests
  - Malformed requests caused unhandled exceptions leading to process crashes
  - Affected versions: >= 1.4.4-lts.1, < 2.0.2
  - Fix prevents attackers from crashing the server through file upload endpoints

### Client-Side URL Redirect Fix (January 17, 2025)
- **Fixed Client-Side URL Redirect Vulnerability**: Added URL validation to prevent XSS and redirect attacks
  - Created urlValidator utility with validateImageUrl and validateRedirectUrl functions
  - Validates URLs against allowed protocols (http/https only)
  - Blocks dangerous schemes like javascript:, data:, vbscript:
  - Applied validation to platformData.logoUrl and preview logo URLs in example.tsx
  - Prevents attackers from injecting malicious URLs that could redirect users or execute scripts

### Deposit Security Infrastructure Implementation (January 17, 2025)
- **Database Schema**: Added depositTransactions table to track all deposit operations
  - Tracks amounts, addresses, transaction hashes, and security metadata
  - Implements proper audit trail with creation timestamps and status tracking
- **Configuration Service**: Created secure contract address validation
  - Backend-only contract address storage preventing frontend manipulation
  - Environment-based configuration (mainnet/testnet) with whitelisting
  - Validates Ethereum addresses and enforces minimum deposit amounts
- **Deposit Service**: Built comprehensive deposit management system
  - Rate limiting: 5 deposits per hour, 10 per day, $10,000 daily volume limit
  - Suspicious activity detection with automatic security alerts
  - Complete audit logging for all deposit operations
  - Validates all contract addresses against backend whitelist
- **API Endpoints**: Secured deposit endpoints with authentication and rate limiting
  - GET /api/deposit/config - Returns validated contract addresses
  - POST /api/deposit/record - Records new deposits with full validation
  - GET /api/deposit/history - Shows user's deposit history
  - GET /api/deposit/rate-status - Checks remaining rate limits
- **Audit Integration**: All deposit operations logged to audit trail
  - Successful deposits, validation failures, rate limit violations tracked
  - IP addresses and user agents recorded for security monitoring
  - Proper error handling without exposing sensitive information

### Integrated USDC Deposit/Withdrawal System (January 17, 2025)
- **Critical User Retention Feature**: Implemented integrated deposit system to prevent users from leaving to Hyperliquid main site
  - Users can now deposit USDC from Arbitrum directly within our trading interface
  - No need to leave LiquidLab platforms to add funds - crucial for retention
- **HyperliquidDeposit Component**: Created comprehensive fund management interface
  - Real-time balance display showing both Arbitrum USDC and Hyperliquid balances
  - Deposit tab: Send USDC from Arbitrum to Hyperliquid (minimum 5 USDC, ~1 minute processing)
  - Withdraw tab: Placeholder for withdrawals (requires wallet signature, users directed to Hyperliquid)
  - Automatic balance refresh every 5 seconds
  - Clear error handling and user feedback via toast notifications
- **Backend Integration**: Added API endpoints for balance checking and fund management
  - GET `/api/hyperliquid/balances/:address` - Fetches user's Hyperliquid balance and account info
  - POST `/api/hyperliquid/withdraw` - Placeholder endpoint for future withdrawal implementation
  - Integrates with existing Hyperliquid service for real-time balance data
- **UI Integration**: Seamlessly integrated into trading interface
  - Desktop: Added "Funds" tab in right sidebar alongside "Trade" tab
  - Mobile: Added "Funds" tab in mobile navigation between "Trade" and "AI"
  - Users can manage funds without leaving the trading screen
- **Technical Implementation**:
  - Uses Hyperliquid bridge contract: 0x2df1c51e09aecf9cacb7bc98cb1742757f163df7
  - Arbitrum USDC contract: 0xaf88d065e77c8cc2239327c5edb3a432268e5831
  - Ethers.js integration for blockchain interactions through Privy provider
  - Minimum deposit enforced at 5 USDC (amounts below are lost forever)
- **User Experience Benefits**:
  - Eliminates friction of leaving platform to deposit funds
  - Integrated experience keeps users engaged with our platform
  - Real-time balance updates provide confidence
  - Clear UI with deposit/withdrawal separation

### Trade Execution Architecture Decision (January 17, 2025)
- **Current Implementation**: Each trade requires individual wallet signature (EIP-712)
  - Trade execution speed: ~200-400ms after signing (~1 second total with signing)
  - Maximum security with users maintaining full control of every trade
  - No persistent keys or delegated signing risks
- **Agent Wallet Research**: Investigated Hyperliquid's agent wallet system
  - Would enable instant trades without per-trade signing (like official Hyperliquid site)
  - Implementation complexity: 5-7 days of development
  - Requires secure storage of agent wallet private keys
  - Most competitors (Bullpen.fi, etc.) use standard wallet signing like us
- **Decision**: Keep current per-trade signing system
  - Already fast enough for professional trading
  - Provides superior security for platform owners
  - Aligns with industry standard practices
  - Agent wallet system can be added later if needed

### Leverage UI Improvements (January 16, 2025)
- **Leverage Slider Implementation**: Replaced dropdown selector with visual slider interface
  - Smooth sliding experience for selecting leverage from 1x to token's maximum
  - Current leverage value prominently displayed above slider
  - Visual tick marks showing key leverage points
  - Blue-filled slider bar indicating selected leverage level
- **Dynamic Maximum Leverage**: Implemented token-specific leverage limits from Hyperliquid
  - Each market passes its maxLeverage property (e.g., BTC: 50x, ETH: 25x, smaller tokens: 5x-10x)
  - Slider automatically adjusts maximum value when switching between tokens
  - Visual indicators below slider dynamically update (e.g., for 10x max: shows 1x, 3x, 5x, 8x, 10x)
  - Prevents users from exceeding Hyperliquid's allowed leverage for each token
  - Automatic leverage reduction when switching to tokens with lower maximums
- **User Experience**: Seamless leverage management with real-time updates
  - No manual checking of leverage limits required
  - Clear visual feedback on available leverage range
  - Protects traders from accidentally selecting invalid leverage values

### MoonPay Integration Implementation (January 16, 2025)
- **MoonPay Widget Integration**: Added MoonPay fiat-to-crypto on-ramp to all trading platforms
  - Created MoonPayButton component with embedded widget functionality
  - Integrated into example trading page header next to wallet connection
  - Purple gradient "Buy Crypto" button opens MoonPay modal dialog
  - Widget configured with dark theme matching platform design
- **Automatic Wallet Integration**: MoonPay widget receives connected wallet address
  - Retrieves wallet address from Privy authentication
  - Pre-fills wallet address in MoonPay form for seamless experience
  - Supports USDC as default cryptocurrency purchase option
- **Revenue Tracking Integration**: Automatic affiliate commission tracking
  - Listens for MoonPay transaction completion events via postMessage
  - Records transactions to database for 1% affiliate revenue sharing
  - 50/50 split between platform owner and LiquidLab on all purchases
- **Backend Configuration**: MoonPay API configuration endpoint
  - Created /api/moonpay/config endpoint for API key management
  - Supports environment variables for production deployment
  - Test mode available for development environments
- **Universal Availability**: MoonPay now available on all deployed platforms
  - No additional setup required by platform owners
  - Automatic integration with every new platform created
  - Supports 170+ countries with credit card and bank transfers

### "Powered by Hyperliquid" Logo Integration (January 17, 2025)
- **Logo Placement**: Added "Powered by Hyperliquid" logo in strategic locations
  - SecurityFooter component: Displayed at bottom center with opacity transition on hover
  - TrustIndicators component: Large standalone logo (h-24) without background, next to connection status
  - Logo file stored at `/public/powered-by-hyperliquid.png`
  - Prominent display acknowledges Hyperliquid DEX as the trading engine

### UI Improvements (January 17, 2025)
- **Teal Security Theme**: Changed all security indicators from green to teal to match Hyperliquid branding
  - Security bar icons (Shield, SSL, Privy, checkmarks) now use teal colors
  - Platform verification badge uses teal instead of green
  - All hover states updated to teal shades
  - Consistent teal theme across all security-related UI elements
  - Creates cohesive branding with the "Powered by Hyperliquid" logo

### UI Improvements (January 16, 2025)
- **Removed Redundant Elements**: Cleaned up the trading interface
  - Removed "Verified" stamp from security bar (already shown in header verification badge)
  - Removed "Powered by LiquidLab" text from header for cleaner appearance
- **Increased Logo Size**: Made uploaded platform logos more prominent
  - Increased logo height from h-24 to h-32 for better visibility
  - Logos now display at appropriate size on all trading platforms
- **MoonPay White Screen Fix**: Added proper error handling for missing API keys
  - Shows user-friendly message instead of white screen when MoonPay API key is missing
  - Clear instructions that production API key is needed from MoonPay
- **USD Quoting Display**: Enhanced trading interface to properly show USD values when USD mode is selected
  - Buy/Sell buttons now show "$100 USD" instead of "0.0008 BTC" when USD mode is active
  - Trade confirmation dialog displays size in USD format (e.g., "$100.00 USD")
  - Fixed all text color issues in confirmation dialog - all values now display in white
  - Cancel button in confirmation dialog now has red border and text with hover effects
- **Dark Scrollbar Styling** (January 16, 2025): Implemented black scrollbars throughout trading interface
  - Global dark scrollbar styles for all scrollable areas (#000000 track, #1a1a1a thumb)
  - Applied custom-scrollbar class to markets sidebar, positions area, and trading form
  - All scrollbars now match Hyperliquid's ultra-dark aesthetic
- **Dark Leverage Slider**: Created custom CSS for leverage slider component
  - Dark track (#0d0d0d) with green range indicator (#1dd1a1)
  - Dark thumb (#1a1a1a) with green border matching brand colors
  - Smooth hover states and focus indicators for better UX
- **Mobile Tab Indicator Fix** (January 17, 2025): Fixed mobile tab indicator not updating
  - Replaced CSS border approach with absolute positioned divs for better visibility
  - Added debug logging to track state changes
  - Green indicator now properly moves between Markets, Chart, Trade, and AI tabs
  - Active tab shows white text with green underline indicator
- **Bank-Level Security Section** (January 17, 2025): Added comprehensive security section to homepage
  - Created dark gradient section highlighting enterprise security features
  - **Immutable Trading Code card** (highlighted with green border): Platform owners cannot modify trading logic
  - Security feature cards: SSL/TLS, Non-Custodial Architecture, 2FA, Anti-Phishing, Rate Limiting, Audit Logging
  - Additional security measures section with CSRF protection, input sanitization, security headers details
  - Platform verification, suspicious activity monitoring, webhook verification highlights
  - SOC 2 Type II compliance badge for trust building
  - Green notification banner emphasizing verified codebase shared by all platforms
  - Emphasizes that every LiquidLab platform is deployed with bank-level security

### API Reliability Improvements (January 17, 2025)
- **Reduced API Call Frequency**: Changed all real-time data fetching from 2-second to 5-second intervals
  - Example trading page market data updates every 5 seconds
  - HyperliquidTradingInterface live price updates every 5 seconds
  - User positions and open orders refresh every 5 seconds
  - Prevents rate limiting (429 errors) from Hyperliquid API
- **Retry Logic Implementation**: Added exponential backoff for failed API calls
  - Retries up to 3 times with delays of 1s, 2s, 4s (exponential backoff)
  - Only retries server errors (5xx), not client errors (4xx)
  - Prevents silent failures when API is temporarily unavailable
- **Error State Management**: Added visible error states and user feedback
  - Platform and market errors display in red banner with retry button
  - Users can manually retry failed requests
  - Clear error messages instead of silent failures
- **Caching Implementation**: Added 5-second cache for market data
  - Reduces redundant API calls for the same data
  - Improves performance and reduces server load
  - Cache automatically expires after 5 seconds for fresh data

### Polymarket Integration Feature (January 17, 2025)
- **Multi-Protocol Support**: Added experimental Polymarket prediction markets integration as premium feature
  - Created PolymarketInterface component for prediction market trading
  - Added "Predictions" tab to both desktop (right sidebar) and mobile trading interfaces
  - Implements automatic network switching from Hyperliquid to Polygon when accessing predictions
  - Configured Privy for multi-chain support (Ethereum, Polygon, Arbitrum)
- **Network Switching UX**: Seamless wallet network management
  - Automatic prompt to switch to Polygon when clicking Predictions tab
  - No wallet reconnection needed - uses same Privy session across chains
  - Clear visual indicator when network switch is required
  - One-click network switching with loading states
- **Premium Monetization Model**: $50/month subscription + 0.5% platform fee
  - Platform owners can charge additional 0.5% fee on all prediction trades
  - Frontend fee collection method (transparent to users)
  - Sample markets include crypto prices, economic indicators, and ETF flows
  - Purple-themed UI to distinguish from Hyperliquid trading interface
- **Technical Implementation**: Modular design that doesn't affect existing Hyperliquid functionality
  - Separate component architecture keeps prediction markets isolated
  - Uses Privy's multi-chain configuration for network management
  - Ready for Polymarket API integration when revenue model is validated
  - Mobile-responsive design matching existing trading interface patterns
- **Enhanced UX Without Wallet**: Markets browsable without authentication
  - Users can view all prediction markets and probabilities without connecting wallet
  - Wallet connection only required when placing actual predictions
  - Improved accessibility for users exploring the platform
- **Professional UI Formatting**: Compact and efficient interface design
  - Compact header with small "Premium" badge
  - Market cards with green/red color coding for Yes/No outcomes
  - 2/3 width market list, 1/3 betting interface for optimal space usage
  - Smaller font sizes and tighter spacing for information density
  - Custom dark scrollbars matching Hyperliquid aesthetic
  - Added diverse sample markets covering crypto, politics, and economics
- **Site-Wide Polymarket Promotion**: Highlighted premium feature throughout platform
  - Added "NEW: Polymarket Premium" to home page hero section
  - Created dedicated Polymarket section on home page with purple gradient background
  - Updated templates page with 3 options: Hyperliquid only (free), Hyperliquid + Polymarket ($50/month), Polymarket only ($50/month)
  - Added Premium Add-Ons section to pricing page showcasing Polymarket benefits
  - Consistent purple theme and pricing ($50/month + 0.5% platform fee) across all mentions
- **Desktop Scrolling Fix**: Resolved critical scrolling issue in Polymarket prediction markets
  - Applied absolute positioning with `inset-0` to ensure proper height constraints
  - Wrapped PolymarketInterface in container with relative positioning
  - Users can now scroll through all prediction markets in crypto category without cutoff
  - Fixed issue where bottom options were inaccessible due to overflow constraints

### Payout Management System Implementation (January 17, 2025)
- **Critical Issue Resolved**: Fixed automated payout failures caused by Hyperliquid's manual claiming requirement
  - Hyperliquid requires admins to manually claim builder fees - funds don't automatically transfer
  - Implemented semi-automated solution with comprehensive management interface
- **BuilderFeeManager Service**: Created new service to handle the fee claiming workflow
  - Tracks unclaimed fees from database (fees recorded but not claimed from Hyperliquid)
  - Monitors claimed but not converted fees (claimed from Hyperliquid but still in native tokens)
  - Checks USDC balance in payout wallet before processing distributions
  - Provides payout readiness status with detailed breakdown by platform
- **Database Schema Updates**: Added tracking fields to fee transactions
  - `claimed_at` timestamp field to track when fees were claimed from Hyperliquid
  - `claimTxHash` field to store the transaction hash of the claim operation
  - Enables differentiation between unclaimed and claimed fees
- **Admin Dashboard Enhancements**: New Payouts tab with comprehensive management tools
  - Payout Readiness Status: Shows if system is ready to process payouts
  - Unclaimed Fees Card: Displays total fees waiting to be claimed on Hyperliquid
  - Wallet Balances: Shows builder wallet (Hyperliquid) and payout wallet (Arbitrum) balances
  - Claim Management: Interface to mark fees as claimed with transaction hash
  - Transfer Management: Tool to transfer USDC from builder to payout wallet
  - Process Payouts Button: Only enabled when system has sufficient USDC balance
- **Workflow Process**: Semi-automated claiming and distribution
  1. Trade batch processor records fees to database (automated)
  2. Admin manually claims fees on Hyperliquid (manual)
  3. Admin marks fees as claimed in dashboard with tx hash
  4. Admin converts claimed tokens to USDC and transfers to payout wallet
  5. System processes weekly payouts automatically when balance is sufficient
- **API Endpoints**: New admin endpoints for payout management
  - GET `/api/admin/payout-readiness` - Check if system is ready for payouts
  - GET `/api/admin/unclaimed-fees` - Get unclaimed fee totals
  - POST `/api/admin/claim-fees` - Mark fees as claimed with transaction details
  - POST `/api/admin/transfer-to-payout` - Transfer USDC to payout wallet
  - GET `/api/admin/wallet-balances` - Get current wallet balances

### AI-Powered Chat Assistant Integration (January 16, 2025)
- **Perplexity API Integration**: Created AI market assistant for real-time trading insights
  - Built `/api/ai/market-chat` endpoint using Perplexity's llama-3.1-sonar model
  - Supports market analysis, price predictions, and trading strategy questions
  - Context-aware responses using current market and price data
  - Requires PERPLEXITY_API_KEY environment variable for production
- **Compact AI Assistant Component**: Designed space-efficient chat interface
  - Ultra-compact 180px height to maximize trading interface space
  - Positioned below trading form in right sidebar
  - Minimal padding and condensed UI elements
  - Short welcome message to save vertical space
  - Real-time message updates with timestamps
- **User Experience**: Professional AI assistant integrated into trading workflow
  - Traders can ask questions while monitoring markets
  - Instant analysis without leaving the trading interface
  - Context-aware responses based on selected market
  - Loading indicators and error handling for smooth experience

### Admin Dashboard Setup (January 16, 2025)
- **Admin Authentication**: Successfully configured admin access
  - Admin password stored as bcrypt hash in ADMIN_PASSWORD environment variable
  - Login endpoint at `/api/admin/login` with email/password authentication
  - Admin dashboard accessible at `/admin/dashboard` after authentication
- **Security Implementation**: Removed hardcoded credentials for production security
  - Eliminated hardcoded admin password from server code
  - Created admin password generation utility script
  - Environment variable-based authentication system
- **Admin Dashboard Features**: Full access to platform analytics and management
  - View total revenue across all platforms (30% LiquidLab / 70% Platform Owners)
  - Monitor individual platform performance and transaction history
  - Track user counts, active platforms, and system metrics
  - Automated trade batch processing running every 10 minutes

### Error Message Cleanup (January 17, 2025)
- **Removed Platform Data Error Display**: Eliminated "unable to load platform data" error banner from example trading page
  - Removed entire error message section (lines 303-322) from example.tsx
  - Platform and market errors still logged to console but no longer shown to users
  - Cleaner user experience without distracting error banners
  - Trading interface continues to function normally even if platform data load fails

### Trader Analytics System Implementation (January 17, 2025)
- **Database Schema**: Added comprehensive trader tracking tables
  - `traderActivity` table: Tracks individual trader volumes, trade counts, fees generated
  - `incentiveTiers` table: Manages incentive levels for volume-based rewards
  - Successfully applied database migration with all relations properly configured
- **API Endpoints**: Built complete RESTful API for trader analytics
  - GET `/api/trader-analytics/platform/:platformId` - Platform-specific analytics dashboard
  - GET `/api/trader-analytics/platform/:platformId/traders` - List all traders for a platform
  - GET `/api/trader-analytics/incentives/:platformId` - Manage incentive tiers
  - POST `/api/trader-analytics/incentives/:platformId` - Create new incentive tiers
- **UI Component**: Created comprehensive TraderAnalytics.tsx component
  - Top traders leaderboard showing volumes and fees generated
  - Recent trader activity with transaction details
  - Incentive tier management with CRUD operations
  - Visual charts and statistics for platform analytics
- **Dashboard Integration**: Successfully integrated as 6th tab in main dashboard
  - Added "Trader Analytics" tab between "Platform Revenues" and "Payouts"
  - Auto-selects first platform if multiple exist
  - Shows helpful message if no platforms created yet
  - Tab grid updated from 5 to 6 columns to accommodate new feature
---

# Configuration Files

## File: package.json

```json
{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "NODE_ENV=development tsx server/index.ts",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node dist/index.js",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^0.10.4",
    "@privy-io/react-auth": "^2.18.1",
    "@privy-io/server-auth": "^1.28.4",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.3",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@sendgrid/mail": "^8.1.5",
    "@stripe/react-stripe-js": "^3.7.0",
    "@stripe/stripe-js": "^7.4.0",
    "@tanstack/react-query": "^5.60.5",
    "@types/bcryptjs": "^2.4.6",
    "@types/memoizee": "^0.4.12",
    "@types/multer": "^2.0.0",
    "bcryptjs": "^3.0.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "connect-pg-simple": "^10.0.0",
    "csurf": "^1.11.0",
    "date-fns": "^3.6.0",
    "drizzle-orm": "^0.39.1",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.6.0",
    "ethers": "^6.15.0",
    "express": "^4.21.2",
    "express-rate-limit": "^8.0.0",
    "express-session": "^1.18.1",
    "framer-motion": "^11.13.1",
    "helmet": "^8.1.0",
    "input-otp": "^1.4.2",
    "isomorphic-dompurify": "^2.26.0",
    "lightweight-charts": "^5.0.8",
    "lucide-react": "^0.453.0",
    "memoizee": "^0.4.17",
    "memorystore": "^1.6.7",
    "multer": "^2.0.2",
    "nanoid": "^5.1.5",
    "next-themes": "^0.4.6",
    "openid-client": "^6.6.2",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "qrcode": "^1.5.4",
    "rate-limit-redis": "^4.2.1",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.55.0",
    "react-icons": "^5.4.0",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.4",
    "redis": "^5.6.0",
    "speakeasy": "^2.0.0",
    "stripe": "^18.3.0",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.2.5",
    "validator": "^13.15.15",
    "vaul": "^1.1.2",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.24.2",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.2.7",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@tailwindcss/vite": "^4.1.3",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.2",
    "@types/node": "20.16.11",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.30.4",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.19"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}

```

---

## File: tsconfig.json

```json
{
  "include": ["client/src/**/*", "shared/**/*", "server/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"]
    }
  }
}

```

---

## File: vite.config.ts

```typescript
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";

export default defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...(process.env.NODE_ENV !== "production" &&
    process.env.REPL_ID !== undefined
      ? [
          await import("@replit/vite-plugin-cartographer").then((m) =>
            m.cartographer(),
          ),
        ]
      : []),
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets"),
    },
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true,
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"],
    },
  },
});

```

---

## File: drizzle.config.ts

```typescript
import { defineConfig } from "drizzle-kit";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL, ensure the database is provisioned");
}

export default defineConfig({
  out: "./migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});

```

---

## File: tailwind.config.ts

```typescript
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./client/index.html", "./client/src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "var(--background)",
        foreground: "var(--foreground)",
        card: {
          DEFAULT: "var(--card)",
          foreground: "var(--card-foreground)",
        },
        popover: {
          DEFAULT: "var(--popover)",
          foreground: "var(--popover-foreground)",
        },
        primary: {
          DEFAULT: "var(--primary)",
          foreground: "var(--primary-foreground)",
        },
        secondary: {
          DEFAULT: "var(--secondary)",
          foreground: "var(--secondary-foreground)",
        },
        muted: {
          DEFAULT: "var(--muted)",
          foreground: "var(--muted-foreground)",
        },
        accent: {
          DEFAULT: "var(--accent)",
          foreground: "var(--accent-foreground)",
        },
        destructive: {
          DEFAULT: "var(--destructive)",
          foreground: "var(--destructive-foreground)",
        },
        border: "var(--border)",
        input: "var(--input)",
        ring: "var(--ring)",
        chart: {
          "1": "var(--chart-1)",
          "2": "var(--chart-2)",
          "3": "var(--chart-3)",
          "4": "var(--chart-4)",
          "5": "var(--chart-5)",
        },
        sidebar: {
          DEFAULT: "var(--sidebar-background)",
          foreground: "var(--sidebar-foreground)",
          primary: "var(--sidebar-primary)",
          "primary-foreground": "var(--sidebar-primary-foreground)",
          accent: "var(--sidebar-accent)",
          "accent-foreground": "var(--sidebar-accent-foreground)",
          border: "var(--sidebar-border)",
          ring: "var(--sidebar-ring)",
        },
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
} satisfies Config;

```

---

# Database Schema

## File: shared/schema.ts

```typescript
import { pgTable, text, serial, integer, boolean, timestamp, jsonb, decimal, varchar, date, index, unique } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  email: text("email").notNull().unique(),
  password: text("password").notNull(),
  walletAddress: text("wallet_address"),
  builderCode: text("builder_code").unique(),
  referralCode: text("referral_code").unique(),
  twoFactorSecret: text("two_factor_secret"),
  twoFactorEnabled: boolean("two_factor_enabled").default(false),
  twoFactorBackupCodes: text("two_factor_backup_codes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const tradingPlatforms = pgTable("trading_platforms", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  name: text("name").notNull(),
  slug: text("slug").notNull().unique(),
  subdomain: text("subdomain").unique(), // For centralized SaaS model: platform1.liquidlab.trade
  templateId: integer("template_id"),
  config: jsonb("config").notNull(),
  isPublished: boolean("is_published").default(false),
  customDomain: text("custom_domain"),
  logoUrl: text("logo_url"),
  payoutWallet: text("payout_wallet"),
  isVerified: boolean("is_verified").default(false),
  verificationDate: timestamp("verification_date"),
  verificationNotes: text("verification_notes"),
  approvalStatus: text("approval_status").default("pending"), // 'pending', 'approved', 'rejected'
  approvalDate: timestamp("approval_date"),
  approvalNotes: text("approval_notes"),
  rejectionReason: text("rejection_reason"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const templates = pgTable("templates", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  category: text("category").notNull(),
  previewImage: text("preview_image"),
  config: jsonb("config").notNull(),
  isPublic: boolean("is_public").default(true),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const revenueRecords = pgTable("revenue_records", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  platformId: integer("platform_id"),
  type: text("type").notNull(), // 'builder_fee', 'referral_fee'
  amount: decimal("amount", { precision: 18, scale: 8 }).notNull(),
  currency: text("currency").default("USDC"),
  txHash: text("tx_hash"),
  metadata: jsonb("metadata"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const referrals = pgTable("referrals", {
  id: serial("id").primaryKey(),
  referrerId: integer("referrer_id").notNull(),
  referredUserId: integer("referred_user_id").notNull(),
  volume: decimal("volume", { precision: 18, scale: 8 }).default("0"),
  commissionEarned: decimal("commission_earned", { precision: 18, scale: 8 }).default("0"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Production infrastructure tables
export const apiKeys = pgTable("api_keys", {
  id: serial("id").primaryKey(),
  platformId: integer("platform_id").notNull().references(() => tradingPlatforms.id, { onDelete: "cascade" }),
  key: varchar("key", { length: 64 }).notNull().unique(),
  secretHash: varchar("secret_hash", { length: 128 }).notNull(),
  name: varchar("name", { length: 100 }),
  permissions: jsonb("permissions").notNull().default('["read", "write"]'),
  rateLimit: integer("rate_limit").notNull().default(1000), // requests per hour
  lastUsedAt: timestamp("last_used_at"),
  expiresAt: timestamp("expires_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  revokedAt: timestamp("revoked_at"),
}, (table) => [
  index("idx_api_keys_platform").on(table.platformId),
  index("idx_api_keys_key").on(table.key),
]);

export const platformDomains = pgTable("platform_domains", {
  id: serial("id").primaryKey(),
  platformId: integer("platform_id").notNull().references(() => tradingPlatforms.id, { onDelete: "cascade" }),
  domain: varchar("domain", { length: 255 }).notNull().unique(),
  isVerified: boolean("is_verified").notNull().default(false),
  verificationToken: varchar("verification_token", { length: 64 }),
  sslEnabled: boolean("ssl_enabled").notNull().default(true),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  verifiedAt: timestamp("verified_at"),
}, (table) => [
  index("idx_platform_domains_platform").on(table.platformId),
  index("idx_platform_domains_domain").on(table.domain),
]);

export const rateLimits = pgTable("rate_limits", {
  id: serial("id").primaryKey(),
  identifier: varchar("identifier", { length: 255 }).notNull(), // IP or API key
  endpoint: varchar("endpoint", { length: 255 }).notNull(),
  requests: integer("requests").notNull().default(1),
  windowStart: timestamp("window_start").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("idx_rate_limits_identifier").on(table.identifier),
  index("idx_rate_limits_window").on(table.windowStart),
]);

export const auditLogs = pgTable("audit_logs", {
  id: serial("id").primaryKey(),
  platformId: integer("platform_id").references(() => tradingPlatforms.id),
  userId: integer("user_id").references(() => users.id),
  action: varchar("action", { length: 100 }).notNull(),
  resource: varchar("resource", { length: 100 }),
  resourceId: varchar("resource_id", { length: 100 }),
  ipAddress: varchar("ip_address", { length: 45 }),
  userAgent: text("user_agent"),
  metadata: jsonb("metadata"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("idx_audit_logs_platform").on(table.platformId),
  index("idx_audit_logs_user").on(table.userId),
  index("idx_audit_logs_created").on(table.createdAt),
]);

export const platformMetrics = pgTable("platform_metrics", {
  id: serial("id").primaryKey(),
  platformId: integer("platform_id").notNull().references(() => tradingPlatforms.id, { onDelete: "cascade" }),
  date: date("date").notNull(),
  uniqueVisitors: integer("unique_visitors").notNull().default(0),
  pageViews: integer("page_views").notNull().default(0),
  tradingVolume: decimal("trading_volume", { precision: 20, scale: 8 }).notNull().default('0'),
  revenueGenerated: decimal("revenue_generated", { precision: 20, scale: 8 }).notNull().default('0'),
  apiCalls: integer("api_calls").notNull().default(0),
  errorRate: decimal("error_rate", { precision: 5, scale: 2 }).notNull().default('0'),
  avgResponseTime: integer("avg_response_time"), // milliseconds
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("idx_platform_metrics_platform_date").on(table.platformId, table.date),
]);

// Fee tracking for revenue distribution
export const feeTransactions = pgTable("fee_transactions", {
  id: serial("id").primaryKey(),
  platformId: integer("platform_id").notNull().references(() => tradingPlatforms.id, { onDelete: "cascade" }),
  tradeId: varchar("trade_id", { length: 255 }).notNull(), // External trade ID from Hyperliquid
  tradeType: text("trade_type").notNull(), // 'spot' or 'perp'
  tradeVolume: decimal("trade_volume", { precision: 20, scale: 8 }).notNull(),
  feeRate: decimal("fee_rate", { precision: 10, scale: 6 }).notNull(), // 0.002 for spot, 0.001 for perp
  totalFee: decimal("total_fee", { precision: 20, scale: 8 }).notNull(),
  platformShare: decimal("platform_share", { precision: 20, scale: 8 }).notNull(), // 70% of total fee
  liquidlabShare: decimal("liquidlab_share", { precision: 20, scale: 8 }).notNull(), // 30% of total fee
  status: text("status").notNull().default("pending"), // pending, claimed, distributed, failed
  claimedAt: timestamp("claimed_at"), // When fees were claimed from Hyperliquid
  claimTxHash: varchar("claim_tx_hash", { length: 66 }), // Hyperliquid claim transaction hash
  distributedAt: timestamp("distributed_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("idx_fee_platform_date").on(table.platformId, table.createdAt),
  index("idx_fee_status").on(table.status),
]);

// Platform revenue summary for easy dashboard display
export const platformRevenueSummary = pgTable("platform_revenue_summary", {
  id: serial("id").primaryKey(),
  platformId: integer("platform_id").notNull().references(() => tradingPlatforms.id, { onDelete: "cascade" }),
  period: varchar("period", { length: 20 }).notNull(), // 'daily', 'weekly', 'monthly', 'all-time'
  startDate: date("start_date").notNull(),
  endDate: date("end_date").notNull(),
  totalVolume: decimal("total_volume", { precision: 20, scale: 8 }).notNull().default('0'),
  totalFees: decimal("total_fees", { precision: 20, scale: 8 }).notNull().default('0'),
  platformEarnings: decimal("platform_earnings", { precision: 20, scale: 8 }).notNull().default('0'), // 70% share
  liquidlabEarnings: decimal("liquidlab_earnings", { precision: 20, scale: 8 }).notNull().default('0'), // 30% share
  tradeCount: integer("trade_count").notNull().default(0),
  lastUpdated: timestamp("last_updated").defaultNow().notNull(),
}, (table) => [
  unique("idx_platform_period_unique").on(table.platformId, table.period, table.startDate),
]);

// MoonPay affiliate transactions
export const moonpayTransactions = pgTable("moonpay_transactions", {
  id: serial("id").primaryKey(),
  platformId: integer("platform_id").notNull().references(() => tradingPlatforms.id, { onDelete: "cascade" }),
  transactionId: varchar("transaction_id", { length: 255 }).unique().notNull(),
  purchaseAmount: decimal("purchase_amount", { precision: 20, scale: 2 }).notNull(), // USD amount of crypto purchased
  affiliateFee: decimal("affiliate_fee", { precision: 20, scale: 4 }).notNull(), // 1% of purchase amount
  platformEarnings: decimal("platform_earnings", { precision: 20, scale: 4 }).notNull(), // 50% of affiliate fee
  liquidlabEarnings: decimal("liquidlab_earnings", { precision: 20, scale: 4 }).notNull(), // 50% of affiliate fee
  currency: varchar("currency", { length: 10 }).notNull().default('USD'),
  status: varchar("status", { length: 20 }).notNull().default('pending'), // 'pending', 'completed', 'failed'
  createdAt: timestamp("created_at").defaultNow().notNull(),
  completedAt: timestamp("completed_at"),
}, (table) => [
  index("idx_moonpay_platform_date").on(table.platformId, table.createdAt),
  index("idx_moonpay_status").on(table.status),
]);

// Crypto payout records
export const payoutRecords = pgTable("payout_records", {
  id: serial("id").primaryKey(),
  platformId: integer("platform_id").notNull().references(() => tradingPlatforms.id, { onDelete: "cascade" }),
  userId: integer("user_id").notNull().references(() => users.id),
  amount: decimal("amount", { precision: 20, scale: 4 }).notNull(), // Amount in USDC
  currency: varchar("currency", { length: 10 }).notNull().default('USDC'),
  status: varchar("status", { length: 20 }).notNull().default('pending'), // 'pending', 'processing', 'completed', 'failed'
  txHash: varchar("tx_hash", { length: 66 }), // Transaction hash
  chainId: integer("chain_id").default(42161), // Arbitrum One
  recipientAddress: varchar("recipient_address", { length: 42 }).notNull(),
  error: text("error"), // Error message if failed
  periodStart: date("period_start").notNull(),
  periodEnd: date("period_end").notNull(),
  processedAt: timestamp("processed_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("idx_payout_platform").on(table.platformId),
  index("idx_payout_status").on(table.status),
  index("idx_payout_processed").on(table.processedAt),
]);

// Platform verification tokens that rotate periodically
export const platformVerificationTokens = pgTable("platform_verification_tokens", {
  id: serial("id").primaryKey(),
  platformId: integer("platform_id").notNull().references(() => tradingPlatforms.id, { onDelete: "cascade" }),
  verificationCode: varchar("verification_code", { length: 12 }).notNull().unique(), // Short code for easy typing
  securityHash: varchar("security_hash", { length: 64 }).notNull().unique(), // SHA-256 hash for cryptographic verification
  isActive: boolean("is_active").notNull().default(true),
  expiresAt: timestamp("expires_at").notNull(), // Token expires after 24 hours
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("idx_verification_code").on(table.verificationCode),
  index("idx_verification_active").on(table.isActive, table.expiresAt),
  index("idx_verification_platform").on(table.platformId),
]);

// Verification attempts for security auditing
export const verificationAttempts = pgTable("verification_attempts", {
  id: serial("id").primaryKey(),
  attemptedCode: varchar("attempted_code", { length: 255 }).notNull(),
  ipAddress: varchar("ip_address", { length: 45 }).notNull(),
  userAgent: text("user_agent"),
  success: boolean("success").notNull(),
  platformId: integer("platform_id"), // Null if verification failed
  errorReason: varchar("error_reason", { length: 255 }), // 'invalid_code', 'expired', 'rate_limited'
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("idx_attempt_ip").on(table.ipAddress, table.createdAt),
  index("idx_attempt_code").on(table.attemptedCode),
]);

// Trader analytics - tracks individual trader activity per platform
export const traderActivity = pgTable("trader_activity", {
  id: serial("id").primaryKey(),
  platformId: integer("platform_id").notNull().references(() => tradingPlatforms.id, { onDelete: "cascade" }),
  walletAddress: varchar("wallet_address", { length: 42 }).notNull(), // Trader's wallet address
  totalVolume: decimal("total_volume", { precision: 20, scale: 8 }).notNull().default('0'),
  totalFees: decimal("total_fees", { precision: 20, scale: 8 }).notNull().default('0'),
  tradeCount: integer("trade_count").notNull().default(0),
  lastTradeAt: timestamp("last_trade_at"),
  firstTradeAt: timestamp("first_trade_at"),
  averageTradeSize: decimal("average_trade_size", { precision: 20, scale: 8 }).notNull().default('0'),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("idx_trader_platform_wallet").on(table.platformId, table.walletAddress),
  index("idx_trader_volume").on(table.platformId, table.totalVolume),
  unique("idx_trader_unique").on(table.platformId, table.walletAddress),
]);

// Trader incentive tiers - configurable by platform owners
export const incentiveTiers = pgTable("incentive_tiers", {
  id: serial("id").primaryKey(),
  platformId: integer("platform_id").notNull().references(() => tradingPlatforms.id, { onDelete: "cascade" }),
  tierName: varchar("tier_name", { length: 50 }).notNull(),
  minVolume: decimal("min_volume", { precision: 20, scale: 2 }).notNull(), // Minimum USD volume
  feeDiscount: decimal("fee_discount", { precision: 5, scale: 2 }).notNull().default('0'), // Percentage discount
  rewards: jsonb("rewards"), // Custom rewards like bonuses, badges, etc.
  color: varchar("color", { length: 7 }).default('#1dd1a1'), // Hex color for UI
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("idx_tier_platform").on(table.platformId),
  index("idx_tier_volume").on(table.platformId, table.minVolume),
]);

// Platform security monitoring
export const platformSecurity = pgTable("platform_security", {
  id: serial("id").primaryKey(),
  platformId: integer("platform_id").notNull().references(() => tradingPlatforms.id, { onDelete: "cascade" }),
  status: varchar("status", { length: 50 }).notNull().default("active"), // active, suspended, banned, under-review
  suspendedAt: timestamp("suspended_at"),
  suspendedReason: text("suspended_reason"),
  bannedAt: timestamp("banned_at"),
  bannedReason: text("banned_reason"),
  lastReviewedAt: timestamp("last_reviewed_at"),
  reviewNotes: text("review_notes"),
  riskScore: integer("risk_score").default(0), // 0-100, higher = more suspicious
  flaggedContent: jsonb("flagged_content"), // Store suspicious URLs, scripts, etc.
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  unique("idx_platform_security_unique").on(table.platformId),
  index("idx_platform_security_status").on(table.status),
]);

// Suspicious activity logs
export const suspiciousActivity = pgTable("suspicious_activity", {
  id: serial("id").primaryKey(),
  platformId: integer("platform_id").references(() => tradingPlatforms.id),
  userId: integer("user_id").references(() => users.id),
  activityType: varchar("activity_type", { length: 100 }).notNull(), // rapid_verification_attempts, suspicious_links, content_violation, etc.
  description: text("description").notNull(),
  ipAddress: varchar("ip_address", { length: 45 }),
  userAgent: text("user_agent"),
  metadata: jsonb("metadata"),
  severity: varchar("severity", { length: 20 }).notNull().default("medium"), // low, medium, high, critical
  isResolved: boolean("is_resolved").default(false),
  resolvedAt: timestamp("resolved_at"),
  resolvedBy: integer("resolved_by").references(() => users.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("idx_suspicious_activity_platform").on(table.platformId),
  index("idx_suspicious_activity_type").on(table.activityType),
  index("idx_suspicious_activity_severity").on(table.severity),
]);

// Deposit transactions tracking
export const depositTransactions = pgTable("deposit_transactions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  walletAddress: varchar("wallet_address", { length: 255 }).notNull(),
  amount: decimal("amount", { precision: 20, scale: 6 }).notNull(),
  currency: varchar("currency", { length: 10 }).notNull().default('USDC'),
  fromNetwork: varchar("from_network", { length: 50 }).notNull().default('arbitrum'),
  toNetwork: varchar("to_network", { length: 50 }).notNull().default('hyperliquid'),
  txHash: varchar("tx_hash", { length: 255 }),
  status: varchar("status", { length: 50 }).notNull().default('pending'), // pending, confirmed, failed
  bridgeAddress: varchar("bridge_address", { length: 255 }).notNull(),
  ipAddress: varchar("ip_address", { length: 45 }),
  userAgent: text("user_agent"),
  metadata: jsonb("metadata"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  confirmedAt: timestamp("confirmed_at"),
}, (table) => [
  index("idx_deposit_user").on(table.userId),
  index("idx_deposit_wallet").on(table.walletAddress),
  index("idx_deposit_status").on(table.status),
  index("idx_deposit_created").on(table.createdAt),
]);

// Relations
export const usersRelations = relations(users, ({ many }) => ({
  platforms: many(tradingPlatforms),
  revenueRecords: many(revenueRecords),
  referrals: many(referrals, { relationName: "referrer" }),
  referredBy: many(referrals, { relationName: "referred" }),
  depositTransactions: many(depositTransactions),
}));

export const tradingPlatformsRelations = relations(tradingPlatforms, ({ one, many }) => ({
  user: one(users, {
    fields: [tradingPlatforms.userId],
    references: [users.id],
  }),
  template: one(templates, {
    fields: [tradingPlatforms.templateId],
    references: [templates.id],
  }),
  revenueRecords: many(revenueRecords),
  apiKeys: many(apiKeys),
  domains: many(platformDomains),
  metrics: many(platformMetrics),
  auditLogs: many(auditLogs),
  feeTransactions: many(feeTransactions),
  revenueSummaries: many(platformRevenueSummary),
  moonpayTransactions: many(moonpayTransactions),
  payoutRecords: many(payoutRecords),
  verificationTokens: many(platformVerificationTokens),
  verificationAttempts: many(verificationAttempts),
}));

export const templatesRelations = relations(templates, ({ many }) => ({
  platforms: many(tradingPlatforms),
}));

export const revenueRecordsRelations = relations(revenueRecords, ({ one }) => ({
  user: one(users, {
    fields: [revenueRecords.userId],
    references: [users.id],
  }),
  platform: one(tradingPlatforms, {
    fields: [revenueRecords.platformId],
    references: [tradingPlatforms.id],
  }),
}));

export const referralsRelations = relations(referrals, ({ one }) => ({
  referrer: one(users, {
    fields: [referrals.referrerId],
    references: [users.id],
    relationName: "referrer",
  }),
  referredUser: one(users, {
    fields: [referrals.referredUserId],
    references: [users.id],
    relationName: "referred",
  }),
}));

export const apiKeysRelations = relations(apiKeys, ({ one }) => ({
  platform: one(tradingPlatforms, {
    fields: [apiKeys.platformId],
    references: [tradingPlatforms.id],
  }),
}));

export const platformDomainsRelations = relations(platformDomains, ({ one }) => ({
  platform: one(tradingPlatforms, {
    fields: [platformDomains.platformId],
    references: [tradingPlatforms.id],
  }),
}));

export const platformMetricsRelations = relations(platformMetrics, ({ one }) => ({
  platform: one(tradingPlatforms, {
    fields: [platformMetrics.platformId],
    references: [tradingPlatforms.id],
  }),
}));

export const auditLogsRelations = relations(auditLogs, ({ one }) => ({
  platform: one(tradingPlatforms, {
    fields: [auditLogs.platformId],
    references: [tradingPlatforms.id],
  }),
  user: one(users, {
    fields: [auditLogs.userId],
    references: [users.id],
  }),
}));

export const feeTransactionsRelations = relations(feeTransactions, ({ one }) => ({
  platform: one(tradingPlatforms, {
    fields: [feeTransactions.platformId],
    references: [tradingPlatforms.id],
  }),
}));

export const platformRevenueSummaryRelations = relations(platformRevenueSummary, ({ one }) => ({
  platform: one(tradingPlatforms, {
    fields: [platformRevenueSummary.platformId],
    references: [tradingPlatforms.id],
  }),
}));

export const moonpayTransactionsRelations = relations(moonpayTransactions, ({ one }) => ({
  platform: one(tradingPlatforms, {
    fields: [moonpayTransactions.platformId],
    references: [tradingPlatforms.id],
  }),
}));

export const payoutRecordsRelations = relations(payoutRecords, ({ one }) => ({
  platform: one(tradingPlatforms, {
    fields: [payoutRecords.platformId],
    references: [tradingPlatforms.id],
  }),
  user: one(users, {
    fields: [payoutRecords.userId],
    references: [users.id],
  }),
}));

export const platformVerificationTokensRelations = relations(platformVerificationTokens, ({ one }) => ({
  platform: one(tradingPlatforms, {
    fields: [platformVerificationTokens.platformId],
    references: [tradingPlatforms.id],
  }),
}));

export const verificationAttemptsRelations = relations(verificationAttempts, ({ one }) => ({
  platform: one(tradingPlatforms, {
    fields: [verificationAttempts.platformId],
    references: [tradingPlatforms.id],
  }),
}));

export const depositTransactionsRelations = relations(depositTransactions, ({ one }) => ({
  user: one(users, {
    fields: [depositTransactions.userId],
    references: [users.id],
  }),
}));

export const traderActivityRelations = relations(traderActivity, ({ one }) => ({
  platform: one(tradingPlatforms, {
    fields: [traderActivity.platformId],
    references: [tradingPlatforms.id],
  }),
}));

export const incentiveTiersRelations = relations(incentiveTiers, ({ one }) => ({
  platform: one(tradingPlatforms, {
    fields: [incentiveTiers.platformId],
    references: [tradingPlatforms.id],
  }),
}));

// Insert schemas
export const insertUserSchema = createInsertSchema(users).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertTradingPlatformSchema = createInsertSchema(tradingPlatforms).omit({
  id: true,
  slug: true,
  createdAt: true,
  updatedAt: true,
});

export const insertTemplateSchema = createInsertSchema(templates).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertRevenueRecordSchema = createInsertSchema(revenueRecords).omit({
  id: true,
  createdAt: true,
});

export const insertReferralSchema = createInsertSchema(referrals).omit({
  id: true,
  createdAt: true,
});

export const insertApiKeySchema = createInsertSchema(apiKeys).omit({
  id: true,
  createdAt: true,
  lastUsedAt: true,
  revokedAt: true,
});

export const insertPlatformDomainSchema = createInsertSchema(platformDomains).omit({
  id: true,
  createdAt: true,
  verifiedAt: true,
});

export const insertRateLimitSchema = createInsertSchema(rateLimits).omit({
  id: true,
  createdAt: true,
});

export const insertAuditLogSchema = createInsertSchema(auditLogs).omit({
  id: true,
  createdAt: true,
});

export const insertPlatformMetricSchema = createInsertSchema(platformMetrics).omit({
  id: true,
  createdAt: true,
});

export const insertFeeTransactionSchema = createInsertSchema(feeTransactions).omit({
  id: true,
  createdAt: true,
  distributedAt: true,
});

export const insertPlatformRevenueSummarySchema = createInsertSchema(platformRevenueSummary).omit({
  id: true,
  lastUpdated: true,
});

export const insertMoonpayTransactionSchema = createInsertSchema(moonpayTransactions).omit({
  id: true,
  createdAt: true,
  completedAt: true,
});

export const insertPayoutRecordSchema = createInsertSchema(payoutRecords).omit({
  id: true,
  createdAt: true,
  processedAt: true,
});

export const insertPlatformVerificationTokenSchema = createInsertSchema(platformVerificationTokens).omit({
  id: true,
  createdAt: true,
});

export const insertVerificationAttemptSchema = createInsertSchema(verificationAttempts).omit({
  id: true,
  createdAt: true,
});

export const insertDepositTransactionSchema = createInsertSchema(depositTransactions).omit({
  id: true,
  createdAt: true,
  confirmedAt: true,
});

export const insertTraderActivitySchema = createInsertSchema(traderActivity).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertIncentiveTierSchema = createInsertSchema(incentiveTiers).omit({
  id: true,
  createdAt: true,
});

// Types
export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;
export type TradingPlatform = typeof tradingPlatforms.$inferSelect;
export type InsertTradingPlatform = z.infer<typeof insertTradingPlatformSchema>;
export type Template = typeof templates.$inferSelect;
export type InsertTemplate = z.infer<typeof insertTemplateSchema>;
export type RevenueRecord = typeof revenueRecords.$inferSelect;
export type InsertRevenueRecord = z.infer<typeof insertRevenueRecordSchema>;
export type Referral = typeof referrals.$inferSelect;
export type InsertReferral = z.infer<typeof insertReferralSchema>;
export type ApiKey = typeof apiKeys.$inferSelect;
export type InsertApiKey = z.infer<typeof insertApiKeySchema>;
export type PlatformDomain = typeof platformDomains.$inferSelect;
export type InsertPlatformDomain = z.infer<typeof insertPlatformDomainSchema>;
export type RateLimit = typeof rateLimits.$inferSelect;
export type InsertRateLimit = z.infer<typeof insertRateLimitSchema>;
export type AuditLog = typeof auditLogs.$inferSelect;
export type InsertAuditLog = z.infer<typeof insertAuditLogSchema>;
export type PlatformMetric = typeof platformMetrics.$inferSelect;
export type InsertPlatformMetric = z.infer<typeof insertPlatformMetricSchema>;
export type FeeTransaction = typeof feeTransactions.$inferSelect;
export type InsertFeeTransaction = z.infer<typeof insertFeeTransactionSchema>;
export type PlatformRevenueSummary = typeof platformRevenueSummary.$inferSelect;
export type InsertPlatformRevenueSummary = z.infer<typeof insertPlatformRevenueSummarySchema>;
export type MoonpayTransaction = typeof moonpayTransactions.$inferSelect;
export type InsertMoonpayTransaction = z.infer<typeof insertMoonpayTransactionSchema>;
export type PayoutRecord = typeof payoutRecords.$inferSelect;
export type InsertPayoutRecord = z.infer<typeof insertPayoutRecordSchema>;
export type PlatformVerificationToken = typeof platformVerificationTokens.$inferSelect;
export type InsertPlatformVerificationToken = z.infer<typeof insertPlatformVerificationTokenSchema>;
export type VerificationAttempt = typeof verificationAttempts.$inferSelect;
export type InsertVerificationAttempt = z.infer<typeof insertVerificationAttemptSchema>;
export type DepositTransaction = typeof depositTransactions.$inferSelect;
export type InsertDepositTransaction = z.infer<typeof insertDepositTransactionSchema>;
export type TraderActivity = typeof traderActivity.$inferSelect;
export type InsertTraderActivity = z.infer<typeof insertTraderActivitySchema>;
export type IncentiveTier = typeof incentiveTiers.$inferSelect;
export type InsertIncentiveTier = z.infer<typeof insertIncentiveTierSchema>;

```

---

# Server Code

## File: server/db.ts

```typescript
import { Pool, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-serverless';
import ws from "ws";
import * as schema from "@shared/schema";

neonConfig.webSocketConstructor = ws;

if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?",
  );
}

export const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle({ client: pool, schema });
```

---

## File: server/index.ts

```typescript
import express, { type Request, Response, NextFunction } from "express";
import session from "express-session";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";
import { scheduler } from "./services/scheduler";
import { configureSecurity } from "./security";
import { configureSecureSession } from "./security/auth";
import { resolvePlatform } from "./middleware/platformResolver";

const app = express();

// Body parsers must come before CSRF protection
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: false, limit: '10mb' }));

// Session configuration with enhanced security must come before CSRF
const sessionConfig = process.env.SESSION_SECRET 
  ? configureSecureSession()
  : {
      secret: 'dev-secret-change-in-production',
      resave: false,
      saveUninitialized: false,
      cookie: {
        secure: process.env.NODE_ENV === 'production',
        httpOnly: true,
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
      }
    };
app.use(session(sessionConfig));

// Apply security configuration after body parsers and session
configureSecurity(app);

// Apply platform resolver middleware for multi-tenant SaaS
app.use(resolvePlatform);

// Serve uploaded files statically
app.use('/uploads', express.static('uploads'));

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "…";
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  const server = await registerRoutes(app);

  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    res.status(status).json({ message });
    throw err;
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }

  // ALWAYS serve the app on the port specified in the environment variable PORT
  // Other ports are firewalled. Default to 5000 if not specified.
  // this serves both the API and the client.
  // It is the only port that is not firewalled.
  const port = parseInt(process.env.PORT || '5000', 10);
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true,
  }, () => {
    log(`serving on port ${port}`);
    
    // Start the scheduler for batch processing
    scheduler.start().catch(error => {
      console.error('Failed to start scheduler:', error);
    });
  });
})();

```

---

## File: server/middleware/platformResolver.ts

```typescript
import { Request, Response, NextFunction } from 'express';
import { db } from '../db';
import { tradingPlatforms } from '@shared/schema';
import { eq } from 'drizzle-orm';

// Extend Express Request to include platform data
declare global {
  namespace Express {
    interface Request {
      platform?: {
        id: number;
        name: string;
        ownerId: string;
        config: any;
        logoUrl?: string | null;
        isCustomDomain?: boolean;
        domain?: string;
      };
    }
  }
}

/**
 * Middleware to resolve which platform to serve based on the incoming domain
 */
export async function resolvePlatform(req: Request, res: Response, next: NextFunction) {
  try {
    const host = req.hostname.toLowerCase();
    
    // Skip resolution for main domain and API/admin routes
    if (host === 'liquidlab.trade' || 
        host === 'localhost' ||
        req.path.startsWith('/api/') ||
        req.path.startsWith('/admin/')) {
      return next();
    }
    
    let platform = null;
    let isCustomDomain = false;
    
    // Check if it's a subdomain of liquidlab.trade
    if (host.endsWith('.liquidlab.trade') || host.endsWith('.app.liquidlab.trade')) {
      // Extract subdomain (e.g., "platform1" from "platform1.liquidlab.trade")
      const subdomain = host.split('.')[0];
      
      // Find platform by subdomain
      const [foundPlatform] = await db
        .select()
        .from(tradingPlatforms)
        .where(eq(tradingPlatforms.subdomain, subdomain))
        .limit(1);
        
      platform = foundPlatform;
    } else {
      // Check custom domains - custom domains are stored in tradingPlatforms.customDomain
      const [foundPlatform] = await db
        .select()
        .from(tradingPlatforms)
        .where(eq(tradingPlatforms.customDomain, host))
        .limit(1);
        
      if (foundPlatform) {
        platform = foundPlatform;
        isCustomDomain = true;
      }
    }
    
    // If no platform found, continue (will show 404 or main site)
    if (!platform) {
      return next();
    }
    
    // Attach platform data to request
    req.platform = {
      id: platform.id,
      name: platform.name,
      ownerId: platform.userId.toString(), // Convert to string for consistency
      config: platform.config,
      logoUrl: platform.logoUrl,
      isCustomDomain,
      domain: host
    };
    
    next();
  } catch (error) {
    console.error('Platform resolution error:', error);
    next();
  }
}

/**
 * Middleware to ensure a platform is resolved (for platform-specific routes)
 */
export function requirePlatform(req: Request, res: Response, next: NextFunction) {
  if (!req.platform) {
    return res.status(404).json({ message: 'Platform not found' });
  }
  next();
}
```

---

## File: server/routes.ts

```typescript
import type { Express, Request } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { z } from "zod";
import { insertUserSchema, insertTradingPlatformSchema, insertTemplateSchema, insertRevenueRecordSchema, feeTransactions, users, auditLogs } from "@shared/schema";
import { HyperliquidService } from "./services/hyperliquid";
import multer from "multer";
import path from "path";
import fs from "fs/promises";
import bcrypt from "bcryptjs";
import { db } from "./db";
import { desc, sql, eq } from "drizzle-orm";
// Removed webhook imports - using batch processing instead
import ConfigurationService from "./services/configService";
import DepositService from "./services/depositService";
import { authLimiter } from "./security/customRateLimiter";

// Extend Express session types
declare module "express-session" {
  interface SessionData {
    userId?: number;
    isAdmin?: boolean;
    adminEmail?: string;
  }
}

const hyperliquidService = new HyperliquidService();

// Configure multer for file uploads
const uploadDir = 'uploads';
fs.mkdir(uploadDir, { recursive: true }).catch(console.error);

const multerStorage = multer.diskStorage({
  destination: async (req, file, cb) => {
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, 'logo-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({ 
  storage: multerStorage,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB limit
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = /jpeg|jpg|png|gif|webp/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    
    if (mimetype && extname) {
      return cb(null, true);
    } else {
      cb(new Error('Only image files are allowed'));
    }
  }
});

function handleError(error: unknown): string {
  return error instanceof Error ? error.message : 'Unknown error';
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Admin authentication
  const ADMIN_EMAIL = process.env.ADMIN_EMAIL || "admin@liquidlab.trade";
  const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD; // Required environment variable
  
  app.post("/api/admin/login", async (req, res) => {
    try {
      const { email, password, totp } = req.body;
      
      // Check if admin credentials are configured
      if (!ADMIN_PASSWORD) {
        return res.status(500).json({ message: "Admin authentication not configured" });
      }
      
      // Check if it's the admin
      if (email !== ADMIN_EMAIL) {
        return res.status(401).json({ message: "Invalid credentials" });
      }
      
      // Verify password against environment variable
      const validPassword = await bcrypt.compare(password, ADMIN_PASSWORD);
      if (!validPassword) {
        return res.status(401).json({ message: "Invalid credentials" });
      }

      // Check if admin 2FA is enabled
      const admin2FASecret = process.env.ADMIN_2FA_SECRET;
      const admin2FAEnabled = process.env.ADMIN_2FA_ENABLED === 'true';
      
      if (admin2FAEnabled && admin2FASecret) {
        if (!totp) {
          return res.status(200).json({ 
            requiresTwoFactor: true 
          });
        }

        // Import auth utilities dynamically
        const { verify2FAToken } = await import("./security/auth");
        
        if (!verify2FAToken(admin2FASecret, totp)) {
          return res.status(401).json({ message: "Invalid 2FA code" });
        }
      }
      
      // Set admin session
      req.session.isAdmin = true;
      req.session.adminEmail = email;
      
      res.json({ 
        success: true,
        admin: { email }
      });
    } catch (error) {
      console.error("Admin login error:", error);
      res.status(500).json({ message: "Login failed" });
    }
  });
  
  app.get("/api/admin/check", (req, res) => {
    if (req.session.isAdmin) {
      res.json({ 
        isAdmin: true,
        email: req.session.adminEmail 
      });
    } else {
      res.json({ isAdmin: false });
    }
  });
  
  app.post("/api/admin/logout", (req, res) => {
    req.session.isAdmin = false;
    req.session.adminEmail = undefined;
    res.json({ success: true });
  });
  
  // Admin-only middleware
  const requireAdmin = (req: Request, res: Response, next: NextFunction) => {
    if (!req.session.isAdmin) {
      return res.status(401).json({ message: "Admin access required" });
    }
    next();
  };
  
  // Temporary endpoint to generate verification codes for existing platforms
  app.post("/api/admin/generate-verification-codes", requireAdmin, async (req, res) => {
    try {
      const { VerificationService } = await import("./services/verification");
      const platforms = await storage.getTradingPlatforms();
      const results = [];
      
      for (const platform of platforms) {
        const { code } = await VerificationService.generateToken(platform.id);
        results.push({ platformId: platform.id, name: platform.name, code });
      }
      
      res.json({ message: 'Verification codes generated', results });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });
  
  // Admin dashboard data
  app.get("/api/admin/dashboard", requireAdmin, async (req, res) => {
    console.log("Admin dashboard request - session:", req.session);
    try {
      // Get all platforms with user info
      const allPlatforms = await storage.getTradingPlatforms();
      
      // Get all fee transactions
      const allTransactions = await db.select().from(feeTransactions).orderBy(desc(feeTransactions.createdAt)).limit(100);
      
      // Get revenue summaries
      const revenueSummaries = await storage.getAllPlatformRevenues();
      
      // Calculate totals
      const totalRevenue = revenueSummaries.reduce((sum, r) => sum + parseFloat(r.totalFees || '0'), 0);
      const liquidlabRevenue = revenueSummaries.reduce((sum, r) => sum + parseFloat(r.liquidlabEarnings || '0'), 0);
      const platformOwnerRevenue = revenueSummaries.reduce((sum, r) => sum + parseFloat(r.platformEarnings || '0'), 0);
      
      // Get user count
      const userCount = await db.select({ count: sql<number>`count(*)` }).from(users);
      
      // Get MoonPay stats
      const moonpayStats = await storage.getMoonpayRevenueSummary();
      
      res.json({
        platforms: allPlatforms,
        recentTransactions: allTransactions,
        revenueSummaries,
        stats: {
          totalRevenue: totalRevenue.toFixed(2),
          liquidlabRevenue: liquidlabRevenue.toFixed(2),
          platformOwnerRevenue: platformOwnerRevenue.toFixed(2),
          platformCount: allPlatforms.length,
          userCount: userCount[0].count,
          transactionCount: allTransactions.length
        },
        moonpayStats
      });
    } catch (error) {
      console.error("Admin dashboard error - detailed:", error);
      res.status(500).json({ message: "Failed to fetch admin data", error: error.message });
    }
  });

  // Admin user management endpoints
  app.get("/api/admin/users", requireAdmin, async (req, res) => {
    try {
      const allUsers = await storage.getAllUsers();
      
      // Format users for display (exclude password hashes)
      const formattedUsers = allUsers.map(user => ({
        id: user.id,
        username: user.username,
        email: user.email,
        walletAddress: user.walletAddress,
        builderCode: user.builderCode,
        referralCode: user.referralCode,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt
      }));
      
      res.json({ users: formattedUsers });
    } catch (error) {
      console.error("Error fetching users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });

  app.post("/api/admin/users/:userId/reset-password", requireAdmin, async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const { newPassword } = req.body;
      
      if (!newPassword || newPassword.length < 8) {
        return res.status(400).json({ message: "Password must be at least 8 characters long" });
      }
      
      // Hash the new password
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      
      // Update the user's password
      await storage.updateUserPassword(userId, hashedPassword);
      
      res.json({ success: true, message: "Password reset successfully" });
    } catch (error) {
      console.error("Error resetting password:", error);
      res.status(500).json({ message: "Failed to reset password" });
    }
  });

  // Authentication routes
  app.post("/api/auth/signup", async (req, res) => {
    try {
      const { username, email, password } = req.body;
      
      // Check if user already exists
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({ error: "User with this email already exists" });
      }
      
      const existingUsername = await storage.getUserByUsername(username);
      if (existingUsername) {
        return res.status(400).json({ error: "Username already taken" });
      }
      
      // Hash password
      const hashedPassword = await bcrypt.hash(password, 10);
      
      // Create new user
      const userData = insertUserSchema.parse({
        username,
        email,
        password: hashedPassword,
      });
      
      const user = await storage.createUser(userData);
      
      // Generate builder and referral codes
      await storage.generateBuilderCode(user.id);
      
      // Set session
      req.session.userId = user.id;
      
      res.json({ 
        user: {
          id: user.id,
          username: user.username,
          email: user.email,
          builderCode: user.builderCode,
          referralCode: user.referralCode
        }
      });
    } catch (error) {
      res.status(400).json({ error: handleError(error) });
    }
  });

  app.post("/api/auth/signin", async (req, res) => {
    try {
      const { email, password, totp } = req.body;
      
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(401).json({ error: "Invalid credentials" });
      }
      
      // Check password
      const validPassword = await bcrypt.compare(password, user.password);
      if (!validPassword) {
        return res.status(401).json({ error: "Invalid credentials" });
      }

      // Check if 2FA is enabled
      if (user.twoFactorEnabled) {
        if (!totp) {
          return res.status(200).json({ 
            requiresTwoFactor: true,
            userId: user.id 
          });
        }

        // Import auth utilities dynamically
        const { verify2FAToken } = await import("./security/auth");
        const secret = await storage.get2FASecret(user.id);
        
        if (!secret || !verify2FAToken(secret, totp)) {
          // Try backup code
          const isBackupValid = await storage.verify2FABackupCode(user.id, totp);
          if (!isBackupValid) {
            return res.status(401).json({ error: "Invalid 2FA code" });
          }
        }
      }
      
      // Set session
      req.session.userId = user.id;
      
      res.json({ 
        user: {
          id: user.id,
          username: user.username,
          email: user.email,
          builderCode: user.builderCode,
          referralCode: user.referralCode
        }
      });
    } catch (error) {
      res.status(400).json({ error: handleError(error) });
    }
  });

  app.get("/api/auth/user", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.json(null);
      }
      
      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.json(null);
      }
      
      res.json({
        id: user.id,
        username: user.username,
        email: user.email,
        builderCode: user.builderCode,
        referralCode: user.referralCode
      });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.post("/api/auth/logout", async (req, res) => {
    try {
      req.session.destroy((err) => {
        if (err) {
          return res.status(500).json({ error: "Failed to logout" });
        }
        res.json({ success: true });
      });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // 2FA management endpoints
  app.get("/api/auth/2fa/setup", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      const { generate2FASecret, generateQRCode } = await import("./security/auth");
      const secret = generate2FASecret(user.email);
      
      // Generate backup codes
      const backupCodes: string[] = [];
      for (let i = 0; i < 8; i++) {
        backupCodes.push(Math.random().toString(36).substring(2, 10).toUpperCase());
      }

      // Save secret and backup codes temporarily
      await storage.setup2FA(user.id, secret.base32, backupCodes);

      // Generate QR code
      const qrCode = await generateQRCode(secret.otpauth_url!);

      res.json({
        secret: secret.base32,
        qrCode,
        backupCodes
      });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.post("/api/auth/2fa/enable", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      const { totp } = req.body;
      if (!totp) {
        return res.status(400).json({ error: "2FA code required" });
      }

      const secret = await storage.get2FASecret(req.session.userId);
      if (!secret) {
        return res.status(400).json({ error: "2FA not set up" });
      }

      const { verify2FAToken } = await import("./security/auth");
      if (!verify2FAToken(secret, totp)) {
        return res.status(400).json({ error: "Invalid 2FA code" });
      }

      await storage.enable2FA(req.session.userId);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.post("/api/auth/2fa/disable", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      const { password } = req.body;
      if (!password) {
        return res.status(400).json({ error: "Password required" });
      }

      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      // Verify password
      const validPassword = await bcrypt.compare(password, user.password);
      if (!validPassword) {
        return res.status(401).json({ error: "Invalid password" });
      }

      await storage.disable2FA(req.session.userId);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.get("/api/auth/2fa/status", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      const user = await storage.getUser(req.session.userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      res.json({
        enabled: user.twoFactorEnabled || false
      });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // User management
  app.post("/api/users", async (req, res) => {
    try {
      const userData = insertUserSchema.parse(req.body);
      const user = await storage.createUser(userData);
      res.json(user);
    } catch (error) {
      res.status(400).json({ error: handleError(error) });
    }
  });

  app.get("/api/users/:id", async (req, res) => {
    try {
      const { id } = req.params;
      const user = await storage.getUser(parseInt(id));
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      res.json(user);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Trading platforms
  app.get("/api/platforms", async (req, res) => {
    try {
      const { userId } = req.query;
      const platforms = await storage.getTradingPlatforms(userId as string);
      res.json(platforms);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.post("/api/platforms", async (req, res) => {
    try {
      const platformData = insertTradingPlatformSchema.parse(req.body);
      const platform = await storage.createTradingPlatform(platformData);
      
      // Import SecurityService
      const { SecurityService } = await import("./services/security");
      
      // Initialize security monitoring for the platform
      await SecurityService.initializePlatformSecurity(platform.id);
      
      // Import VerificationService and generate verification code
      const { VerificationService } = await import("./services/verification");
      await VerificationService.generateToken(platform.id);
      
      // Scan platform content for suspicious elements
      const isClean = await SecurityService.scanPlatformContent(platform.id, {
        name: platform.name,
        config: platform.config,
        logoUrl: platform.logoUrl
      });
      
      if (!isClean) {
        // Mark platform for review if suspicious content detected
        await SecurityService.updateRiskScore(platform.id, 50);
      }
      
      // Send approval notification to admin
      const user = await storage.getUser(platform.userId);
      if (user) {
        const { sendPlatformApprovalNotification } = await import('./services/notifications');
        await sendPlatformApprovalNotification(platform, user);
      }
      
      res.json(platform);
    } catch (error) {
      res.status(400).json({ error: handleError(error) });
    }
  });

  app.get("/api/platforms/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const platform = await storage.getTradingPlatform(id);
      if (!platform) {
        return res.status(404).json({ error: "Platform not found" });
      }
      res.json(platform);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Get current platform based on domain (for centralized SaaS)
  app.get("/api/platform/current", async (req, res) => {
    try {
      // Platform data is attached by the platformResolver middleware
      if (req.platform) {
        res.json(req.platform);
      } else {
        // No platform for this domain - return null
        res.json(null);
      }
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.put("/api/platforms/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      
      // Check if platform is allowed to be updated
      const { SecurityService } = await import("./services/security");
      const isAllowed = await SecurityService.isPlatformAllowed(id);
      if (!isAllowed) {
        return res.status(403).json({ error: "This platform has been suspended. Please contact support." });
      }
      
      // Scan for suspicious content if platform details are being updated
      if (updates.name || updates.config || updates.logoUrl) {
        const isClean = await SecurityService.scanPlatformContent(id, {
          name: updates.name,
          config: updates.config,
          logoUrl: updates.logoUrl
        });
        
        if (!isClean) {
          await SecurityService.updateRiskScore(id, 30);
        }
      }
      
      const platform = await storage.updateTradingPlatform(id, updates);
      res.json(platform);
    } catch (error) {
      res.status(400).json({ error: handleError(error) });
    }
  });

  app.delete("/api/platforms/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteTradingPlatform(id);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Custom domain management
  app.post("/api/platforms/:id/domains", async (req, res) => {
    try {
      const platformId = parseInt(req.params.id);
      const { domain } = req.body;
      
      // Check authentication
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized - Please login" });
      }
      
      // Verify platform ownership
      const platform = await storage.getTradingPlatform(platformId);
      if (!platform || platform.userId !== req.session.userId) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const { domainManager } = await import('./services/domainManager');
      const result = await domainManager.addCustomDomain(platformId, domain);
      
      if (result.success) {
        res.json({
          success: true,
          verificationToken: result.verificationToken,
          instructions: {
            recordType: 'TXT',
            recordName: '_liquidlab',
            recordValue: result.verificationToken
          }
        });
      } else {
        res.status(400).json({ error: result.error });
      }
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });
  
  app.post("/api/platforms/:id/domains/verify", async (req, res) => {
    try {
      const platformId = parseInt(req.params.id);
      const { domain } = req.body;
      
      // Check authentication
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized - Please login" });
      }
      
      // Verify platform ownership
      const platform = await storage.getTradingPlatform(platformId);
      if (!platform || platform.userId !== req.session.userId) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const { domainManager } = await import('./services/domainManager');
      const result = await domainManager.verifyDomain(platformId, domain);
      
      res.json(result);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });
  
  app.get("/api/platforms/:id/domains", async (req, res) => {
    try {
      const platformId = parseInt(req.params.id);
      
      // Check authentication
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized - Please login" });
      }
      
      // Verify platform ownership
      const platform = await storage.getTradingPlatform(platformId);
      if (!platform || platform.userId !== req.session.userId) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const { domainManager } = await import('./services/domainManager');
      const domains = await domainManager.getPlatformDomains(platformId);
      
      // Transform data to match frontend expectations
      const transformedDomains = domains.map(domain => ({
        ...domain,
        status: domain.isVerified ? 'active' : 'pending'
      }));
      
      res.json(transformedDomains);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });
  
  app.delete("/api/platforms/:id/domains/:domain", async (req, res) => {
    try {
      const platformId = parseInt(req.params.id);
      const { domain } = req.params;
      
      // Check authentication
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized - Please login" });
      }
      
      // Verify platform ownership
      const platform = await storage.getTradingPlatform(platformId);
      if (!platform || platform.userId !== req.session.userId) {
        return res.status(403).json({ error: "Unauthorized" });
      }
      
      const { domainManager } = await import('./services/domainManager');
      const success = await domainManager.removeDomain(platformId, domain);
      
      res.json({ success });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Templates
  app.get("/api/templates", async (req, res) => {
    try {
      const templates = await storage.getTemplates();
      res.json(templates);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.post("/api/templates", async (req, res) => {
    try {
      const templateData = insertTemplateSchema.parse(req.body);
      const template = await storage.createTemplate(templateData);
      res.json(template);
    } catch (error) {
      res.status(400).json({ error: handleError(error) });
    }
  });

  app.get("/api/templates/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const template = await storage.getTemplate(id);
      if (!template) {
        return res.status(404).json({ error: "Template not found" });
      }
      res.json(template);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Revenue tracking
  app.get("/api/revenue/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      const { period = '30d' } = req.query;
      const records = await storage.getRevenueRecords(parseInt(userId), period as string);
      res.json(records);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.post("/api/revenue", async (req, res) => {
    try {
      const revenueData = insertRevenueRecordSchema.parse(req.body);
      const record = await storage.createRevenueRecord(revenueData);
      res.json(record);
    } catch (error) {
      res.status(400).json({ error: handleError(error) });
    }
  });

  // Builder codes
  app.post("/api/builder-codes", async (req, res) => {
    try {
      const { userId } = req.body;
      const code = await storage.generateBuilderCode(userId);
      res.json({ code });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.get("/api/builder-codes/:code/validate", async (req, res) => {
    try {
      const { code } = req.params;
      const isValid = await storage.validateBuilderCode(code);
      res.json({ isValid });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Analytics
  app.get("/api/analytics/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      const analytics = await storage.getDashboardAnalytics(parseInt(userId));
      res.json(analytics);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Referrals
  app.post("/api/referrals", async (req, res) => {
    try {
      const { referrerId, referredUserId } = req.body;
      const referral = await storage.createReferral(referrerId, referredUserId);
      res.json(referral);
    } catch (error) {
      res.status(400).json({ error: handleError(error) });
    }
  });

  app.get("/api/referrals/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      const referrals = await storage.getReferrals(parseInt(userId));
      res.json(referrals);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Hyperliquid API endpoints
  app.get("/api/hyperliquid/market-data", async (req, res) => {
    try {
      const { symbol } = req.query;
      const data = await hyperliquidService.getMarketData(symbol as string);
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Get properly mapped market prices with symbol names using orderbook mid prices and volume data
  app.get("/api/hyperliquid/market-prices", async (req, res) => {
    try {
      // Get market metadata with volume data
      const metaData = await hyperliquidService.getMetaAndAssetCtxs();
      
      if (!metaData || !metaData[0] || !metaData[0].universe) {
        return res.json({});
      }

      // Create a map of symbol to market data from asset contexts
      const marketDataMap: { [key: string]: { 
        price: number; 
        volume24h: string; 
        change24h: string;
        high24h: string;
        low24h: string;
        fundingRate: string;
        openInterest: string;
      } } = {};
      
      if (metaData[1]) {
        metaData[0].universe.forEach((market: any, index: number) => {
          if (metaData[1][index]) {
            // Asset context contains volume and price data
            const assetCtx = metaData[1][index];
            
            const price = parseFloat(assetCtx.markPx || assetCtx.midPx || "0");
            const prevDayPrice = parseFloat(assetCtx.prevDayPx || "0");
            
            // Calculate 24h change percentage
            let change24h = "0";
            if (prevDayPrice > 0) {
              const changePercent = ((price - prevDayPrice) / prevDayPrice) * 100;
              change24h = changePercent.toFixed(2);
            }
            
            // Volume data is in dayNtlVlm (day notional volume)
            const volume = assetCtx.dayNtlVlm || "0";
            
            // Funding rate (8-hour rate converted to annual percentage)
            const funding = assetCtx.funding || "0";
            const fundingRate = (parseFloat(funding) * 365 * 3 * 100).toFixed(2); // Convert to annual %
            
            // Open interest in USD
            const openInterest = assetCtx.openInterest || "0";
            
            // Estimate high/low based on price and volatility (since Hyperliquid doesn't provide these directly)
            // Use a conservative estimate of 2% daily range
            const volatilityFactor = 0.02;
            const high24h = (price * (1 + volatilityFactor)).toFixed(2);
            const low24h = (price * (1 - volatilityFactor)).toFixed(2);
            
            marketDataMap[market.name] = {
              price: price,
              volume24h: volume,
              change24h: change24h,
              high24h: high24h,
              low24h: low24h,
              fundingRate: fundingRate,
              openInterest: openInterest
            };
          }
        });
      }

      // For main markets, get more accurate prices from orderbooks
      const mainMarkets = ['BTC', 'ETH', 'SOL', 'ARB', 'MATIC', 'AVAX', 'BNB', 'DOGE', 'SUI', 'APT'];
      const orderbookPromises = mainMarkets.map(async (symbol) => {
        try {
          const orderbook = await hyperliquidService.getOrderbook(symbol);
          if (orderbook && orderbook.levels) {
            const bestAsk = parseFloat(orderbook.levels[0][0]?.px || '0');
            const bestBid = parseFloat(orderbook.levels[1][0]?.px || '0');
            const midPrice = bestAsk && bestBid ? (bestAsk + bestBid) / 2 : bestAsk || bestBid;
            if (midPrice > 0) {
              // Update with more accurate orderbook price
              marketDataMap[symbol] = {
                ...marketDataMap[symbol],
                price: midPrice,
                fundingRate: marketDataMap[symbol]?.fundingRate || "0",
                openInterest: marketDataMap[symbol]?.openInterest || "0"
              };
            }
          }
        } catch (error) {
          console.error(`Error fetching ${symbol} orderbook:`, error);
        }
      });

      await Promise.all(orderbookPromises);

      res.json(marketDataMap);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.get("/api/hyperliquid/orderbook/:symbol", async (req, res) => {
    try {
      const { symbol } = req.params;
      const data = await hyperliquidService.getOrderbook(symbol);
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.get("/api/hyperliquid/candles/:symbol", async (req, res) => {
    try {
      const { symbol } = req.params;
      const { interval = '15m' } = req.query;
      
      // Get current price directly from Hyperliquid
      const orderbookData = await hyperliquidService.getOrderbook(symbol);
      let currentPrice = 100000; // Default for BTC
      
      if (orderbookData && orderbookData.levels) {
        const bestAsk = parseFloat(orderbookData.levels[0]?.[0]?.px || '0');
        const bestBid = parseFloat(orderbookData.levels[1]?.[0]?.px || '0');
        currentPrice = bestAsk && bestBid ? (bestAsk + bestBid) / 2 : bestAsk || bestBid || currentPrice;
      }
      
      // Generate realistic candle data
      const now = Math.floor(Date.now() / 1000);
      const intervalSeconds = {
        '1m': 60,
        '5m': 300,
        '15m': 900,
        '1h': 3600,
        '4h': 14400,
        '1d': 86400
      }[interval as string] || 900;
      
      const candles = [];
      for (let i = 100; i >= 0; i--) {
        const time = now - (i * intervalSeconds);
        const volatility = 0.0002; // 0.02% volatility per candle
        const trend = Math.sin(i / 20) * 0.001; // Slight trend
        const random = (Math.random() - 0.5) * volatility;
        
        const basePrice = currentPrice * (1 - (i * 0.00001) + trend);
        const open = basePrice * (1 + random);
        const close = basePrice * (1 + (Math.random() - 0.5) * volatility);
        const high = Math.max(open, close) * (1 + Math.random() * volatility);
        const low = Math.min(open, close) * (1 - Math.random() * volatility);
        
        candles.push({
          time: time * 1000, // Convert to milliseconds
          open,
          high,
          low,
          close,
          volume: Math.random() * 1000000
        });
      }
      
      res.json({ candles });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });



  app.get("/api/hyperliquid/user-state/:address", async (req, res) => {
    try {
      const { address } = req.params;
      const data = await hyperliquidService.getUserState(address);
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.post("/api/hyperliquid/place-order", async (req, res) => {
    try {
      // The order request should already be signed on the client side
      const { orderRequest } = req.body;
      const result = await hyperliquidService.placeOrder(orderRequest);
      res.json(result);
    } catch (error) {
      res.status(400).json({ error: handleError(error) });
    }
  });

  app.get("/api/hyperliquid/user-positions/:address", async (req, res) => {
    try {
      const { address } = req.params;
      const data = await hyperliquidService.getUserPositions(address);
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.get("/api/hyperliquid/open-orders/:address", async (req, res) => {
    try {
      const { address } = req.params;
      const data = await hyperliquidService.getUserOpenOrders(address);
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Get user balances including withdrawable amount
  app.get("/api/hyperliquid/balances/:address", async (req, res) => {
    try {
      const { address } = req.params;
      const userState = await hyperliquidService.getUserState(address);
      
      // Extract relevant balance information
      const balances = {
        withdrawable: userState?.withdrawable || "0",
        accountValue: userState?.marginSummary?.accountValue || "0",
        totalMarginUsed: userState?.marginSummary?.totalMarginUsed || "0",
        balances: userState?.balances || {},
        marginSummary: userState?.marginSummary || {}
      };
      
      res.json(balances);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Withdraw from Hyperliquid to Arbitrum
  app.post("/api/hyperliquid/withdraw", async (req, res) => {
    try {
      const { amount, destination } = req.body;
      
      if (!amount || parseFloat(amount) < 2) {
        return res.status(400).json({ error: "Minimum withdrawal is 2 USDC (1 USDC fee)" });
      }
      
      if (!destination) {
        return res.status(400).json({ error: "Destination address required" });
      }
      
      // For now, return a placeholder response since we need the user's private key
      // In production, this would use the agent wallet system or require user signature
      res.json({
        success: true,
        message: "Withdrawal functionality requires wallet signature. Please use Hyperliquid's interface for withdrawals.",
        amount: amount,
        destination: destination
      });
      
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Debug endpoint to find all USDC pairs with proper token mapping
  app.get("/api/hyperliquid/spot-pairs-debug", async (req, res) => {
    try {
      const spotMetaData = await hyperliquidService.getSpotMetaAndAssetCtxs();
      
      if (!spotMetaData || spotMetaData.length < 2) {
        return res.status(500).json({ error: "Failed to fetch spot data" });
      }
      
      const [spotMeta, assetCtxs] = spotMetaData;
      
      // Token name mappings (based on Hyperliquid documentation)
      const tokenMappings: Record<string, string[]> = {
        "BTC": ["BTC", "UBTC", "WBTC"],  // BTC might appear as UBTC on mainnet
        "ETH": ["ETH", "WETH"],
        "SOL": ["SOL", "WSOL"],
        "FARTCOIN": ["FARTCOIN", "FART"],
        "PUMP": ["PUMP"],
        "HYPE": ["HYPE"]
      };
      
      const usdcPairs: any[] = [];
      const foundTokens: Record<string, any> = {};
      
      // Find all USDC pairs and check for our target tokens
      spotMeta.universe.forEach((pair: any, pairIndex: number) => {
        const baseTokenIndex = pair.tokens[0];
        const quoteTokenIndex = pair.tokens[1];
        
        const baseToken = spotMeta.tokens.find((t: any) => t.index === baseTokenIndex);
        const quoteToken = spotMeta.tokens.find((t: any) => t.index === quoteTokenIndex);
        
        if (quoteToken?.name === "USDC" && baseToken) {
          const assetCtx = assetCtxs[pairIndex];
          const pairInfo = {
            pairName: pair.name,
            baseToken: baseToken.name,
            baseIndex: baseTokenIndex,
            pairIndex: pairIndex,
            price: assetCtx?.midPx || assetCtx?.markPx || "0",
            volume: assetCtx?.dayNtlVlm || "0"
          };
          
          usdcPairs.push(pairInfo);
          
          // Check if this matches any of our target tokens
          for (const [targetName, possibleNames] of Object.entries(tokenMappings)) {
            if (possibleNames.includes(baseToken.name)) {
              foundTokens[targetName] = {
                actualName: baseToken.name,
                ...pairInfo
              };
              break;
            }
          }
        }
      });
      
      res.json({
        allUsdcPairs: usdcPairs,
        foundTargetTokens: foundTokens,
        totalUsdcPairs: usdcPairs.length
      });
    } catch (error) {
      console.error("Error in spot pairs debug:", error);
      res.status(500).json({ error: "Failed to debug spot pairs" });
    }
  });

  // Spot trading endpoints
  app.get("/api/hyperliquid/spot-prices", async (req, res) => {
    try {
      // Fetch spot metadata and prices
      const spotMetaData = await hyperliquidService.getSpotMetaAndAssetCtxs();
      
      if (!spotMetaData || spotMetaData.length < 2) {
        return res.status(500).json({ error: "Failed to fetch spot data" });
      }
      
      const [spotMeta, assetCtxs] = spotMetaData;
      const spotPrices: Record<string, any> = {};
      
      // Map token names to their indices
      const tokenIndexMap: Record<string, number> = {};
      spotMeta.tokens.forEach((token: any) => {
        tokenIndexMap[token.name] = token.index;
      });
      
      // Define token mappings - Universal tokens on Hyperliquid spot
      const tokenMappings: Record<string, string> = {
        "UBTC": "BTC",  // Universal BTC shows as BTC in UI
        "UETH": "ETH",  // Universal ETH shows as ETH in UI
        "USOL": "SOL",  // Universal SOL shows as SOL in UI
        "PUMP": "PUMP",
        "HYPE": "HYPE"
      };
      
      // Find spot pairs for our supported tokens
      spotMeta.universe.forEach((pair: any, pairIndex: number) => {
        const baseTokenIndex = pair.tokens[0];
        const quoteTokenIndex = pair.tokens[1];
        
        // Find the base token
        const baseToken = spotMeta.tokens.find((t: any) => t.index === baseTokenIndex);
        const quoteToken = spotMeta.tokens.find((t: any) => t.index === quoteTokenIndex);
        
        // Include tokens that are in our mapping and paired with USDC
        if (baseToken && quoteToken && quoteToken.name === "USDC" && tokenMappings.hasOwnProperty(baseToken.name)) {
          const assetCtx = assetCtxs[pairIndex];
          if (assetCtx) {
            const rawPrice = parseFloat(assetCtx.midPx || assetCtx.markPx || "0");
            const prevPrice = parseFloat(assetCtx.prevDayPx || "0");
            
            // Apply decimal adjustment based on szDecimals
            const decimals = baseToken.szDecimals || 0;
            const price = rawPrice * Math.pow(10, decimals);
            const adjustedPrevPrice = prevPrice * Math.pow(10, decimals);
            
            const change24h = adjustedPrevPrice > 0 ? ((price - adjustedPrevPrice) / adjustedPrevPrice * 100) : 0;
            
            // Use the mapped display name (e.g., UBTC -> BTC)
            const displaySymbol = tokenMappings[baseToken.name];
            
            spotPrices[displaySymbol] = {
              symbol: displaySymbol,
              actualSymbol: baseToken.name,  // Keep the actual symbol for trading
              price: price,
              change24h: change24h,
              volume24h: parseFloat(assetCtx.dayNtlVlm || "0"),
              pairIndex: pairIndex,
              baseTokenIndex: baseTokenIndex,
              quoteTokenIndex: quoteTokenIndex,
              pairName: pair.name  // Include the pair name (e.g., @142)
            };
          }
        }
      });
      

      
      res.json(spotPrices);
    } catch (error) {
      console.error("Error fetching spot prices:", error);
      res.status(500).json({ error: "Failed to fetch spot prices" });
    }
  });

  app.post("/api/hyperliquid/spot-order", async (req, res) => {
    try {
      // Check authentication
      if (!req.session.userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      
      const { symbol, side, amount, walletAddress } = req.body;
      
      if (!symbol || !side || !amount || !walletAddress) {
        return res.status(400).json({ error: "Missing required fields" });
      }
      
      // For spot trading, we need to:
      // 1. Get the spot pair info
      // 2. Sign the order with the user's wallet (done on frontend)
      // 3. Submit to Hyperliquid
      
      // This is a simplified response for now
      // In production, this would handle the actual spot order placement
      res.json({
        success: true,
        message: `Spot ${side} order for ${amount} ${symbol} requires wallet signature`,
        orderId: `spot_${Date.now()}`,
        note: "Please use the trading interface to sign and submit spot orders"
      });
    } catch (error) {
      console.error("Error placing spot order:", error);
      res.status(500).json({ error: "Failed to place spot order" });
    }
  });

  // Get validated contract addresses for secure deposits
  app.get("/api/deposit/config", async (req, res) => {
    try {
      const config = ConfigurationService.getContractAddresses();
      const rateLimits = ConfigurationService.getDepositRateLimits();
      
      res.json({
        addresses: {
          hyperliquidBridge: config.hyperliquidBridge,
          arbitrumUSDC: config.arbitrumUSDC,
        },
        minimumAmount: config.minimumDepositAmount,
        rateLimits: {
          maxPerHour: rateLimits.maxDepositsPerHour,
          maxPerDay: rateLimits.maxDepositsPerDay,
          maxAmount: rateLimits.maxAmountPerDeposit,
        },
        environment: config.environment,
      });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Record a new deposit transaction
  app.post("/api/deposit/record", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const { amount, walletAddress, bridgeAddress, tokenAddress, txHash } = req.body;
      
      // Validate request body
      if (!amount || !walletAddress || !bridgeAddress || !tokenAddress) {
        return res.status(400).json({ error: "Missing required fields" });
      }

      // Record deposit with security checks
      const result = await DepositService.recordDeposit({
        userId: req.session.userId,
        walletAddress,
        amount,
        bridgeAddress,
        tokenAddress,
        txHash,
        ipAddress: req.ip,
        userAgent: req.get('user-agent'),
      });

      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }

      res.json({
        success: true,
        depositId: result.depositId,
        message: "Deposit recorded successfully",
      });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Get user's recent deposits
  app.get("/api/deposit/history", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const limit = parseInt(req.query.limit as string) || 10;
      const deposits = await DepositService.getUserDeposits(req.session.userId, limit);
      
      res.json({
        deposits,
        count: deposits.length,
      });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Get deposit rate limit status
  app.get("/api/deposit/rate-status", async (req, res) => {
    try {
      if (!req.session.userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const rateCheck = await DepositService.checkDepositRateLimits(req.session.userId, "0");
      const limits = ConfigurationService.getDepositRateLimits();
      
      res.json({
        allowed: rateCheck.allowed,
        hourlyCount: rateCheck.hourlyCount,
        dailyCount: rateCheck.dailyCount,
        dailyVolume: rateCheck.dailyVolume,
        limits: {
          maxPerHour: limits.maxDepositsPerHour,
          maxPerDay: limits.maxDepositsPerDay,
          maxDailyVolume: limits.maxDailyVolume,
        },
      });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.get("/api/hyperliquid/meta", async (req, res) => {
    try {
      console.log("Fetching meta and asset contexts...");
      const data = await hyperliquidService.getMetaAndAssetCtxs();
      console.log("Meta data received, length:", data?.length);
      res.json(data);
    } catch (error) {
      console.error("Error in /api/hyperliquid/meta:", error);
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.get("/api/hyperliquid/candles/:symbol/:interval", async (req, res) => {
    try {
      const { symbol, interval } = req.params;
      const { startTime, endTime } = req.query;
      
      const data = await hyperliquidService.getCandleData(
        symbol, 
        interval,
        startTime ? parseInt(startTime as string) : undefined,
        endTime ? parseInt(endTime as string) : undefined
      );
      
      res.json(data);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // TradingView UDF endpoints for Hyperliquid data
  // These endpoints allow TradingView Charting Library to use Hyperliquid as a data source
  
  // UDF config endpoint
  app.get("/api/udf/config", (req, res) => {
    res.json({
      supported_resolutions: ['1', '5', '15', '30', '60', '240', '1D', '1W'],
      supports_group_request: false,
      supports_marks: false,
      supports_search: true,
      supports_timescale_marks: false,
      supports_time: true,
      exchanges: [
        {
          value: 'HYPERLIQUID',
          name: 'Hyperliquid',
          desc: 'Hyperliquid DEX'
        }
      ],
      symbols_types: [
        {
          name: 'crypto',
          value: 'crypto'
        }
      ]
    });
  });

  // UDF symbol info endpoint
  app.get("/api/udf/symbols", async (req, res) => {
    try {
      const symbol = req.query.symbol as string;
      
      // Get asset info from Hyperliquid
      const meta = await hyperliquidService.getMeta();
      const assetInfo = meta.universe.find((asset: any) => 
        asset.name === symbol || `${asset.name}-USD` === symbol
      );

      if (!assetInfo) {
        res.status(404).json({ s: 'error', errmsg: 'Symbol not found' });
        return;
      }

      res.json({
        name: symbol,
        'exchange-traded': 'HYPERLIQUID',
        'exchange-listed': 'HYPERLIQUID',
        timezone: 'Etc/UTC',
        minmov: 1,
        minmov2: 0,
        pointvalue: 1,
        session: '24x7',
        has_intraday: true,
        has_no_volume: false,
        description: `${assetInfo.name} Perpetual`,
        type: 'crypto',
        supported_resolutions: ['1', '5', '15', '30', '60', '240', '1D', '1W'],
        pricescale: Math.pow(10, assetInfo.szDecimals),
        ticker: symbol
      });
    } catch (error) {
      console.error('Error fetching symbol info:', error);
      res.status(500).json({ s: 'error', errmsg: 'Failed to fetch symbol info' });
    }
  });

  // UDF history endpoint
  app.get("/api/udf/history", async (req, res) => {
    try {
      const symbol = (req.query.symbol as string).replace('-USD', '');
      const from = parseInt(req.query.from as string) * 1000; // Convert to milliseconds
      const to = parseInt(req.query.to as string) * 1000;
      const resolution = req.query.resolution as string;
      
      // Map TradingView resolutions to Hyperliquid intervals
      const intervalMap: { [key: string]: string } = {
        '1': '1m',
        '5': '5m',
        '15': '15m',
        '30': '30m',
        '60': '1h',
        '240': '4h',
        '1D': '1d',
        '1W': '1w'
      };
      
      const interval = intervalMap[resolution] || '1h';
      
      const candles = await hyperliquidService.getCandleData(
        symbol,
        interval,
        from,
        to
      );

      if (!candles || candles.length === 0) {
        res.json({ s: 'no_data' });
        return;
      }

      // Convert to TradingView format
      const t: number[] = [];
      const o: number[] = [];
      const h: number[] = [];
      const l: number[] = [];
      const c: number[] = [];
      const v: number[] = [];

      candles.forEach((candle: any) => {
        t.push(Math.floor(candle.timestamp / 1000)); // Convert to seconds
        o.push(parseFloat(candle.open));
        h.push(parseFloat(candle.high));
        l.push(parseFloat(candle.low));
        c.push(parseFloat(candle.close));
        v.push(parseFloat(candle.volume || 0));
      });

      res.json({
        s: 'ok',
        t,
        o,
        h,
        l,
        c,
        v
      });
    } catch (error) {
      console.error('Error fetching history:', error);
      res.json({ s: 'error', errmsg: error instanceof Error ? error.message : 'Failed to fetch history' });
    }
  });

  // UDF search endpoint
  app.get("/api/udf/search", async (req, res) => {
    try {
      const query = (req.query.query as string || '').toUpperCase();
      const type = req.query.type as string;
      const exchange = req.query.exchange as string;
      const limit = parseInt(req.query.limit as string) || 30;

      const meta = await hyperliquidService.getMeta();
      const results = meta.universe
        .filter((asset: any) => {
          const symbol = asset.name;
          return symbol.includes(query);
        })
        .slice(0, limit)
        .map((asset: any) => ({
          symbol: `${asset.name}-USD`,
          full_name: `HYPERLIQUID:${asset.name}USD`,
          description: `${asset.name} Perpetual`,
          exchange: 'HYPERLIQUID',
          ticker: `${asset.name}-USD`,
          type: 'crypto'
        }));

      res.json(results);
    } catch (error) {
      console.error('Error in symbol search:', error);
      res.json([]);
    }
  });

  // UDF time endpoint
  app.get("/api/udf/time", (req, res) => {
    res.json(Math.floor(Date.now() / 1000));
  });

  // Platform verification endpoints
  app.get("/api/platforms/verify/:platformId", async (req, res) => {
    try {
      const { platformId } = req.params;
      const platform = await storage.getTradingPlatform(parseInt(platformId));
      
      if (!platform) {
        return res.status(404).json({ error: "Platform not found" });
      }
      
      res.json({
        id: platform.id,
        name: platform.name,
        isVerified: platform.isVerified || false,
        verificationDate: platform.verificationDate,
        customDomain: platform.customDomain,
        builderCode: 'LIQUIDLAB2025'
      });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Import rate limiter for verification endpoint
  const { authLimiter } = await import("./security/customRateLimiter");

  // Verify platform by code (new rotating token system)
  // Apply rate limiting middleware BEFORE any expensive operations
  app.post("/api/platforms/verify", authLimiter, async (req, res) => {
    try {
      const { code } = req.body;
      if (!code) {
        return res.status(400).json({ error: "Verification code required" });
      }

      // Get client IP
      const ipAddress = req.ip || req.connection.remoteAddress || 'unknown';
      const userAgent = req.headers['user-agent'];

      // Import VerificationService
      const { VerificationService } = await import("./services/verification");

      // Check rate limit (secondary check for IP-based limiting)
      const withinLimit = await VerificationService.checkRateLimit(ipAddress);
      if (!withinLimit) {
        return res.status(429).json({ error: "Too many attempts. Please try again later." });
      }

      // Verify the platform
      const result = await VerificationService.verifyPlatform(code, ipAddress, userAgent);
      
      if (result.success) {
        res.json({
          success: true,
          platform: result.platform,
          securityHash: result.securityHash,
        });
      } else {
        res.status(400).json({ 
          success: false, 
          error: result.error 
        });
      }
    } catch (error) {
      console.error("Error verifying platform:", error);
      res.status(500).json({ error: "System error during verification" });
    }
  });

  // Get verification code for a platform (public endpoint)
  app.get("/api/platforms/:id/verification-code", async (req, res) => {
    try {
      const platformId = parseInt(req.params.id);
      const { VerificationService } = await import("./services/verification");
      
      const code = await VerificationService.getActiveCode(platformId);
      
      res.json({ code });
    } catch (error) {
      console.error("Error getting verification code:", error);
      res.json({ code: null });
    }
  });

  // Generate new verification token for a platform
  app.post("/api/admin/platforms/:platformId/generate-token", requireAdmin, async (req, res) => {
    try {
      const { platformId } = req.params;
      const { VerificationService } = await import("./services/verification");
      
      const { code, hash } = await VerificationService.generateToken(parseInt(platformId));
      
      res.json({ 
        success: true, 
        verificationCode: code,
        securityHash: hash,
        expiresIn: "24 hours"
      });
    } catch (error) {
      console.error("Error generating verification token:", error);
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.post("/api/admin/platforms/:platformId/verify", requireAdmin, async (req, res) => {
    try {
      const { platformId } = req.params;
      const { notes } = req.body;
      
      const updatedPlatform = await storage.updateTradingPlatform(parseInt(platformId), {
        isVerified: true,
        verificationDate: new Date(),
        verificationNotes: notes
      });
      
      res.json({ success: true, platform: updatedPlatform });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // MoonPay configuration endpoint
  app.get("/api/moonpay/config", async (req, res) => {
    try {
      // In production, this would come from environment variables
      // For now, return a placeholder that indicates MoonPay integration is ready
      res.json({
        apiKey: process.env.MOONPAY_API_KEY || 'pk_test_liquidlab2025',
        environment: process.env.MOONPAY_ENV || 'test'
      });
    } catch (error) {
      console.error('Error fetching MoonPay config:', error);
      res.status(500).json({ message: 'Failed to fetch MoonPay configuration' });
    }
  });

  // MoonPay revenue endpoints
  app.get("/api/moonpay/revenue/:platformId", async (req, res) => {
    try {
      const platformId = parseInt(req.params.platformId);
      const moonpayStats = await storage.getMoonpayRevenueSummary(platformId);
      res.json(moonpayStats);
    } catch (error) {
      console.error('Error fetching MoonPay revenue:', error);
      res.status(500).json({ message: 'Failed to fetch MoonPay revenue' });
    }
  });

  app.get("/api/moonpay/revenue", async (req, res) => {
    try {
      const moonpayStats = await storage.getMoonpayRevenueSummary();
      res.json(moonpayStats);
    } catch (error) {
      console.error('Error fetching total MoonPay revenue:', error);
      res.status(500).json({ message: 'Failed to fetch MoonPay revenue' });
    }
  });

  app.post("/api/moonpay/record", async (req, res) => {
    try {
      const { platformId, transactionId, purchaseAmount } = req.body;
      
      const affiliateFee = (parseFloat(purchaseAmount) * 0.01).toFixed(4); // 1% affiliate fee
      const platformEarnings = (parseFloat(affiliateFee) * 0.5).toFixed(4); // 50% split
      const liquidlabEarnings = (parseFloat(affiliateFee) * 0.5).toFixed(4); // 50% split
      
      const transaction = await storage.recordMoonpayTransaction({
        platformId,
        transactionId,
        purchaseAmount,
        affiliateFee,
        platformEarnings,
        liquidlabEarnings,
        currency: 'USD',
        status: 'completed',
        completedAt: new Date()
      });
      
      res.json(transaction);
    } catch (error) {
      console.error('Error recording MoonPay transaction:', error);
      res.status(500).json({ message: 'Failed to record MoonPay transaction' });
    }
  });

  // AI Market Chat endpoint
  app.post('/api/ai/market-chat', async (req, res) => {
    try {
      const { message, context } = req.body;
      
      if (!process.env.PERPLEXITY_API_KEY) {
        return res.status(503).json({ 
          response: "AI assistant is currently unavailable. Please ask the administrator to configure the Perplexity API key." 
        });
      }

      const systemPrompt = `You are a cryptocurrency trading assistant for LiquidLab platform. Provide concise, accurate market analysis and trading insights. Current context: Trading ${context.market} at $${context.currentPrice}. Keep responses brief and focused on actionable information.`;

      const response = await fetch('https://api.perplexity.ai/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.PERPLEXITY_API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'llama-3.1-sonar-small-128k-online',
          messages: [
            {
              role: 'system',
              content: systemPrompt
            },
            {
              role: 'user',
              content: message
            }
          ],
          temperature: 0.2,
          top_p: 0.9,
          return_images: false,
          return_related_questions: false,
          search_recency_filter: 'month',
          stream: false
        })
      });

      if (!response.ok) {
        throw new Error(`Perplexity API error: ${response.status}`);
      }

      const data = await response.json();
      const aiResponse = data.choices[0]?.message?.content || "Sorry, I couldn't generate a response.";

      res.json({ response: aiResponse });
    } catch (error) {
      console.error('AI chat error:', error);
      res.status(500).json({ 
        response: "I'm having trouble connecting to the AI service right now. Please try again later." 
      });
    }
  });

  // Crypto payout endpoints
  app.get("/api/payouts/platform/:platformId", async (req, res) => {
    try {
      const platformId = parseInt(req.params.platformId);
      const { status, startDate, endDate } = req.query;
      
      // Verify user owns this platform
      if (req.session.userId) {
        const platform = await storage.getTradingPlatform(platformId);
        if (!platform || platform.userId !== req.session.userId) {
          return res.status(403).json({ error: "Unauthorized" });
        }
      }
      
      const options: any = {};
      if (status) options.status = status as string;
      if (startDate) options.startDate = new Date(startDate as string);
      if (endDate) options.endDate = new Date(endDate as string);
      
      const payouts = await storage.getPayouts(platformId, options);
      res.json(payouts);
    } catch (error) {
      console.error('Error fetching payouts:', error);
      res.status(500).json({ error: 'Failed to fetch payouts' });
    }
  });

  app.get("/api/payouts/pending/:platformId", async (req, res) => {
    try {
      const platformId = parseInt(req.params.platformId);
      
      // Verify user owns this platform
      if (req.session.userId) {
        const platform = await storage.getTradingPlatform(platformId);
        if (!platform || platform.userId !== req.session.userId) {
          return res.status(403).json({ error: "Unauthorized" });
        }
      }
      
      const pendingPayouts = await storage.getPendingPayouts(platformId);
      res.json(pendingPayouts);
    } catch (error) {
      console.error('Error fetching pending payouts:', error);
      res.status(500).json({ error: 'Failed to fetch pending payouts' });
    }
  });

  // Admin-only: Get wallet balance
  app.get("/api/admin/wallet-balance", requireAdmin, async (req, res) => {
    try {
      if (!process.env.PAYOUT_WALLET_PRIVATE_KEY) {
        return res.json({ 
          balance: '0.00',
          error: 'Payout wallet not configured' 
        });
      }
      
      const { cryptoPayout } = await import('./services/cryptoPayout');
      const balance = await cryptoPayout.getWalletBalance();
      
      res.json({ balance });
    } catch (error) {
      console.error('Error fetching wallet balance:', error);
      res.json({ 
        balance: '0.00',
        error: 'Failed to fetch balance' 
      });
    }
  });

  // Admin-only: Process payouts
  app.post("/api/payouts/process", requireAdmin, async (req, res) => {
    try {
      const { period = 'weekly' } = req.body;
      
      if (!process.env.PAYOUT_WALLET_PRIVATE_KEY) {
        return res.status(500).json({ error: 'Payout wallet not configured' });
      }
      
      // Run async without waiting
      const { cryptoPayout } = await import('./services/cryptoPayout');
      cryptoPayout.processPayouts(period as 'weekly' | 'monthly').catch(error => {
        console.error('Payout processing error:', error);
      });
      
      res.json({ 
        success: true, 
        message: 'Payout processing started in background' 
      });
    } catch (error) {
      console.error('Error starting payout processing:', error);
      res.status(500).json({ error: 'Failed to start payout processing' });
    }
  });

  // Admin-only: Check payout readiness
  app.get("/api/admin/payout-readiness", requireAdmin, async (req, res) => {
    try {
      const { period = 'weekly' } = req.query;
      const { builderFeeManager } = await import('./services/builderFeeManager');
      const readiness = await builderFeeManager.checkPayoutReadiness(period as 'weekly' | 'monthly');
      
      res.json(readiness);
    } catch (error) {
      console.error('Error checking payout readiness:', error);
      res.status(500).json({ error: 'Failed to check payout readiness' });
    }
  });

  // Admin-only: Get unclaimed fees
  app.get("/api/admin/unclaimed-fees", requireAdmin, async (req, res) => {
    try {
      const { builderFeeManager } = await import('./services/builderFeeManager');
      const unclaimed = await builderFeeManager.getUnclaimedFees();
      
      res.json({
        total: unclaimed.total,
        byPlatform: Array.from(unclaimed.byPlatform.entries()).map(([platformId, amount]) => ({
          platformId,
          amount
        }))
      });
    } catch (error) {
      console.error('Error fetching unclaimed fees:', error);
      res.status(500).json({ error: 'Failed to fetch unclaimed fees' });
    }
  });

  // Admin-only: Mark fees as claimed
  app.post("/api/admin/claim-fees", requireAdmin, async (req, res) => {
    try {
      const { startDate, endDate, claimTxHash } = req.body;
      
      if (!startDate || !endDate || !claimTxHash) {
        return res.status(400).json({ error: 'Missing required fields' });
      }
      
      const { builderFeeManager } = await import('./services/builderFeeManager');
      const result = await builderFeeManager.markFeesAsClaimed(
        new Date(startDate),
        new Date(endDate),
        claimTxHash
      );
      
      res.json(result);
    } catch (error) {
      console.error('Error marking fees as claimed:', error);
      res.status(500).json({ error: 'Failed to mark fees as claimed' });
    }
  });

  // Admin-only: Transfer USDC to payout wallet
  app.post("/api/admin/transfer-to-payout", requireAdmin, async (req, res) => {
    try {
      const { amount } = req.body;
      
      if (!amount || parseFloat(amount) <= 0) {
        return res.status(400).json({ error: 'Invalid amount' });
      }
      
      const { builderFeeManager } = await import('./services/builderFeeManager');
      const result = await builderFeeManager.transferToPayoutWallet(amount);
      
      res.json(result);
    } catch (error) {
      console.error('Error transferring to payout wallet:', error);
      res.status(500).json({ error: 'Failed to transfer funds' });
    }
  });

  // Admin-only: Get wallet balances
  app.get("/api/admin/wallet-balances", requireAdmin, async (req, res) => {
    try {
      const { builderFeeManager } = await import('./services/builderFeeManager');
      const { cryptoPayout } = await import('./services/cryptoPayout');
      
      const [payoutBalance, hyperliquidBalance] = await Promise.all([
        builderFeeManager.getAvailableUSDC(),
        builderFeeManager.getHyperliquidBalance()
      ]);
      
      res.json({
        payoutWallet: {
          usdc: payoutBalance,
          address: process.env.PAYOUT_WALLET_ADDRESS || 'Not configured'
        },
        builderWallet: {
          hyperliquid: hyperliquidBalance,
          address: process.env.VITE_BUILDER_WALLET_ADDRESS || 'Not configured'
        }
      });
    } catch (error) {
      console.error('Error fetching wallet balances:', error);
      res.status(500).json({ error: 'Failed to fetch balances' });
    }
  });

  // Admin-only: Get pending platforms
  app.get("/api/admin/platforms/pending", requireAdmin, async (req, res) => {
    try {
      const pendingPlatforms = await storage.getPendingPlatforms();
      
      // Get user details for each platform
      const platformsWithUsers = await Promise.all(
        pendingPlatforms.map(async (platform) => {
          const user = await storage.getUser(platform.userId);
          return {
            ...platform,
            user: user ? {
              id: user.id,
              username: user.username,
              email: user.email,
            } : null,
          };
        })
      );
      
      res.json(platformsWithUsers);
    } catch (error) {
      console.error('Error fetching pending platforms:', error);
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Admin-only: Approve platform
  app.post("/api/admin/platforms/:platformId/approve", requireAdmin, async (req, res) => {
    try {
      const { platformId } = req.params;
      const { approvalNotes } = req.body;
      
      const platform = await storage.approvePlatform(parseInt(platformId), approvalNotes);
      const user = await storage.getUser(platform.userId);
      
      // Send approval notification
      if (user) {
        const { sendPlatformApprovedNotification } = await import('./services/notifications');
        await sendPlatformApprovedNotification(platform, user);
      }
      
      res.json({ success: true, platform });
    } catch (error) {
      console.error('Error approving platform:', error);
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Admin-only: Reject platform
  app.post("/api/admin/platforms/:platformId/reject", requireAdmin, async (req, res) => {
    try {
      const { platformId } = req.params;
      const { rejectionReason } = req.body;
      
      if (!rejectionReason) {
        return res.status(400).json({ error: 'Rejection reason is required' });
      }
      
      const platform = await storage.rejectPlatform(parseInt(platformId), rejectionReason);
      const user = await storage.getUser(platform.userId);
      
      // Send rejection notification
      if (user) {
        const { sendPlatformRejectedNotification } = await import('./services/notifications');
        await sendPlatformRejectedNotification(platform, user);
      }
      
      res.json({ success: true, platform });
    } catch (error) {
      console.error('Error rejecting platform:', error);
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Fee tracking endpoints
  app.post("/api/fees/record", async (req, res) => {
    try {
      const { platformId, tradeType, tradeVolume, tradeDetails } = req.body;
      
      // Calculate fees based on trade type
      const feePercentage = tradeType === 'spot' ? 0.002 : 0.001; // 0.2% for spot, 0.1% for perp
      const totalFee = parseFloat(tradeVolume) * feePercentage;
      const platformShare = totalFee * 0.7; // 70% to platform owner
      const liquidlabShare = totalFee * 0.3; // 30% to LiquidLab
      
      const feeTransaction = await storage.recordFeeTransaction({
        platformId,
        tradeType,
        tradeVolume: tradeVolume.toString(),
        totalFee: totalFee.toFixed(8),
        platformShare: platformShare.toFixed(8),
        liquidlabShare: liquidlabShare.toFixed(8),
        tradeDetails: tradeDetails || {},
        status: 'pending',
      });
      
      res.json(feeTransaction);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });
  
  app.get("/api/fees/platform/:platformId", async (req, res) => {
    try {
      const { platformId } = req.params;
      const { status, startDate, endDate } = req.query;
      
      const options: any = {};
      if (status) options.status = status as string;
      if (startDate) options.startDate = new Date(startDate as string);
      if (endDate) options.endDate = new Date(endDate as string);
      
      const transactions = await storage.getFeeTransactions(parseInt(platformId), options);
      res.json(transactions);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });
  
  app.get("/api/fees/summary/:platformId/:period", async (req, res) => {
    try {
      const { platformId, period } = req.params;
      const summary = await storage.getRevenueSummary(parseInt(platformId), period);
      res.json(summary || { message: "No summary found for this period" });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });
  
  app.get("/api/fees/all-platforms", async (req, res) => {
    try {
      const { period, minRevenue } = req.query;
      const options: any = {};
      if (period) options.period = period as string;
      if (minRevenue) options.minRevenue = parseFloat(minRevenue as string);
      
      const revenues = await storage.getAllPlatformRevenues(options);
      res.json(revenues);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Trader analytics endpoints
  app.get("/api/platforms/:platformId/traders", async (req, res) => {
    try {
      const { platformId } = req.params;
      const { minVolume, sortBy } = req.query;
      
      // Verify platform ownership
      const platform = await storage.getTradingPlatform(parseInt(platformId));
      if (!platform) {
        return res.status(404).json({ error: "Platform not found" });
      }
      
      if (!req.session.userId || platform.userId !== req.session.userId) {
        return res.status(403).json({ error: "Unauthorized access to platform data" });
      }
      
      const options: any = {};
      if (minVolume) options.minVolume = parseFloat(minVolume as string);
      if (sortBy) options.sortBy = sortBy as 'volume' | 'fees' | 'trades';
      
      const traders = await storage.getTradersByPlatform(parseInt(platformId), options);
      res.json(traders);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.get("/api/platforms/:platformId/traders/top", async (req, res) => {
    try {
      const { platformId } = req.params;
      const { limit } = req.query;
      
      // Verify platform ownership
      const platform = await storage.getTradingPlatform(parseInt(platformId));
      if (!platform) {
        return res.status(404).json({ error: "Platform not found" });
      }
      
      if (!req.session.userId || platform.userId !== req.session.userId) {
        return res.status(403).json({ error: "Unauthorized access to platform data" });
      }
      
      const topTraders = await storage.getTopTraders(
        parseInt(platformId),
        limit ? parseInt(limit as string) : 10
      );
      res.json(topTraders);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.get("/api/platforms/:platformId/traders/:walletAddress", async (req, res) => {
    try {
      const { platformId, walletAddress } = req.params;
      
      // Verify platform ownership
      const platform = await storage.getTradingPlatform(parseInt(platformId));
      if (!platform) {
        return res.status(404).json({ error: "Platform not found" });
      }
      
      if (!req.session.userId || platform.userId !== req.session.userId) {
        return res.status(403).json({ error: "Unauthorized access to platform data" });
      }
      
      const trader = await storage.getTraderActivity(parseInt(platformId), walletAddress);
      if (!trader) {
        return res.status(404).json({ error: "Trader not found" });
      }
      
      // Get trader's current tier if incentive tiers are configured
      const tier = await storage.getTraderTier(parseInt(platformId), walletAddress);
      
      res.json({
        ...trader,
        currentTier: tier || null
      });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Incentive tier management endpoints
  app.get("/api/platforms/:platformId/incentive-tiers", async (req, res) => {
    try {
      const { platformId } = req.params;
      
      // Verify platform ownership
      const platform = await storage.getTradingPlatform(parseInt(platformId));
      if (!platform) {
        return res.status(404).json({ error: "Platform not found" });
      }
      
      if (!req.session.userId || platform.userId !== req.session.userId) {
        return res.status(403).json({ error: "Unauthorized access to platform data" });
      }
      
      const tiers = await storage.getIncentiveTiers(parseInt(platformId));
      res.json(tiers);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.post("/api/platforms/:platformId/incentive-tiers", async (req, res) => {
    try {
      const { platformId } = req.params;
      const { name, minVolume, rewardType, rewardValue, description } = req.body;
      
      // Verify platform ownership
      const platform = await storage.getTradingPlatform(parseInt(platformId));
      if (!platform) {
        return res.status(404).json({ error: "Platform not found" });
      }
      
      if (!req.session.userId || platform.userId !== req.session.userId) {
        return res.status(403).json({ error: "Unauthorized access to platform data" });
      }
      
      const tier = await storage.createIncentiveTier({
        platformId: parseInt(platformId),
        name,
        minVolume,
        rewardType,
        rewardValue,
        description,
        isActive: true
      });
      
      res.json(tier);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.put("/api/platforms/:platformId/incentive-tiers/:tierId", async (req, res) => {
    try {
      const { platformId, tierId } = req.params;
      const updates = req.body;
      
      // Verify platform ownership
      const platform = await storage.getTradingPlatform(parseInt(platformId));
      if (!platform) {
        return res.status(404).json({ error: "Platform not found" });
      }
      
      if (!req.session.userId || platform.userId !== req.session.userId) {
        return res.status(403).json({ error: "Unauthorized access to platform data" });
      }
      
      const tier = await storage.updateIncentiveTier(parseInt(tierId), updates);
      res.json(tier);
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  app.delete("/api/platforms/:platformId/incentive-tiers/:tierId", async (req, res) => {
    try {
      const { platformId, tierId } = req.params;
      
      // Verify platform ownership
      const platform = await storage.getTradingPlatform(parseInt(platformId));
      if (!platform) {
        return res.status(404).json({ error: "Platform not found" });
      }
      
      if (!req.session.userId || platform.userId !== req.session.userId) {
        return res.status(403).json({ error: "Unauthorized access to platform data" });
      }
      
      await storage.deleteIncentiveTier(parseInt(tierId));
      res.json({ message: "Incentive tier deleted successfully" });
    } catch (error) {
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Import rate limiter for file upload
  const { createRateLimiter } = await import("./security/customRateLimiter");
  
  // Create specific rate limiter for file uploads (more restrictive)
  const uploadLimiter = createRateLimiter({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 10, // max 10 uploads per windowMs
    message: 'Too many file uploads. Please try again later.',
    standardHeaders: true,
  });

  // Logo upload endpoint with enhanced error handling and rate limiting
  app.post("/api/upload-logo", uploadLimiter, (req, res) => {
    upload.single('logo')(req, res, async (err) => {
      try {
        console.log("Upload request received");
        
        // Handle multer errors
        if (err) {
          console.error("Multer error:", err);
          if (err instanceof multer.MulterError) {
            if (err.code === 'LIMIT_FILE_SIZE') {
              return res.status(400).json({ error: 'File too large. Max size is 5MB.' });
            }
            return res.status(400).json({ error: `Upload error: ${err.message}` });
          } else if (err) {
            return res.status(400).json({ error: err.message || 'File upload failed' });
          }
        }
        
        console.log("File:", req.file);
        
        if (!req.file) {
          console.error("No file in request");
          return res.status(400).json({ error: "No file uploaded" });
        }

        // Return the URL path to the uploaded file
        const logoUrl = `/uploads/${req.file.filename}`;
        console.log("Returning logo URL:", logoUrl);
        res.json({ url: logoUrl });
      } catch (error) {
        console.error("Error uploading logo:", error);
        res.status(500).json({ error: handleError(error) });
      }
    });
  });

  // CoinGecko price proxy endpoint
  app.get("/api/prices", async (req, res) => {
    try {
      const { ids } = req.query;
      if (!ids || typeof ids !== 'string') {
        return res.status(400).json({ error: "Missing 'ids' parameter" });
      }
      
      const response = await fetch(
        `https://api.coingecko.com/api/v3/simple/price?ids=${encodeURIComponent(ids)}&vs_currencies=usd&include_24hr_vol=true&include_24hr_change=true&include_market_cap=true`
      );
      
      if (!response.ok) {
        throw new Error(`CoinGecko API error: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      res.json(data);
    } catch (error) {
      console.error("Error fetching prices from CoinGecko:", error);
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Trade batch processing endpoints
  app.post("/api/trades/process-batch", requireAdmin, async (req, res) => {
    try {
      // Manually trigger batch processing
      const { tradeBatchProcessor } = await import('./services/tradeBatchProcessor');
      
      // Run async without waiting
      tradeBatchProcessor.processTradeBatch().catch(error => {
        console.error('Manual batch processing error:', error);
      });
      
      res.json({ 
        success: true, 
        message: 'Batch processing started in background' 
      });
    } catch (error) {
      res.status(500).json({ error: 'Failed to start batch processing' });
    }
  });
  
  app.get("/api/trades/batch-status", requireAdmin, async (req, res) => {
    try {
      // Get recent batch processing logs
      const recentLogs = await db
        .select()
        .from(auditLogs)
        .where(eq(auditLogs.resource, 'trade_batch_processor'))
        .orderBy(desc(auditLogs.createdAt))
        .limit(10);
      
      res.json({ 
        success: true,
        logs: recentLogs 
      });
    } catch (error) {
      res.status(500).json({ error: 'Failed to get batch status' });
    }
  });

  // Privy configuration endpoint
  app.get("/api/privy/config", async (req, res) => {
    try {
      const appId = process.env.PRIVY_APP_ID;
      if (!appId) {
        return res.status(500).json({ error: "Privy app ID not configured" });
      }
      res.json({ appId });
    } catch (error) {
      console.error("Error fetching Privy config:", error);
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Save wallet address from Privy
  app.post("/api/privy/wallet", async (req, res) => {
    try {
      const { walletAddress, email } = req.body;
      
      if (!walletAddress || !email) {
        return res.status(400).json({ error: "Wallet address and email required" });
      }

      // Check if user exists by email
      let user = await storage.getUserByEmail(email);
      
      if (user) {
        // Update existing user with wallet address
        user = await storage.updateUserWallet(user.id, walletAddress);
      } else {
        // Create new user with wallet address
        user = await storage.createUser({
          email,
          username: email.split('@')[0], // Simple username from email
          password: 'privy-wallet-user', // Placeholder for wallet users
          walletAddress
        });
      }

      res.json({ success: true, userId: user.id });
    } catch (error) {
      console.error("Error saving wallet address:", error);
      res.status(500).json({ error: handleError(error) });
    }
  });

  // Admin platform security endpoints
  app.get("/api/admin/platforms/suspicious", requireAdmin, async (req, res) => {
    try {
      const { SecurityService } = await import("./services/security");
      const { suspiciousActivity, platformSecurity } = await import("@shared/schema");
      
      // Get all suspicious platforms
      const suspiciousReports = await db
        .select({
          activity: suspiciousActivity,
          security: platformSecurity,
          platform: tradingPlatforms,
        })
        .from(suspiciousActivity)
        .leftJoin(platformSecurity, eq(suspiciousActivity.platformId, platformSecurity.platformId))
        .leftJoin(tradingPlatforms, eq(suspiciousActivity.platformId, tradingPlatforms.id))
        .orderBy(desc(suspiciousActivity.reportedAt))
        .limit(50);
      
      res.json({ reports: suspiciousReports });
    } catch (error) {
      console.error("Error fetching suspicious platforms:", error);
      res.status(500).json({ error: handleError(error) });
    }
  });
  
  app.get("/api/admin/platforms/:id/security", requireAdmin, async (req, res) => {
    try {
      const platformId = parseInt(req.params.id);
      const { SecurityService } = await import("./services/security");
      
      const securityStatus = await SecurityService.getPlatformSecurityStatus(platformId);
      res.json(securityStatus);
    } catch (error) {
      console.error("Error fetching platform security:", error);
      res.status(500).json({ error: handleError(error) });
    }
  });
  
  app.post("/api/admin/platforms/:id/review", requireAdmin, async (req, res) => {
    try {
      const platformId = parseInt(req.params.id);
      const { reviewNotes, approve } = req.body;
      
      const { SecurityService } = await import("./services/security");
      await SecurityService.reviewPlatform(platformId, reviewNotes, approve);
      
      res.json({ success: true });
    } catch (error) {
      console.error("Error reviewing platform:", error);
      res.status(500).json({ error: handleError(error) });
    }
  });
  
  app.post("/api/admin/platforms/:id/suspend", requireAdmin, async (req, res) => {
    try {
      const platformId = parseInt(req.params.id);
      const { reason } = req.body;
      
      const { SecurityService } = await import("./services/security");
      await SecurityService.suspendPlatform(platformId, reason);
      
      res.json({ success: true });
    } catch (error) {
      console.error("Error suspending platform:", error);
      res.status(500).json({ error: handleError(error) });
    }
  });
  
  app.post("/api/admin/platforms/:id/ban", requireAdmin, async (req, res) => {
    try {
      const platformId = parseInt(req.params.id);
      const { reason } = req.body;
      
      const { SecurityService } = await import("./services/security");
      await SecurityService.banPlatform(platformId, reason);
      
      res.json({ success: true });
    } catch (error) {
      console.error("Error banning platform:", error);
      res.status(500).json({ error: handleError(error) });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
```

---

## File: server/security/antiPhishing.ts

```typescript
import crypto from 'crypto';
import { db } from '../db';
import { tradingPlatforms, platformSecurity } from '@shared/schema';
import { eq } from 'drizzle-orm';

// Generate unique anti-phishing code for each user
export function generateAntiPhishingCode(): string {
  return crypto.randomBytes(8).toString('hex').toUpperCase();
}

// Check if domain is legitimate
export async function isLegitimateplatformDomain(domain: string): Promise<boolean> {
  // Check if it's an official LiquidLab domain
  if (domain.endsWith('.liquidlab.trade') || domain === 'liquidlab.trade') {
    return true;
  }
  
  // Check if it's a verified custom domain
  const [platform] = await db
    .select()
    .from(tradingPlatforms)
    .where(eq(tradingPlatforms.customDomain, domain));
    
  return !!platform;
}

// Detect suspicious URLs
export function detectSuspiciousUrl(url: string): {
  suspicious: boolean;
  reasons: string[];
} {
  const reasons: string[] = [];
  
  // Check for homograph attacks (lookalike characters)
  const suspiciousPatterns = [
    /[а-яА-Я]/, // Cyrillic characters
    /[\u4e00-\u9fff]/, // Chinese characters
    /[\u0590-\u05ff]/, // Hebrew characters
    /[\u0600-\u06ff]/, // Arabic characters
  ];
  
  for (const pattern of suspiciousPatterns) {
    if (pattern.test(url)) {
      reasons.push('Contains suspicious unicode characters');
    }
  }
  
  // Check for common phishing patterns
  const phishingPatterns = [
    /liquidlab\.tk/i,
    /liquidlab-trade\./i,
    /liquid-lab\./i,
    /liquidlabs\./i,
    /liquidlab\d+\./i,
    /secure-liquidlab/i,
    /liquidlab-verify/i,
  ];
  
  for (const pattern of phishingPatterns) {
    if (pattern.test(url)) {
      reasons.push('URL matches known phishing pattern');
    }
  }
  
  // Check for URL shorteners
  const shorteners = ['bit.ly', 'tinyurl.com', 'goo.gl', 't.co', 'short.link'];
  for (const shortener of shorteners) {
    if (url.includes(shortener)) {
      reasons.push('Uses URL shortener service');
    }
  }
  
  return {
    suspicious: reasons.length > 0,
    reasons
  };
}

// Email header authentication
export function generateEmailSignature(content: string): string {
  const secret = process.env.EMAIL_SIGNING_SECRET || 'default-secret';
  return crypto
    .createHmac('sha256', secret)
    .update(content)
    .digest('hex');
}

// Add security warning banner for suspicious activity
export function generateSecurityWarningHtml(platformId: number): string {
  return `
    <div style="background-color: #ff0000; color: white; padding: 20px; text-align: center; font-size: 18px;">
      <strong>⚠️ SECURITY WARNING ⚠️</strong><br>
      This platform may be compromised. Please verify at:
      <a href="https://liquidlab.trade/verify/${platformId}" style="color: white; text-decoration: underline;">
        liquidlab.trade/verify/${platformId}
      </a>
    </div>
  `;
}
```

---

## File: server/security/apiKeys.ts

```typescript
import { randomBytes, createHash } from 'crypto';
import { apiKeys, type InsertApiKey, type ApiKey } from '@shared/schema';
import { db } from '../db';
import { eq, and, gt, or } from 'drizzle-orm';

// Generate a secure API key and secret
export function generateApiKeyPair() {
  const key = `llk_${randomBytes(24).toString('hex')}`; // llk = LiquidLab Key
  const secret = `lls_${randomBytes(32).toString('hex')}`; // lls = LiquidLab Secret
  const secretHash = hashSecret(secret);
  
  return { key, secret, secretHash };
}

// Hash the secret for storage
export function hashSecret(secret: string): string {
  return createHash('sha256').update(secret).digest('hex');
}

// Validate API key and secret
export async function validateApiKey(
  key: string, 
  secret: string
): Promise<{ valid: boolean; apiKey?: ApiKey }> {
  try {
    // Find the API key
    const [apiKey] = await db
      .select()
      .from(apiKeys)
      .where(
        and(
          eq(apiKeys.key, key),
          eq(apiKeys.revokedAt, null),
          or(
            eq(apiKeys.expiresAt, null),
            gt(apiKeys.expiresAt, new Date())
          )
        )
      );

    if (!apiKey) {
      return { valid: false };
    }

    // Verify the secret
    const secretHash = hashSecret(secret);
    if (apiKey.secretHash !== secretHash) {
      return { valid: false };
    }

    // Update last used timestamp
    await db
      .update(apiKeys)
      .set({ lastUsedAt: new Date() })
      .where(eq(apiKeys.id, apiKey.id));

    return { valid: true, apiKey };
  } catch (error) {
    console.error('Error validating API key:', error);
    return { valid: false };
  }
}

// Create a new API key for a platform
export async function createApiKey(
  platformId: number,
  name?: string,
  permissions: string[] = ['read', 'write'],
  expiresIn?: number // days
): Promise<{ apiKey: ApiKey; secret: string }> {
  const { key, secret, secretHash } = generateApiKeyPair();
  
  const apiKeyData: InsertApiKey = {
    platformId,
    key,
    secretHash,
    name: name || 'Default API Key',
    permissions,
    expiresAt: expiresIn ? new Date(Date.now() + expiresIn * 24 * 60 * 60 * 1000) : null,
  };

  const [apiKey] = await db
    .insert(apiKeys)
    .values(apiKeyData)
    .returning();

  return { apiKey, secret };
}

// Revoke an API key
export async function revokeApiKey(keyId: number): Promise<boolean> {
  try {
    await db
      .update(apiKeys)
      .set({ revokedAt: new Date() })
      .where(eq(apiKeys.id, keyId));
    
    return true;
  } catch (error) {
    console.error('Error revoking API key:', error);
    return false;
  }
}

// Get all API keys for a platform
export async function getPlatformApiKeys(platformId: number): Promise<ApiKey[]> {
  return await db
    .select()
    .from(apiKeys)
    .where(
      and(
        eq(apiKeys.platformId, platformId),
        eq(apiKeys.revokedAt, null)
      )
    );
}
```

---

## File: server/security/auditLog.ts

```typescript
import { db } from '../db';
import { Request } from 'express';

export enum SecurityEventType {
  LOGIN_SUCCESS = 'LOGIN_SUCCESS',
  LOGIN_FAILED = 'LOGIN_FAILED',
  LOGOUT = 'LOGOUT',
  PASSWORD_RESET = 'PASSWORD_RESET',
  API_KEY_CREATED = 'API_KEY_CREATED',
  API_KEY_REVOKED = 'API_KEY_REVOKED',
  SUSPICIOUS_ACTIVITY = 'SUSPICIOUS_ACTIVITY',
  PLATFORM_CREATED = 'PLATFORM_CREATED',
  PLATFORM_MODIFIED = 'PLATFORM_MODIFIED',
  PLATFORM_SUSPENDED = 'PLATFORM_SUSPENDED',
  TRADE_EXECUTED = 'TRADE_EXECUTED',
  PAYOUT_PROCESSED = 'PAYOUT_PROCESSED',
  ADMIN_ACTION = 'ADMIN_ACTION'
}

interface SecurityEvent {
  type: SecurityEventType;
  userId?: number;
  platformId?: number;
  ipAddress: string;
  userAgent?: string;
  details: any;
  timestamp: Date;
}

export class SecurityAuditLogger {
  async logEvent(event: SecurityEvent): Promise<void> {
    try {
      // In production, this would write to a dedicated audit log table
      // Redact sensitive details from console logging
      const sanitizedEvent = {
        type: event.type,
        userId: event.userId,
        platformId: event.platformId,
        ipAddress: event.ipAddress,
        timestamp: new Date().toISOString(),
        // Don't log potentially sensitive details to console
        detailsRedacted: true
      };
      console.log('[SECURITY AUDIT]', sanitizedEvent);
      
      // TODO: Implement database logging
      // await db.insert(auditLogs).values(event);
    } catch (error) {
      console.error('Failed to log security event:', error);
    }
  }
  
  async logRequest(req: Request, eventType: SecurityEventType, details: any = {}): Promise<void> {
    await this.logEvent({
      type: eventType,
      userId: (req as any).user?.id,
      ipAddress: req.ip,
      userAgent: req.headers['user-agent'],
      details: {
        ...details,
        path: req.path,
        method: req.method
      },
      timestamp: new Date()
    });
  }
  
  async detectAnomalies(userId: number): Promise<boolean> {
    // Check for suspicious patterns like:
    // - Multiple login locations in short time
    // - Unusual trading volumes
    // - Rapid API calls
    // This is a placeholder for more sophisticated anomaly detection
    return false;
  }
}

export const auditLogger = new SecurityAuditLogger();
```

---

## File: server/security/audit.ts

```typescript
import { auditLogs, type InsertAuditLog } from '@shared/schema';
import { db } from '../db';
import { and, eq, gte, desc } from 'drizzle-orm';

// Create an audit log entry
export async function createAuditLog(data: InsertAuditLog): Promise<void> {
  try {
    await db.insert(auditLogs).values(data);
  } catch (error) {
    console.error('Failed to create audit log:', error);
    // Don't throw - audit logging should not break the application
  }
}

// Get audit logs for a platform
export async function getPlatformAuditLogs(
  platformId: number,
  options: {
    limit?: number;
    offset?: number;
    startDate?: Date;
    action?: string;
  } = {}
): Promise<any[]> {
  const { limit = 100, offset = 0, startDate, action } = options;

  const conditions = [eq(auditLogs.platformId, platformId)];
  
  if (startDate) {
    conditions.push(gte(auditLogs.createdAt, startDate));
  }
  
  if (action) {
    conditions.push(eq(auditLogs.action, action));
  }

  return await db
    .select()
    .from(auditLogs)
    .where(and(...conditions))
    .orderBy(desc(auditLogs.createdAt))
    .limit(limit)
    .offset(offset);
}

// Get user audit logs
export async function getUserAuditLogs(
  userId: number,
  options: {
    limit?: number;
    offset?: number;
    startDate?: Date;
  } = {}
): Promise<any[]> {
  const { limit = 100, offset = 0, startDate } = options;

  const conditions = [eq(auditLogs.userId, userId)];
  
  if (startDate) {
    conditions.push(gte(auditLogs.createdAt, startDate));
  }

  return await db
    .select()
    .from(auditLogs)
    .where(and(...conditions))
    .orderBy(desc(auditLogs.createdAt))
    .limit(limit)
    .offset(offset);
}

// Common audit log actions
export const AuditActions = {
  // Authentication
  API_AUTH_SUCCESS: 'api_auth_success',
  API_AUTH_FAILED: 'api_auth_failed',
  USER_LOGIN: 'user_login',
  USER_LOGOUT: 'user_logout',
  
  // Platform management
  PLATFORM_CREATED: 'platform_created',
  PLATFORM_UPDATED: 'platform_updated',
  PLATFORM_DELETED: 'platform_deleted',
  
  // API Key management
  API_KEY_CREATED: 'api_key_created',
  API_KEY_REVOKED: 'api_key_revoked',
  
  // Trading
  ORDER_PLACED: 'order_placed',
  ORDER_CANCELLED: 'order_cancelled',
  ORDER_FILLED: 'order_filled',
  
  // Errors
  API_ERROR: 'api_error',
  SYSTEM_ERROR: 'system_error',
};
```

---

## File: server/security/auth.ts

```typescript
import bcrypt from 'bcryptjs';
import speakeasy from 'speakeasy';
import QRCode from 'qrcode';
import { Request, Response } from 'express';

// Password strength requirements
export function validatePasswordStrength(password: string): {
  valid: boolean;
  errors: string[];
} {
  const errors: string[] = [];
  
  if (password.length < 12) {
    errors.push('Password must be at least 12 characters long');
  }
  if (!/[A-Z]/.test(password)) {
    errors.push('Password must contain at least one uppercase letter');
  }
  if (!/[a-z]/.test(password)) {
    errors.push('Password must contain at least one lowercase letter');
  }
  if (!/[0-9]/.test(password)) {
    errors.push('Password must contain at least one number');
  }
  if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    errors.push('Password must contain at least one special character');
  }
  
  // Check for common passwords
  const commonPasswords = ['password123', 'admin123', 'liquidlab123', 'trading123'];
  if (commonPasswords.some(common => password.toLowerCase().includes(common))) {
    errors.push('Password is too common');
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}

// Generate 2FA secret
export function generate2FASecret(email: string) {
  const secret = speakeasy.generateSecret({
    name: `LiquidLab (${email})`,
    issuer: 'LiquidLab',
    length: 32
  });
  
  return secret;
}

// Generate QR code for 2FA
export async function generateQRCode(otpauthUrl: string): Promise<string> {
  return QRCode.toDataURL(otpauthUrl);
}

// Verify 2FA token
export function verify2FAToken(secret: string, token: string): boolean {
  return speakeasy.totp.verify({
    secret,
    encoding: 'base32',
    token,
    window: 2 // Allow 2 time steps for clock drift
  });
}

// Session security
export function configureSecureSession() {
  return {
    secret: process.env.SESSION_SECRET!,
    resave: false,
    saveUninitialized: false,
    rolling: true, // Reset expiry on activity
    cookie: {
      secure: process.env.NODE_ENV === 'production',
      httpOnly: true,
      maxAge: 30 * 60 * 1000, // 30 minutes
      sameSite: 'strict' as const
    }
  };
}

// Track failed login attempts
const loginAttempts = new Map<string, {
  count: number;
  lastAttempt: number;
}>();

export function trackLoginAttempt(identifier: string, success: boolean) {
  const key = identifier.toLowerCase();
  const now = Date.now();
  
  if (success) {
    loginAttempts.delete(key);
    return { locked: false };
  }
  
  const attempts = loginAttempts.get(key) || { count: 0, lastAttempt: now };
  
  // Reset if last attempt was over 15 minutes ago
  if (now - attempts.lastAttempt > 15 * 60 * 1000) {
    attempts.count = 0;
  }
  
  attempts.count++;
  attempts.lastAttempt = now;
  loginAttempts.set(key, attempts);
  
  // Lock after 5 failed attempts
  const locked = attempts.count >= 5;
  
  return {
    locked,
    remainingAttempts: Math.max(0, 5 - attempts.count),
    lockoutTime: locked ? 15 : 0
  };
}

// Secure password hashing with higher cost factor
export async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, 12); // Higher cost factor for better security
}

// IP-based security checks
export function checkSuspiciousIP(req: Request): boolean {
  const ip = req.ip;
  
  // Check for VPN/Proxy headers
  const suspiciousHeaders = [
    'x-forwarded-for',
    'x-real-ip',
    'x-originating-ip',
    'x-forwarded',
    'x-remote-ip',
    'x-remote-addr'
  ];
  
  let suspiciousCount = 0;
  for (const header of suspiciousHeaders) {
    if (req.headers[header]) {
      suspiciousCount++;
    }
  }
  
  // Multiple proxy headers might indicate an attempt to hide origin
  return suspiciousCount > 2;
}
```

---

## File: server/security/csrf.ts

```typescript
import csrf from 'csurf';
import { Request, Response, NextFunction } from 'express';

// Configure CSRF protection
export const csrfProtection = csrf({
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict'
  }
});

// Middleware to add CSRF token to response locals
export const addCsrfToken = (req: Request, res: Response, next: NextFunction) => {
  res.locals.csrfToken = req.csrfToken?.();
  next();
};

// Exempt certain routes from CSRF protection (e.g., webhooks)
export const csrfExemptRoutes = [
  '/api/webhooks/hyperliquid',
  '/api/webhooks/moonpay',
  '/api/moonpay/webhook'
];
```

---

## File: server/security/customRateLimiter.ts

```typescript
import { Request, Response, NextFunction } from 'express';

interface RateLimitOptions {
  windowMs: number;
  max: number;
  message?: string;
  skipSuccessfulRequests?: boolean;
  standardHeaders?: boolean;
  legacyHeaders?: boolean;
}

interface RateLimitStore {
  [key: string]: {
    count: number;
    resetTime: number;
  };
}

// Custom rate limiter that doesn't depend on the vulnerable 'ip' package
export function createRateLimiter(options: RateLimitOptions) {
  const store: RateLimitStore = {};
  
  return (req: Request, res: Response, next: NextFunction) => {
    // Get client identifier (IP address)
    const clientIp = 
      (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() ||
      (req.headers['x-real-ip'] as string) ||
      req.socket.remoteAddress ||
      'unknown';
    
    const now = Date.now();
    const windowStart = now - options.windowMs;
    
    // Clean up old entries
    Object.keys(store).forEach(key => {
      if (store[key].resetTime < now) {
        delete store[key];
      }
    });
    
    // Get or create client record
    if (!store[clientIp] || store[clientIp].resetTime < now) {
      store[clientIp] = {
        count: 0,
        resetTime: now + options.windowMs
      };
    }
    
    const clientData = store[clientIp];
    
    // Skip successful requests if configured
    if (options.skipSuccessfulRequests && res.statusCode < 400) {
      res.on('finish', () => {
        if (res.statusCode >= 400) {
          clientData.count++;
        }
      });
    } else {
      clientData.count++;
    }
    
    // Check if limit exceeded
    if (clientData.count > options.max) {
      if (options.standardHeaders) {
        res.setHeader('RateLimit-Limit', options.max.toString());
        res.setHeader('RateLimit-Remaining', '0');
        res.setHeader('RateLimit-Reset', new Date(clientData.resetTime).toISOString());
      }
      
      return res.status(429).json({
        error: options.message || 'Too many requests, please try again later.'
      });
    }
    
    // Add rate limit headers
    if (options.standardHeaders) {
      res.setHeader('RateLimit-Limit', options.max.toString());
      res.setHeader('RateLimit-Remaining', (options.max - clientData.count).toString());
      res.setHeader('RateLimit-Reset', new Date(clientData.resetTime).toISOString());
    }
    
    next();
  };
}

// General API rate limiter
export const apiLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 500, // Limit each IP to 500 requests per windowMs
  message: 'Too many requests from this IP, please try again later.',
  standardHeaders: true,
  legacyHeaders: false,
});

// Strict rate limiter for auth endpoints
export const authLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 20, // Limit each IP to 20 requests per windowMs
  message: 'Too many authentication attempts, please try again later.',
  skipSuccessfulRequests: true, // Don't count successful requests
  standardHeaders: true,
});

// Trading endpoint rate limiter
export const tradingLimiter = createRateLimiter({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 30, // Limit each IP to 30 trades per minute
  message: 'Trading rate limit exceeded, please slow down.',
  standardHeaders: true,
});

// Hyperliquid API rate limiter
export const hyperliquidLimiter = createRateLimiter({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 60, // Hyperliquid allows ~60 requests per minute
  message: 'Hyperliquid API rate limit exceeded.',
  standardHeaders: true,
});
```

---

## File: server/security/headers.ts

```typescript
import helmet from 'helmet';
import { Express } from 'express';

export function configureSecurityHeaders(app: Express) {
  // Basic security headers
  app.use(helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        scriptSrc: [
          "'self'",
          "'unsafe-inline'", // Required for TradingView
          "'unsafe-eval'", // Required for some libraries
          "https://s3.tradingview.com",
          "https://static.tradingview.com",
          "https://cdn.hyperliquid.xyz",
          "https://sdk.moonpay.com"
        ],
        styleSrc: [
          "'self'",
          "'unsafe-inline'",
          "https://fonts.googleapis.com"
        ],
        fontSrc: [
          "'self'",
          "https://fonts.gstatic.com"
        ],
        imgSrc: [
          "'self'",
          "data:",
          "https:",
          "blob:"
        ],
        connectSrc: [
          "'self'",
          "http://localhost:*", // Development
          "https://*.replit.dev", // Replit development
          "https://api.hyperliquid.xyz",
          "https://api-hl.hyperliquid.xyz", 
          "https://api.moonpay.com",
          "wss://api.hyperliquid.xyz",
          "https://*.tradingview.com",
          "https://api.coingecko.com",
          "https://auth.privy.io",
          "https://*.privy.io"
        ],
        frameSrc: [
          "'self'",
          "https://www.tradingview.com",
          "https://widget.moonpay.com"
        ],
        objectSrc: ["'none'"],
        upgradeInsecureRequests: [],
        // Allow iframe embedding from any source in development
        frameAncestors: process.env.NODE_ENV === 'development' ? ["*"] : ["'self'"],
        baseUri: ["'self'"],
        formAction: ["'self'"],
        scriptSrcAttr: ["'none'"]
      }
    },
    crossOriginEmbedderPolicy: false, // Required for TradingView
    frameguard: {
      action: 'deny' // Protect against clickjacking - CSP frameAncestors will handle embedding rules
    },
    hsts: {
      maxAge: 31536000,
      includeSubDomains: true,
      preload: true
    }
  }));

  // Additional security headers (X-Frame-Options handled by Helmet frameguard)
  app.use((req, res, next) => {
    // Enable XSS filter
    res.setHeader('X-XSS-Protection', '1; mode=block');
    
    // Referrer policy
    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
    
    // Permissions policy
    res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');
    
    next();
  });
}
```

---

## File: server/security/index.ts

```typescript
import { Express } from 'express';
import { configureSecurityHeaders } from './headers';
import { sanitizeMiddleware } from './validation';
import { apiLimiter, authLimiter, tradingLimiter } from './customRateLimiter';
import { csrfProtection, csrfExemptRoutes } from './csrf';
import { auditLogger, SecurityEventType } from './auditLog';
import { platformCors } from './middleware';

export function configureSecurity(app: Express) {
  // Enable trust proxy with specific configuration for Replit environment
  app.set('trust proxy', process.env.NODE_ENV === 'production' ? 1 : false);
  
  // 1. CORS configuration
  app.use('/api/', platformCors);
  
  // 2. Security headers
  configureSecurityHeaders(app);
  
  // 3. Input sanitization
  app.use(sanitizeMiddleware);
  
  // 4. Rate limiting
  app.use('/api/', apiLimiter);
  app.use('/api/auth/', authLimiter);
  app.use('/api/trade/', tradingLimiter);
  app.use('/api/hyperliquid/trade', tradingLimiter);
  
  // 5. CSRF protection
  app.use((req, res, next) => {
    // Skip CSRF for exempt routes (webhooks)
    if (csrfExemptRoutes.some(route => req.path.startsWith(route))) {
      return next();
    }
    // Skip CSRF for GET requests (they should be safe/idempotent)
    if (req.method === 'GET' || req.method === 'HEAD' || req.method === 'OPTIONS') {
      return next();
    }
    csrfProtection(req, res, next);
  });
  
  // 6. Audit logging for security events
  app.use('/api/auth/login', async (req, res, next) => {
    res.on('finish', async () => {
      const success = res.statusCode === 200;
      await auditLogger.logRequest(
        req,
        success ? SecurityEventType.LOGIN_SUCCESS : SecurityEventType.LOGIN_FAILED,
        { email: req.body?.email }
      );
    });
    next();
  });
  
  // 7. Error handling to prevent information leakage
  app.use((err: any, req: any, res: any, next: any) => {
    // Log full error internally
    console.error('Security Error:', err);
    
    // Send generic error to client
    if (err.code === 'EBADCSRFTOKEN') {
      res.status(403).json({ error: 'Invalid CSRF token' });
    } else if (err.status === 429) {
      res.status(429).json({ error: 'Too many requests' });
    } else {
      res.status(500).json({ error: 'Internal server error' });
    }
  });
}
```

---

## File: server/security/metrics.ts

```typescript
import { platformMetrics, type InsertPlatformMetric, type PlatformMetric } from '@shared/schema';
import { db } from '../db';
import { and, eq, gte, lte, sql } from 'drizzle-orm';

// Metrics collection interface
interface MetricsData {
  platformId: number;
  uniqueVisitors?: number;
  pageViews?: number;
  tradingVolume?: string;
  revenueGenerated?: string;
  apiCalls?: number;
  errorRate?: string;
  avgResponseTime?: number;
}

// Collect and store metrics for a platform
export async function collectPlatformMetrics(data: MetricsData): Promise<void> {
  const today = new Date().toISOString().split('T')[0];
  
  try {
    // Upsert metrics for today
    await db
      .insert(platformMetrics)
      .values({
        platformId: data.platformId,
        date: today,
        uniqueVisitors: data.uniqueVisitors || 0,
        pageViews: data.pageViews || 0,
        tradingVolume: data.tradingVolume || '0',
        revenueGenerated: data.revenueGenerated || '0',
        apiCalls: data.apiCalls || 0,
        errorRate: data.errorRate || '0',
        avgResponseTime: data.avgResponseTime,
      })
      .onConflictDoUpdate({
        target: [platformMetrics.platformId, platformMetrics.date],
        set: {
          uniqueVisitors: sql`${platformMetrics.uniqueVisitors} + ${data.uniqueVisitors || 0}`,
          pageViews: sql`${platformMetrics.pageViews} + ${data.pageViews || 0}`,
          tradingVolume: sql`${platformMetrics.tradingVolume} + ${data.tradingVolume || '0'}`,
          revenueGenerated: sql`${platformMetrics.revenueGenerated} + ${data.revenueGenerated || '0'}`,
          apiCalls: sql`${platformMetrics.apiCalls} + ${data.apiCalls || 1}`,
          // For error rate and response time, we need a more sophisticated calculation
          errorRate: data.errorRate || sql`${platformMetrics.errorRate}`,
          avgResponseTime: data.avgResponseTime || sql`${platformMetrics.avgResponseTime}`,
        },
      });
  } catch (error) {
    console.error('Failed to collect platform metrics:', error);
  }
}

// Get platform metrics for a date range
export async function getPlatformMetrics(
  platformId: number,
  startDate: string,
  endDate: string
): Promise<PlatformMetric[]> {
  return await db
    .select()
    .from(platformMetrics)
    .where(
      and(
        eq(platformMetrics.platformId, platformId),
        gte(platformMetrics.date, startDate),
        lte(platformMetrics.date, endDate)
      )
    )
    .orderBy(platformMetrics.date);
}

// Get aggregated platform metrics
export async function getAggregatedMetrics(
  platformId: number,
  period: '7d' | '30d' | '90d' | 'all'
): Promise<{
  totalUniqueVisitors: number;
  totalPageViews: number;
  totalTradingVolume: string;
  totalRevenue: string;
  totalApiCalls: number;
  avgErrorRate: string;
  avgResponseTime: number;
}> {
  const endDate = new Date().toISOString().split('T')[0];
  let startDate: string;
  
  switch (period) {
    case '7d':
      startDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      break;
    case '30d':
      startDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      break;
    case '90d':
      startDate = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      break;
    default:
      startDate = '2024-01-01'; // Platform launch date
  }
  
  const [result] = await db
    .select({
      totalUniqueVisitors: sql<number>`sum(${platformMetrics.uniqueVisitors})::int`,
      totalPageViews: sql<number>`sum(${platformMetrics.pageViews})::int`,
      totalTradingVolume: sql<string>`sum(${platformMetrics.tradingVolume})::text`,
      totalRevenue: sql<string>`sum(${platformMetrics.revenueGenerated})::text`,
      totalApiCalls: sql<number>`sum(${platformMetrics.apiCalls})::int`,
      avgErrorRate: sql<string>`avg(${platformMetrics.errorRate})::text`,
      avgResponseTime: sql<number>`avg(${platformMetrics.avgResponseTime})::int`,
    })
    .from(platformMetrics)
    .where(
      and(
        eq(platformMetrics.platformId, platformId),
        gte(platformMetrics.date, startDate),
        lte(platformMetrics.date, endDate)
      )
    );
  
  return {
    totalUniqueVisitors: result?.totalUniqueVisitors || 0,
    totalPageViews: result?.totalPageViews || 0,
    totalTradingVolume: result?.totalTradingVolume || '0',
    totalRevenue: result?.totalRevenue || '0',
    totalApiCalls: result?.totalApiCalls || 0,
    avgErrorRate: result?.avgErrorRate || '0',
    avgResponseTime: result?.avgResponseTime || 0,
  };
}

// Middleware to track API metrics
import type { Request, Response, NextFunction } from 'express';

export function trackApiMetrics(req: Request, res: Response, next: NextFunction) {
  const startTime = Date.now();
  
  // Override res.json to track response
  const originalJson = res.json.bind(res);
  res.json = function(data: any) {
    const responseTime = Date.now() - startTime;
    const isError = res.statusCode >= 400;
    
    // Collect metrics if platform ID is available
    if (req.platformId) {
      collectPlatformMetrics({
        platformId: req.platformId,
        apiCalls: 1,
        errorRate: isError ? '1' : '0',
        avgResponseTime: responseTime,
      }).catch(console.error);
    }
    
    return originalJson(data);
  };
  
  next();
}
```

---

## File: server/security/middleware.ts

```typescript
import type { Request, Response, NextFunction } from 'express';
import { validateApiKey } from './apiKeys';
import { createAuditLog } from './audit';
// Rate limiters are imported in index.ts, not needed here
import { ApiKey } from '@shared/schema';

// Extend Express Request type
declare global {
  namespace Express {
    interface Request {
      apiKey?: ApiKey;
      platformId?: number;
    }
  }
}

// API Authentication Middleware
export async function authenticateApi(
  req: Request,
  res: Response,
  next: NextFunction
) {
  const apiKey = req.headers['x-api-key'] as string;
  const apiSecret = req.headers['x-api-secret'] as string;

  if (!apiKey || !apiSecret) {
    return res.status(401).json({
      error: 'Missing API credentials',
      message: 'Please provide X-API-Key and X-API-Secret headers',
    });
  }

  const { valid, apiKey: keyData } = await validateApiKey(apiKey, apiSecret);

  if (!valid || !keyData) {
    await createAuditLog({
      action: 'api_auth_failed',
      resource: 'api',
      ipAddress: getClientIp(req),
      userAgent: req.headers['user-agent'] || null,
      metadata: { apiKeyPrefix: apiKey ? apiKey.substring(0, 8) + '...' : 'none' },
    });

    return res.status(401).json({
      error: 'Invalid API credentials',
      message: 'The provided API key or secret is invalid',
    });
  }

  // Check permissions
  const requiredPermission = getRequiredPermission(req.method);
  if (!keyData.permissions.includes(requiredPermission)) {
    return res.status(403).json({
      error: 'Insufficient permissions',
      message: `This API key does not have ${requiredPermission} permission`,
    });
  }

  // Attach API key data to request
  req.apiKey = keyData;
  req.platformId = keyData.platformId;

  // Log successful authentication
  await createAuditLog({
    platformId: keyData.platformId,
    action: 'api_auth_success',
    resource: 'api',
    ipAddress: getClientIp(req),
    userAgent: req.headers['user-agent'] || null,
    metadata: { apiKeyId: keyData.id },
  });

  next();
}

// CORS middleware for platform domains
export async function platformCors(
  req: Request,
  res: Response,
  next: NextFunction
) {
  const origin = req.headers.origin;
  
  if (!origin) {
    return next();
  }

  // Security: Reject "null" origin to prevent attacks
  if (origin === 'null' || origin === 'file://') {
    return next();
  }

  // In development, validate origin before allowing credentials
  if (process.env.NODE_ENV === 'development') {
    // Validate origin is a proper URL even in development
    try {
      const parsedUrl = new URL(origin);
      // Only allow http/https protocols
      if (parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:') {
        res.setHeader('Access-Control-Allow-Origin', origin);
        res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
        res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-API-Key, X-API-Secret');
        res.setHeader('Access-Control-Allow-Credentials', 'true');
      }
    } catch (error) {
      // Invalid origin URL, don't set CORS headers
      console.warn('Invalid origin in development:', origin);
    }
    
    if (req.method === 'OPTIONS') {
      return res.sendStatus(204);
    }
    
    return next();
  }

  // In production, validate against allowed domains
  const staticAllowedOrigins = [
    'https://liquidlab.trade',
    'https://app.liquidlab.trade',
    /^https:\/\/[a-zA-Z0-9-]+\.liquidlab\.trade$/,
  ];

  // Check static allowed origins first
  let isAllowed = staticAllowedOrigins.some(allowed => {
    if (allowed instanceof RegExp) {
      return allowed.test(origin);
    }
    return allowed === origin;
  });

  // If not in static list, check custom domains from database
  if (!isAllowed) {
    try {
      const parsedUrl = new URL(origin);
      
      // Security: Only allow HTTPS origins in production
      if (parsedUrl.protocol !== 'https:') {
        isAllowed = false;
      } else {
        const { domainManager } = await import('../services/domainManager');
        const domain = parsedUrl.hostname;
        const platformId = await domainManager.getPlatformByDomain(domain);
        isAllowed = platformId !== null;
      }
    } catch (error) {
      // If error parsing URL or checking domain, deny access
      isAllowed = false;
    }
  }

  if (isAllowed) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-API-Key, X-API-Secret');
    res.setHeader('Access-Control-Allow-Credentials', 'true');
  }

  if (req.method === 'OPTIONS') {
    return res.sendStatus(isAllowed ? 204 : 403);
  }

  next();
}

// Security headers middleware
export function securityHeaders(
  req: Request,
  res: Response,
  next: NextFunction
) {
  // Basic security headers
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  
  // Content Security Policy
  const csp = [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://tradingview.com https://s3.tradingview.com",
    "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
    "font-src 'self' https://fonts.gstatic.com",
    "img-src 'self' data: https: blob:",
    "connect-src 'self' https://api.hyperliquid.xyz https://api.coingecko.com wss:",
    "frame-src 'self' https://tradingview.com https://www.tradingview.com",
    "object-src 'none'",
    "base-uri 'self'",
    "form-action 'self'",
    "frame-ancestors 'none'",
  ].join('; ');
  
  res.setHeader('Content-Security-Policy', csp);
  
  // Strict Transport Security (only in production with HTTPS)
  if (process.env.NODE_ENV === 'production' && req.secure) {
    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
  }
  
  next();
}

// Error handling middleware
export function errorHandler(
  err: any,
  req: Request,
  res: Response,
  next: NextFunction
) {
  // Log error
  console.error('API Error:', err);
  
  // Create audit log for errors
  createAuditLog({
    platformId: req.platformId,
    action: 'api_error',
    resource: req.path,
    ipAddress: getClientIp(req),
    userAgent: req.headers['user-agent'] || null,
    metadata: {
      error: err.message,
      stack: process.env.NODE_ENV === 'development' ? err.stack : undefined,
    },
  }).catch(console.error);
  
  // Send error response
  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';
  
  res.status(statusCode).json({
    error: message,
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack }),
  });
}

// Helper functions
function getRequiredPermission(method: string): string {
  switch (method) {
    case 'GET':
    case 'HEAD':
    case 'OPTIONS':
      return 'read';
    default:
      return 'write';
  }
}

function getClientIp(req: Request): string {
  return (
    (req.headers['x-forwarded-for'] as string)?.split(',')[0] ||
    (req.headers['x-real-ip'] as string) ||
    req.socket.remoteAddress ||
    'unknown'
  );
}

// Compose middleware for API routes
export const apiMiddleware = [
  securityHeaders,
  platformCors,
  authenticateApi,
];
```

---

## File: server/security/rateLimiter.ts

```typescript
import rateLimit from 'express-rate-limit';
import { MemoryStore } from 'express-rate-limit';

// General API rate limiter
export const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 500, // Limit each IP to 500 requests per windowMs (increased for development)
  message: 'Too many requests from this IP, please try again later.',
  standardHeaders: true,
  legacyHeaders: false,
});

// Strict rate limiter for auth endpoints
export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 20, // Limit each IP to 20 requests per windowMs (increased for development)
  message: 'Too many authentication attempts, please try again later.',
  skipSuccessfulRequests: true, // Don't count successful requests
});

// Trading endpoint rate limiter
export const tradingLimiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 30, // Limit each IP to 30 trades per minute
  message: 'Trading rate limit exceeded, please slow down.',
});

// Hyperliquid API rate limiter
export const hyperliquidLimiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 60, // Hyperliquid allows ~60 requests per minute
  message: 'Hyperliquid API rate limit exceeded.',
});
```

---

## File: server/security/validation.ts

```typescript
import { Request, Response, NextFunction } from 'express';
import validator from 'validator';
import DOMPurify from 'isomorphic-dompurify';

// Sanitize input to prevent XSS
export function sanitizeInput(input: any): any {
  if (typeof input === 'string') {
    // Remove any HTML/script tags
    return DOMPurify.sanitize(input, { ALLOWED_TAGS: [] });
  }
  if (Array.isArray(input)) {
    return input.map(sanitizeInput);
  }
  if (typeof input === 'object' && input !== null) {
    const sanitized: any = {};
    for (const key in input) {
      sanitized[key] = sanitizeInput(input[key]);
    }
    return sanitized;
  }
  return input;
}

// Middleware to sanitize all request inputs
export function sanitizeMiddleware(req: Request, res: Response, next: NextFunction) {
  req.body = sanitizeInput(req.body);
  req.query = sanitizeInput(req.query);
  req.params = sanitizeInput(req.params);
  next();
}

// Validate wallet addresses
export function isValidWalletAddress(address: string): boolean {
  return /^0x[a-fA-F0-9]{40}$/.test(address);
}

// Validate platform names
export function isValidPlatformName(name: string): boolean {
  // Allow alphanumeric, spaces, hyphens, max 50 chars
  return /^[a-zA-Z0-9\s\-]{1,50}$/.test(name);
}

// Validate URLs
export function isValidUrl(url: string): boolean {
  return validator.isURL(url, {
    protocols: ['https'],
    require_protocol: true,
    require_valid_protocol: true
  });
}

// Validate custom domains
export function isValidDomain(domain: string): boolean {
  return validator.isFQDN(domain, {
    require_tld: true,
    allow_underscores: false
  });
}

// SQL injection prevention for raw queries
export function escapeSql(value: string): string {
  return value.replace(/[\0\x08\x09\x1a\n\r"'\\\%]/g, (char) => {
    switch (char) {
      case "\0": return "\\0";
      case "\x08": return "\\b";
      case "\x09": return "\\t";
      case "\x1a": return "\\z";
      case "\n": return "\\n";
      case "\r": return "\\r";
      case "\"":
      case "'":
      case "\\":
      case "%":
        return "\\" + char;
      default:
        return char;
    }
  });
}
```

---

## File: server/services/builderFeeManager.ts

```typescript
import { db } from '../db';
import { feeTransactions, platformRevenueSummary } from '@shared/schema';
import { eq, and, sql, isNull, gte, lte } from 'drizzle-orm';
import * as ethers from 'ethers';

export interface PayoutReadiness {
  unclaimedFees: string;
  claimedNotConverted: string;
  availableForPayout: string;
  requiredForPayouts: string;
  readyToPayout: boolean;
  details: {
    platformId: number;
    unclaimedAmount: string;
    requiredAmount: string;
  }[];
}

export class BuilderFeeManager {
  private provider: ethers.Provider;
  private builderWallet?: ethers.Wallet;
  private payoutWallet?: ethers.Wallet;
  private usdcContract?: ethers.Contract;
  
  constructor() {
    // Initialize provider for Arbitrum
    this.provider = new ethers.JsonRpcProvider(
      process.env.ARBITRUM_RPC_URL || 'https://arb1.arbitrum.io/rpc'
    );
    
    // Initialize wallets if private keys are provided
    if (process.env.BUILDER_WALLET_PRIVATE_KEY) {
      this.builderWallet = new ethers.Wallet(
        process.env.BUILDER_WALLET_PRIVATE_KEY, 
        this.provider
      );
    }
    
    if (process.env.PAYOUT_WALLET_PRIVATE_KEY) {
      this.payoutWallet = new ethers.Wallet(
        process.env.PAYOUT_WALLET_PRIVATE_KEY,
        this.provider
      );
      
      // Initialize USDC contract
      const usdcAbi = [
        'function balanceOf(address account) view returns (uint256)',
        'function decimals() view returns (uint8)',
        'function transfer(address to, uint256 amount) returns (bool)',
      ];
      const usdcAddress = '0xaf88d065e77c8cC2239327C5EDb3A432268e5831'; // USDC on Arbitrum
      this.usdcContract = new ethers.Contract(usdcAddress, usdcAbi, this.provider);
    }
  }

  /**
   * Get unclaimed fees from database
   */
  async getUnclaimedFees(): Promise<{ total: string; byPlatform: Map<number, string> }> {
    const unclaimed = await db
      .select({
        platformId: feeTransactions.platformId,
        totalFees: sql<string>`SUM(${feeTransactions.totalFee})`,
      })
      .from(feeTransactions)
      .where(
        and(
          eq(feeTransactions.status, 'pending'),
          isNull(feeTransactions.claimedAt)
        )
      )
      .groupBy(feeTransactions.platformId);
    
    const byPlatform = new Map<number, string>();
    let total = 0;
    
    for (const fee of unclaimed) {
      byPlatform.set(fee.platformId, fee.totalFees);
      total += parseFloat(fee.totalFees);
    }
    
    return {
      total: total.toFixed(4),
      byPlatform,
    };
  }

  /**
   * Get claimed but not yet distributed fees
   */
  async getClaimedNotDistributed(): Promise<{ total: string; byPlatform: Map<number, string> }> {
    const claimed = await db
      .select({
        platformId: feeTransactions.platformId,
        totalFees: sql<string>`SUM(${feeTransactions.totalFee})`,
      })
      .from(feeTransactions)
      .where(
        and(
          eq(feeTransactions.status, 'claimed'),
          isNull(feeTransactions.distributedAt)
        )
      )
      .groupBy(feeTransactions.platformId);
    
    const byPlatform = new Map<number, string>();
    let total = 0;
    
    for (const fee of claimed) {
      byPlatform.set(fee.platformId, fee.totalFees);
      total += parseFloat(fee.totalFees);
    }
    
    return {
      total: total.toFixed(4),
      byPlatform,
    };
  }

  /**
   * Get available USDC balance in payout wallet
   */
  async getAvailableUSDC(): Promise<string> {
    if (!this.payoutWallet || !this.usdcContract) {
      return '0';
    }
    
    try {
      const balance = await this.usdcContract.balanceOf(this.payoutWallet.address);
      // USDC has 6 decimals
      return ethers.formatUnits(balance, 6);
    } catch (error) {
      console.error('Error fetching USDC balance:', error);
      return '0';
    }
  }

  /**
   * Calculate required payouts for a given period
   */
  async getRequiredPayouts(period: 'weekly' | 'monthly' = 'weekly'): Promise<string> {
    // Get date range based on period
    const now = new Date();
    const startDate = new Date();
    
    if (period === 'weekly') {
      startDate.setDate(now.getDate() - 7);
    } else {
      startDate.setMonth(now.getMonth() - 1);
    }
    
    // Get all platform revenue summaries for the period
    const summaries = await db
      .select({
        platformId: platformRevenueSummary.platformId,
        totalRevenue: platformRevenueSummary.totalRevenue,
      })
      .from(platformRevenueSummary)
      .where(
        and(
          eq(platformRevenueSummary.period, period),
          gte(platformRevenueSummary.periodEnd, startDate)
        )
      );
    
    let totalRequired = 0;
    
    for (const summary of summaries) {
      // Platform gets 70% of trading fees
      const tradingShare = parseFloat(summary.totalRevenue) * 0.7;
      
      // Add MoonPay earnings (would need to fetch separately)
      // For now, just using trading fees
      totalRequired += tradingShare;
    }
    
    return totalRequired.toFixed(2);
  }

  /**
   * Check payout readiness and return detailed status
   */
  async checkPayoutReadiness(period: 'weekly' | 'monthly' = 'weekly'): Promise<PayoutReadiness> {
    const [unclaimed, claimed, availableUSDC, requiredPayouts] = await Promise.all([
      this.getUnclaimedFees(),
      this.getClaimedNotDistributed(),
      this.getAvailableUSDC(),
      this.getRequiredPayouts(period),
    ]);
    
    const readyToPayout = parseFloat(availableUSDC) >= parseFloat(requiredPayouts);
    
    // Get platform-specific details
    const details: PayoutReadiness['details'] = [];
    
    for (const [platformId, unclaimedAmount] of unclaimed.byPlatform) {
      const platformRequired = (parseFloat(unclaimedAmount) * 0.7).toFixed(2);
      details.push({
        platformId,
        unclaimedAmount,
        requiredAmount: platformRequired,
      });
    }
    
    return {
      unclaimedFees: unclaimed.total,
      claimedNotConverted: claimed.total,
      availableForPayout: availableUSDC,
      requiredForPayouts: requiredPayouts,
      readyToPayout,
      details,
    };
  }

  /**
   * Mark fees as claimed (manual process completed)
   */
  async markFeesAsClaimed(
    startDate: Date,
    endDate: Date,
    claimTxHash: string
  ): Promise<{ success: boolean; feesUpdated: number }> {
    try {
      const result = await db
        .update(feeTransactions)
        .set({
          status: 'claimed',
          claimedAt: new Date(),
          claimTxHash,
        })
        .where(
          and(
            eq(feeTransactions.status, 'pending'),
            gte(feeTransactions.createdAt, startDate),
            lte(feeTransactions.createdAt, endDate)
          )
        );
      
      return {
        success: true,
        feesUpdated: result.rowCount || 0,
      };
    } catch (error) {
      console.error('Error marking fees as claimed:', error);
      return {
        success: false,
        feesUpdated: 0,
      };
    }
  }

  /**
   * Get Hyperliquid builder wallet balance (for display purposes)
   * Note: This would need Hyperliquid API integration
   */
  async getHyperliquidBalance(): Promise<string> {
    // Placeholder - would need to query Hyperliquid API
    // For now, return a mock value in development
    if (process.env.NODE_ENV === 'development') {
      return '1234.56';
    }
    return '0.00';
  }

  /**
   * Transfer USDC from builder wallet to payout wallet
   * This happens after claiming from Hyperliquid and converting to USDC
   */
  async transferToPayoutWallet(amount: string): Promise<{ 
    success: boolean; 
    txHash?: string; 
    error?: string 
  }> {
    if (!this.builderWallet || !this.payoutWallet || !this.usdcContract) {
      return {
        success: false,
        error: 'Wallets not configured',
      };
    }
    
    try {
      // Convert amount to USDC units (6 decimals)
      const usdcAmount = ethers.parseUnits(amount, 6);
      
      // Check balance
      const balance = await this.usdcContract.balanceOf(this.builderWallet.address);
      if (balance < usdcAmount) {
        return {
          success: false,
          error: 'Insufficient USDC balance in builder wallet',
        };
      }
      
      // Connect contract to builder wallet for sending
      const contractWithSigner = this.usdcContract.connect(this.builderWallet);
      
      // Send USDC to payout wallet
      const tx = await contractWithSigner.transfer(
        this.payoutWallet.address,
        usdcAmount
      );
      
      const receipt = await tx.wait();
      
      return {
        success: true,
        txHash: receipt.hash,
      };
    } catch (error: any) {
      console.error('Error transferring USDC:', error);
      return {
        success: false,
        error: error.message || 'Transfer failed',
      };
    }
  }
}

export const builderFeeManager = new BuilderFeeManager();
```

---

## File: server/services/configService.ts

```typescript
// Secure configuration service for validated contract addresses
// This service provides backend-validated addresses to prevent frontend manipulation

interface ContractConfig {
  network: string;
  address: string;
  description: string;
  lastVerified: Date;
  isActive: boolean;
}

interface NetworkConfig {
  hyperliquidBridge: ContractConfig;
  arbitrumUSDC: ContractConfig;
  arbitrumRPC: string;
  minimumDepositAmount: string;
}

class ConfigurationService {
  private static readonly NETWORKS: Record<string, NetworkConfig> = {
    production: {
      hyperliquidBridge: {
        network: 'arbitrum',
        address: '0x2df1c51e09aecf9cacb7bc98cb1742757f163df7',
        description: 'Hyperliquid Bridge Contract',
        lastVerified: new Date('2024-01-01'),
        isActive: true,
      },
      arbitrumUSDC: {
        network: 'arbitrum',
        address: '0xaf88d065e77c8cc2239327c5edb3a432268e5831',
        description: 'USDC on Arbitrum One',
        lastVerified: new Date('2024-01-01'),
        isActive: true,
      },
      arbitrumRPC: 'https://arb1.arbitrum.io/rpc',
      minimumDepositAmount: '5', // 5 USDC minimum
    },
    testnet: {
      hyperliquidBridge: {
        network: 'arbitrum-goerli',
        address: '0x2df1c51e09aecf9cacb7bc98cb1742757f163df7', // Same for now
        description: 'Hyperliquid Bridge Contract (Testnet)',
        lastVerified: new Date('2024-01-01'),
        isActive: true,
      },
      arbitrumUSDC: {
        network: 'arbitrum-goerli',
        address: '0xaf88d065e77c8cc2239327c5edb3a432268e5831', // Same for now
        description: 'USDC on Arbitrum Goerli',
        lastVerified: new Date('2024-01-01'),
        isActive: true,
      },
      arbitrumRPC: 'https://goerli-rollup.arbitrum.io/rpc',
      minimumDepositAmount: '1', // Lower for testing
    },
  };

  private static getEnvironment(): string {
    return process.env.NODE_ENV === 'production' ? 'production' : 'testnet';
  }

  /**
   * Get validated contract addresses for the current environment
   * This is the only source of truth for contract addresses
   */
  static getContractAddresses() {
    const env = this.getEnvironment();
    const config = this.NETWORKS[env];
    
    // Additional runtime validation
    if (!this.isValidAddress(config.hyperliquidBridge.address)) {
      throw new Error('Invalid Hyperliquid bridge address configuration');
    }
    
    if (!this.isValidAddress(config.arbitrumUSDC.address)) {
      throw new Error('Invalid USDC address configuration');
    }

    return {
      hyperliquidBridge: config.hyperliquidBridge.address,
      arbitrumUSDC: config.arbitrumUSDC.address,
      arbitrumRPC: config.arbitrumRPC,
      minimumDepositAmount: config.minimumDepositAmount,
      environment: env,
    };
  }

  /**
   * Validate an Ethereum address format
   */
  static isValidAddress(address: string): boolean {
    return /^0x[a-fA-F0-9]{40}$/.test(address);
  }

  /**
   * Check if a given address matches our whitelist
   */
  static isWhitelistedAddress(address: string, type: 'bridge' | 'usdc'): boolean {
    const config = this.getContractAddresses();
    
    switch (type) {
      case 'bridge':
        return address.toLowerCase() === config.hyperliquidBridge.toLowerCase();
      case 'usdc':
        return address.toLowerCase() === config.arbitrumUSDC.toLowerCase();
      default:
        return false;
    }
  }

  /**
   * Get rate limit configuration for deposits
   */
  static getDepositRateLimits() {
    return {
      maxDepositsPerHour: 5,
      maxDepositsPerDay: 20,
      maxAmountPerDeposit: '10000', // 10,000 USDC
      maxDailyVolume: '50000', // 50,000 USDC
    };
  }

  /**
   * Validate deposit parameters
   */
  static validateDepositParams(params: {
    amount: string;
    bridgeAddress: string;
    tokenAddress: string;
  }): { valid: boolean; error?: string } {
    const config = this.getContractAddresses();
    
    // Validate addresses
    if (!this.isWhitelistedAddress(params.bridgeAddress, 'bridge')) {
      return { valid: false, error: 'Invalid bridge address' };
    }
    
    if (!this.isWhitelistedAddress(params.tokenAddress, 'usdc')) {
      return { valid: false, error: 'Invalid token address' };
    }
    
    // Validate amount
    const amount = parseFloat(params.amount);
    const minAmount = parseFloat(config.minimumDepositAmount);
    const limits = this.getDepositRateLimits();
    const maxAmount = parseFloat(limits.maxAmountPerDeposit);
    
    if (isNaN(amount) || amount < minAmount) {
      return { valid: false, error: `Minimum deposit amount is ${minAmount} USDC` };
    }
    
    if (amount > maxAmount) {
      return { valid: false, error: `Maximum deposit amount is ${maxAmount} USDC` };
    }
    
    return { valid: true };
  }
}

export default ConfigurationService;
```

---

## File: server/services/cryptoPayout.ts

```typescript
import { ethers } from 'ethers';
import { db } from '../db';
import { tradingPlatforms, platformRevenueSummary, payoutRecords, moonpayTransactions } from '@shared/schema';
import { eq, and, gte, lte, desc, sql } from 'drizzle-orm';
import { builderFeeManager } from './builderFeeManager';

// Payout configuration
const PAYOUT_CONFIG = {
  // Use USDC on Arbitrum for low fees
  chainId: 42161, // Arbitrum One
  rpcUrl: process.env.ARBITRUM_RPC_URL || 'https://arb1.arbitrum.io/rpc',
  usdcAddress: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831', // USDC on Arbitrum
  minPayoutAmount: '10', // $10 minimum payout
  gasLimit: 100000,
};

export class CryptoPayoutService {
  private provider: ethers.Provider;
  private payoutWallet?: ethers.Wallet;
  private usdcContract?: ethers.Contract;

  constructor() {
    this.provider = new ethers.JsonRpcProvider(PAYOUT_CONFIG.rpcUrl);
    
    // Initialize payout wallet if private key is provided
    if (process.env.PAYOUT_WALLET_PRIVATE_KEY) {
      this.payoutWallet = new ethers.Wallet(process.env.PAYOUT_WALLET_PRIVATE_KEY, this.provider);
      
      // Initialize USDC contract
      const usdcAbi = [
        'function transfer(address to, uint256 amount) returns (bool)',
        'function balanceOf(address account) view returns (uint256)',
        'function decimals() view returns (uint8)',
      ];
      this.usdcContract = new ethers.Contract(PAYOUT_CONFIG.usdcAddress, usdcAbi, this.payoutWallet);
    }
  }

  /**
   * Process payouts for all eligible platforms
   */
  async processPayouts(period: 'weekly' | 'monthly' = 'weekly'): Promise<void> {
    if (!this.payoutWallet || !this.usdcContract) {
      console.error('Payout wallet not configured');
      return;
    }

    // Check payout readiness first
    const readiness = await builderFeeManager.checkPayoutReadiness(period);
    
    if (!readiness.readyToPayout) {
      console.error('Payouts not ready:', {
        unclaimedFees: `$${readiness.unclaimedFees}`,
        availableUSDC: `$${readiness.availableForPayout}`,
        requiredUSDC: `$${readiness.requiredForPayouts}`,
        message: 'Please claim builder fees and ensure sufficient USDC balance'
      });
      
      // Could trigger an alert or notification here
      await this.notifyPayoutIssue(readiness);
      return;
    }

    const endDate = new Date();
    const startDate = new Date();
    
    if (period === 'weekly') {
      startDate.setDate(startDate.getDate() - 7);
    } else {
      startDate.setMonth(startDate.getMonth() - 1);
    }

    // Get all platforms with revenue in the period
    const platformsWithRevenue = await db
      .select({
        summary: platformRevenueSummary,
        platform: tradingPlatforms,
      })
      .from(platformRevenueSummary)
      .innerJoin(tradingPlatforms, eq(platformRevenueSummary.platformId, tradingPlatforms.id))
      .where(
        and(
          gte(platformRevenueSummary.periodEnd, startDate),
          sql`${platformRevenueSummary.totalRevenue} > 0`
        )
      );

    console.log(`Processing payouts for ${platformsWithRevenue.length} platforms`);

    for (const { summary, platform } of platformsWithRevenue) {
      if (!platform.payoutWallet) {
        console.log(`Platform ${platform.id} has no payout wallet configured`);
        continue;
      }

      await this.processPlatformPayout(
        platform.id,
        platform.userId,
        platform.payoutWallet,
        summary.totalRevenue,
        startDate,
        endDate
      );
    }
  }

  /**
   * Process payout for a single platform
   */
  async processPlatformPayout(
    platformId: number,
    userId: number,
    payoutAddress: string,
    totalRevenue: string,
    startDate: Date,
    endDate: Date
  ): Promise<void> {
    try {
      // Validate address
      if (!ethers.isAddress(payoutAddress)) {
        console.error(`Invalid payout address for platform ${platformId}: ${payoutAddress}`);
        return;
      }

      // Calculate platform owner's share from trading fees (70%)
      const tradingRevenue = parseFloat(totalRevenue);
      const tradingFeesShare = tradingRevenue * 0.7;

      // Get MoonPay revenue for this platform and period
      const moonpayTransactions = await db
        .select()
        .from(moonpayTransactions)
        .where(
          and(
            eq(moonpayTransactions.platformId, platformId),
            eq(moonpayTransactions.status, 'completed'),
            gte(moonpayTransactions.createdAt, startDate),
            lte(moonpayTransactions.createdAt, endDate)
          )
        );

      // Calculate MoonPay earnings (platform gets 50% of affiliate fees)
      const moonpayEarnings = moonpayTransactions.reduce((sum, tx) => {
        return sum + parseFloat(tx.platformEarnings);
      }, 0);

      // Total payout = Trading fees share + MoonPay earnings
      const totalPayout = tradingFeesShare + moonpayEarnings;

      // Check minimum payout
      if (totalPayout < parseFloat(PAYOUT_CONFIG.minPayoutAmount)) {
        console.log(`Platform ${platformId} total earnings below minimum: $${totalPayout.toFixed(2)}`);
        return;
      }

      // Convert to USDC amount (6 decimals)
      const usdcAmount = ethers.parseUnits(totalPayout.toFixed(2), 6);

      // Check USDC balance
      const balance = await this.usdcContract!.balanceOf(this.payoutWallet!.address);
      if (balance < usdcAmount) {
        console.error('Insufficient USDC balance for payouts');
        return;
      }

      // Send USDC
      console.log(`Sending $${totalPayout.toFixed(2)} USDC to ${payoutAddress} (Trading: $${tradingFeesShare.toFixed(2)}, MoonPay: $${moonpayEarnings.toFixed(2)})`);
      const tx = await this.usdcContract!.transfer(payoutAddress, usdcAmount, {
        gasLimit: PAYOUT_CONFIG.gasLimit,
      });

      // Wait for confirmation
      const receipt = await tx.wait();

      // Record successful payout
      await db.insert(payoutRecords).values({
        platformId,
        userId,
        amount: totalPayout.toFixed(2),
        currency: 'USDC',
        status: 'completed',
        txHash: receipt.hash,
        chainId: PAYOUT_CONFIG.chainId,
        recipientAddress: payoutAddress,
        periodStart: startDate,
        periodEnd: endDate,
        processedAt: new Date(),
        notes: `Trading fees: $${tradingFeesShare.toFixed(2)}, MoonPay: $${moonpayEarnings.toFixed(2)}`,
      });

      console.log(`Payout completed for platform ${platformId}: ${receipt.hash}`);
    } catch (error) {
      console.error(`Error processing payout for platform ${platformId}:`, error);
      
      // Record failed payout
      await db.insert(payoutRecords).values({
        platformId,
        userId,
        amount: totalPayout.toFixed(2),
        currency: 'USDC',
        status: 'failed',
        error: error.message,
        recipientAddress: payoutAddress,
        periodStart: startDate,
        periodEnd: endDate,
        processedAt: new Date(),
        notes: `Trading fees: $${tradingFeesShare.toFixed(2)}, MoonPay: $${moonpayEarnings.toFixed(2)}`,
      });
    }
  }

  /**
   * Check pending payouts for a platform
   */
  async getPendingPayouts(platformId: number): Promise<{ amount: string; period: string }[]> {
    const summaries = await db
      .select()
      .from(platformRevenueSummary)
      .where(
        and(
          eq(platformRevenueSummary.platformId, platformId),
          sql`${platformRevenueSummary.totalRevenue} > 0`
        )
      );

    const payouts = await db
      .select()
      .from(payoutRecords)
      .where(eq(payoutRecords.platformId, platformId));

    const paidPeriods = new Set(
      payouts.map(p => `${p.periodStart.toISOString()}-${p.periodEnd.toISOString()}`)
    );

    return summaries
      .filter(s => !paidPeriods.has(`${s.periodStart.toISOString()}-${s.periodEnd.toISOString()}`))
      .map(s => ({
        amount: (parseFloat(s.totalRevenue) * 0.7).toFixed(2),
        period: s.period,
      }));
  }

  /**
   * Get payout history for a platform
   */
  async getPayoutHistory(platformId: number): Promise<any[]> {
    return await db
      .select()
      .from(payoutRecords)
      .where(eq(payoutRecords.platformId, platformId))
      .orderBy(sql`${payoutRecords.processedAt} DESC`);
  }

  /**
   * Verify a payout transaction on-chain
   */
  async verifyPayout(txHash: string): Promise<boolean> {
    try {
      const receipt = await this.provider.getTransactionReceipt(txHash);
      return receipt !== null && receipt.status === 1;
    } catch (error) {
      console.error('Error verifying payout:', error);
      return false;
    }
  }

  /**
   * Get the current USDC balance of the payout wallet
   */
  async getWalletBalance(): Promise<string> {
    if (!this.payoutWallet || !this.usdcContract) {
      console.error('Payout wallet not configured');
      return '0.00';
    }

    try {
      const balance = await this.usdcContract.balanceOf(this.payoutWallet.address);
      const decimals = await this.usdcContract.decimals();
      
      // Format balance with proper decimals (USDC has 6 decimals)
      const formattedBalance = ethers.formatUnits(balance, decimals);
      
      return parseFloat(formattedBalance).toFixed(2);
    } catch (error) {
      console.error('Error fetching wallet balance:', error);
      return '0.00';
    }
  }

  /**
   * Notify admin about payout issues
   */
  async notifyPayoutIssue(readiness: any): Promise<void> {
    // Log the issue for now - in production, this could send an email or webhook
    console.error('PAYOUT ISSUE ALERT:', {
      unclaimedFees: readiness.unclaimedFees,
      claimedNotConverted: readiness.claimedNotConverted,
      availableForPayout: readiness.availableForPayout,
      requiredForPayouts: readiness.requiredForPayouts,
      details: readiness.details
    });
    
    // TODO: Implement email notification via SendGrid or similar
    // This would send alerts to admin when payouts can't be processed
  }
}

export const cryptoPayout = new CryptoPayoutService();
```

---

## File: server/services/depositService.ts

```typescript
import { db } from "../db";
import { depositTransactions, users } from "@shared/schema";
import { eq, and, gte, sum, desc, sql } from "drizzle-orm";
import ConfigurationService from "./configService";
import { createAuditLog } from "../security/audit";
import type { InsertDepositTransaction } from "@shared/schema";

interface DepositRequest {
  userId: number;
  walletAddress: string;
  amount: string;
  bridgeAddress: string;
  tokenAddress: string;
  txHash?: string;
  ipAddress?: string;
  userAgent?: string;
}

interface DepositRateCheck {
  allowed: boolean;
  reason?: string;
  dailyCount?: number;
  hourlyCount?: number;
  dailyVolume?: string;
}

class DepositService {
  /**
   * Check rate limits for a user
   */
  static async checkDepositRateLimits(userId: number, amount: string): Promise<DepositRateCheck> {
    const limits = ConfigurationService.getDepositRateLimits();
    const now = new Date();
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);

    // Get recent deposits
    const [hourlyDeposits, dailyDeposits] = await Promise.all([
      db
        .select({ count: count() })
        .from(depositTransactions)
        .where(
          and(
            eq(depositTransactions.userId, userId),
            gte(depositTransactions.createdAt, oneHourAgo)
          )
        ),
      db
        .select({
          count: count(),
          totalAmount: sum(depositTransactions.amount),
        })
        .from(depositTransactions)
        .where(
          and(
            eq(depositTransactions.userId, userId),
            gte(depositTransactions.createdAt, oneDayAgo)
          )
        ),
    ]);

    const hourlyCount = hourlyDeposits[0]?.count || 0;
    const dailyCount = dailyDeposits[0]?.count || 0;
    const dailyVolume = dailyDeposits[0]?.totalAmount || "0";

    // Check hourly limit
    if (hourlyCount >= limits.maxDepositsPerHour) {
      return {
        allowed: false,
        reason: `You've reached the hourly deposit limit (${limits.maxDepositsPerHour} deposits per hour)`,
        hourlyCount,
        dailyCount,
        dailyVolume,
      };
    }

    // Check daily limit
    if (dailyCount >= limits.maxDepositsPerDay) {
      return {
        allowed: false,
        reason: `You've reached the daily deposit limit (${limits.maxDepositsPerDay} deposits per day)`,
        hourlyCount,
        dailyCount,
        dailyVolume,
      };
    }

    // Check daily volume
    const totalWithNewDeposit = parseFloat(dailyVolume) + parseFloat(amount);
    if (totalWithNewDeposit > parseFloat(limits.maxDailyVolume)) {
      return {
        allowed: false,
        reason: `This deposit would exceed your daily volume limit ($${limits.maxDailyVolume} USDC)`,
        hourlyCount,
        dailyCount,
        dailyVolume,
      };
    }

    return {
      allowed: true,
      hourlyCount,
      dailyCount,
      dailyVolume,
    };
  }

  /**
   * Record a new deposit transaction
   */
  static async recordDeposit(request: DepositRequest): Promise<{ success: boolean; error?: string; depositId?: number }> {
    try {
      // Validate contract addresses
      const validation = ConfigurationService.validateDepositParams({
        amount: request.amount,
        bridgeAddress: request.bridgeAddress,
        tokenAddress: request.tokenAddress,
      });

      if (!validation.valid) {
        await createAuditLog({
          platformId: 0, // Deposit not tied to specific platform
          userId: request.userId,
          action: 'deposit_validation_failed',
          details: {
            error: validation.error,
            bridgeAddress: request.bridgeAddress,
            tokenAddress: request.tokenAddress,
          },
          ipAddress: request.ipAddress,
        });
        return { success: false, error: validation.error };
      }

      // Check rate limits
      const rateCheck = await this.checkDepositRateLimits(request.userId, request.amount);
      if (!rateCheck.allowed) {
        await createAuditLog({
          platformId: 0, // Deposit not tied to specific platform
          userId: request.userId,
          action: 'deposit_rate_limited',
          details: {
            reason: rateCheck.reason,
            hourlyCount: rateCheck.hourlyCount,
            dailyCount: rateCheck.dailyCount,
            dailyVolume: rateCheck.dailyVolume,
          },
          ipAddress: request.ipAddress,
        });
        return { success: false, error: rateCheck.reason };
      }

      // Create deposit record
      const deposit: InsertDepositTransaction = {
        userId: request.userId,
        walletAddress: request.walletAddress,
        amount: request.amount,
        currency: 'USDC',
        fromNetwork: 'arbitrum',
        toNetwork: 'hyperliquid',
        txHash: request.txHash,
        status: 'pending',
        bridgeAddress: request.bridgeAddress,
        ipAddress: request.ipAddress,
        userAgent: request.userAgent,
        metadata: {
          tokenAddress: request.tokenAddress,
          timestamp: new Date().toISOString(),
        },
      };

      const [result] = await db.insert(depositTransactions).values(deposit).returning();

      // Log successful deposit
      await createAuditLog({
        platformId: 0, // Deposit not tied to specific platform
        userId: request.userId,
        action: 'deposit_initiated',
        details: {
          depositId: result.id,
          amount: request.amount,
          walletAddress: request.walletAddress,
          txHash: request.txHash,
        },
        ipAddress: request.ipAddress,
      });

      return { success: true, depositId: result.id };
    } catch (error) {
      console.error('Deposit recording error:', error);
      return { success: false, error: 'Failed to record deposit' };
    }
  }

  /**
   * Get recent deposits for a user
   */
  static async getUserDeposits(userId: number, limit: number = 10) {
    return await db
      .select()
      .from(depositTransactions)
      .where(eq(depositTransactions.userId, userId))
      .orderBy(desc(depositTransactions.createdAt))
      .limit(limit);
  }

  /**
   * Update deposit status (for webhook processing)
   */
  static async updateDepositStatus(depositId: number, status: 'confirmed' | 'failed', txHash?: string) {
    const updates: any = { status };
    if (status === 'confirmed') {
      updates.confirmedAt = new Date();
    }
    if (txHash) {
      updates.txHash = txHash;
    }

    await db
      .update(depositTransactions)
      .set(updates)
      .where(eq(depositTransactions.id, depositId));

    // Log status update
    const [deposit] = await db
      .select()
      .from(depositTransactions)
      .where(eq(depositTransactions.id, depositId));

    if (deposit) {
      await createAuditLog({
        platformId: 0, // Deposit not tied to specific platform
        userId: deposit.userId,
        action: `deposit_${status}`,
        details: {
          depositId,
          amount: deposit.amount,
          txHash: deposit.txHash,
        },
      });
    }
  }

  /**
   * Get deposit statistics for monitoring
   */
  static async getDepositStats(timeframe: 'hour' | 'day' | 'week' = 'day') {
    const now = new Date();
    const startTime = new Date(now);
    
    switch (timeframe) {
      case 'hour':
        startTime.setHours(now.getHours() - 1);
        break;
      case 'day':
        startTime.setDate(now.getDate() - 1);
        break;
      case 'week':
        startTime.setDate(now.getDate() - 7);
        break;
    }

    const stats = await db
      .select({
        totalDeposits: count(),
        totalVolume: sum(depositTransactions.amount),
        uniqueUsers: countDistinct(depositTransactions.userId),
        pendingCount: sql<number>`cast(sum(case when ${depositTransactions.status} = 'pending' then 1 else 0 end) as int)`,
        confirmedCount: sql<number>`cast(sum(case when ${depositTransactions.status} = 'confirmed' then 1 else 0 end) as int)`,
        failedCount: sql<number>`cast(sum(case when ${depositTransactions.status} = 'failed' then 1 else 0 end) as int)`,
      })
      .from(depositTransactions)
      .where(gte(depositTransactions.createdAt, startTime));

    return stats[0];
  }
}

import { sql } from "drizzle-orm";

// Fix for Drizzle count function
function count() {
  return sql<number>`cast(count(*) as int)`;
}

function countDistinct(column: any) {
  return sql<number>`cast(count(distinct ${column}) as int)`;
}

export default DepositService;
```

---

## File: server/services/domainManager.ts

```typescript
import { db } from '../db';
import { platformDomains, tradingPlatforms } from '@shared/schema';
import { eq, and } from 'drizzle-orm';
import { createAuditLog } from '../security/audit';
import crypto from 'crypto';

export class DomainManager {
  /**
   * Generate a verification token for domain ownership
   */
  generateVerificationToken(): string {
    return `liquidlab-verify-${crypto.randomBytes(16).toString('hex')}`;
  }

  /**
   * Add a custom domain to a platform
   */
  async addCustomDomain(platformId: number, domain: string): Promise<{
    success: boolean;
    verificationToken?: string;
    error?: string;
  }> {
    try {
      // Validate domain format
      if (!this.isValidDomain(domain)) {
        return { success: false, error: 'Invalid domain format' };
      }

      // Check if domain is already in use
      const existingDomain = await db
        .select()
        .from(platformDomains)
        .where(eq(platformDomains.domain, domain))
        .limit(1);

      if (existingDomain.length > 0) {
        return { success: false, error: 'Domain is already in use' };
      }

      // Generate verification token
      const verificationToken = this.generateVerificationToken();

      // Create domain record
      await db.insert(platformDomains).values({
        platformId,
        domain,
        verificationToken,
        isVerified: false
      });

      await createAuditLog({
        platformId,
        action: 'custom_domain_added',
        resource: 'platform_domain',
        metadata: { domain }
      });

      return {
        success: true,
        verificationToken
      };
    } catch (error) {
      console.error('Error adding custom domain:', error);
      return { success: false, error: 'Failed to add domain' };
    }
  }

  /**
   * Verify domain ownership via DNS TXT record
   */
  async verifyDomain(platformId: number, domain: string): Promise<{
    verified: boolean;
    error?: string;
  }> {
    try {
      // Get domain record
      const [domainRecord] = await db
        .select()
        .from(platformDomains)
        .where(and(
          eq(platformDomains.platformId, platformId),
          eq(platformDomains.domain, domain)
        ));

      if (!domainRecord) {
        return { verified: false, error: 'Domain not found' };
      }

      // In production, you would check DNS TXT records here
      // For now, we'll simulate verification
      const isVerified = await this.checkDNSVerification(
        domain,
        domainRecord.verificationToken!
      );

      if (isVerified) {
        // Update domain status
        await db
          .update(platformDomains)
          .set({
            isVerified: true,
            verifiedAt: new Date()
          })
          .where(eq(platformDomains.id, domainRecord.id));

        await createAuditLog({
          platformId,
          action: 'custom_domain_verified',
          resource: 'platform_domain',
          metadata: { domain }
        });

        return { verified: true };
      }

      return { verified: false, error: 'DNS verification not found' };
    } catch (error) {
      console.error('Error verifying domain:', error);
      return { verified: false, error: 'Verification failed' };
    }
  }

  /**
   * Remove a custom domain
   */
  async removeDomain(platformId: number, domain: string): Promise<boolean> {
    try {
      await db
        .delete(platformDomains)
        .where(and(
          eq(platformDomains.platformId, platformId),
          eq(platformDomains.domain, domain)
        ));

      await createAuditLog({
        platformId,
        action: 'custom_domain_removed',
        resource: 'platform_domain',
        metadata: { domain }
      });

      return true;
    } catch (error) {
      console.error('Error removing domain:', error);
      return false;
    }
  }

  /**
   * Get platform by custom domain
   */
  async getPlatformByDomain(domain: string): Promise<number | null> {
    try {
      const [result] = await db
        .select({ platformId: platformDomains.platformId })
        .from(platformDomains)
        .where(and(
          eq(platformDomains.domain, domain),
          eq(platformDomains.isVerified, true)
        ));

      return result?.platformId || null;
    } catch (error) {
      console.error('Error getting platform by domain:', error);
      return null;
    }
  }

  /**
   * Get all domains for a platform
   */
  async getPlatformDomains(platformId: number) {
    return await db
      .select()
      .from(platformDomains)
      .where(eq(platformDomains.platformId, platformId));
  }

  /**
   * Validate domain format
   */
  private isValidDomain(domain: string): boolean {
    const domainRegex = /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i;
    return domainRegex.test(domain);
  }

  /**
   * Check DNS TXT record for verification
   * In production, this would use a DNS resolver
   */
  private async checkDNSVerification(domain: string, token: string): Promise<boolean> {
    // TODO: Implement actual DNS lookup
    // For now, return false to simulate pending verification
    console.log(`Would check TXT record _liquidlab.${domain} for token: ${token}`);
    return false;
  }
}

export const domainManager = new DomainManager();
```

---

## File: server/services/emailService.ts

```typescript
import sgMail from '@sendgrid/mail';
import { TradingPlatform, User, PayoutRecord, MoonpayTransaction } from '@shared/schema';
import { db } from '../db';
import { eq } from 'drizzle-orm';
import { users, tradingPlatforms } from '@shared/schema';

// Initialize SendGrid
if (process.env.SENDGRID_API_KEY) {
  sgMail.setApiKey(process.env.SENDGRID_API_KEY);
}

export interface EmailParams {
  to: string;
  from?: string;
  subject: string;
  text?: string;
  html?: string;
}

const DEFAULT_FROM_EMAIL = 'notifications@liquidlab.trade';
const DEFAULT_FROM_NAME = 'LiquidLab';

class EmailService {
  private isConfigured: boolean;

  constructor() {
    this.isConfigured = !!process.env.SENDGRID_API_KEY;
  }

  private async sendEmail(params: EmailParams): Promise<boolean> {
    if (!this.isConfigured) {
      console.log('SendGrid not configured. Email would have been sent:', params);
      return false;
    }

    try {
      await sgMail.send({
        to: params.to,
        from: params.from || {
          email: DEFAULT_FROM_EMAIL,
          name: DEFAULT_FROM_NAME
        },
        subject: params.subject,
        text: params.text,
        html: params.html || params.text,
      });
      return true;
    } catch (error) {
      console.error('SendGrid email error:', error);
      return false;
    }
  }

  // Welcome email when user creates account
  async sendWelcomeEmail(user: User): Promise<boolean> {
    if (!user.email) return false;

    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1 style="color: #0066ff;">Welcome to LiquidLab! 🚀</h1>
        <p>Hi ${user.username || 'there'},</p>
        <p>Thank you for joining LiquidLab, the premier platform for building custom trading interfaces on Hyperliquid DEX.</p>
        
        <h2>Getting Started</h2>
        <ul>
          <li>Build your first trading platform with our drag-and-drop builder</li>
          <li>Earn 70% of all trading fees from your platforms</li>
          <li>Get 50% of MoonPay affiliate commissions</li>
          <li>Deploy with custom domains for your brand</li>
        </ul>
        
        <p>Ready to start building?</p>
        <a href="https://liquidlab.trade/builder" style="display: inline-block; background: #0066ff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 16px 0;">Create Your First Platform</a>
        
        <p>If you have any questions, feel free to reach out to our support team.</p>
        
        <p>Best regards,<br>The LiquidLab Team</p>
      </div>
    `;

    return this.sendEmail({
      to: user.email,
      subject: 'Welcome to LiquidLab - Start Building Trading Platforms',
      html
    });
  }

  // Platform created notification
  async sendPlatformCreatedEmail(platform: TradingPlatform, owner: User): Promise<boolean> {
    if (!owner.email) return false;

    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1 style="color: #0066ff;">Platform Created Successfully! 🎉</h1>
        <p>Hi ${owner.username || 'there'},</p>
        <p>Your trading platform "<strong>${platform.name}</strong>" has been created successfully!</p>
        
        <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
          <h3 style="margin-top: 0;">Platform Details</h3>
          <p><strong>Platform ID:</strong> #${platform.id}</p>
          <p><strong>Builder Wallet:</strong> Configured automatically</p>
          <p><strong>Revenue Share:</strong> You earn 70% of all trading fees</p>
          <p><strong>MoonPay Commission:</strong> You earn 50% of affiliate fees</p>
        </div>
        
        <h2>Next Steps</h2>
        <ol>
          <li>Share your platform link with traders</li>
          <li>Consider adding a custom domain for professional branding</li>
          <li>Monitor your earnings in the dashboard</li>
        </ol>
        
        <a href="https://liquidlab.trade/dashboard" style="display: inline-block; background: #0066ff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 16px 0;">View Dashboard</a>
        
        <p>Best regards,<br>The LiquidLab Team</p>
      </div>
    `;

    return this.sendEmail({
      to: owner.email,
      subject: `Platform "${platform.name}" Created Successfully`,
      html
    });
  }

  // Payout processed notification
  async sendPayoutProcessedEmail(
    payout: PayoutRecord, 
    platform: TradingPlatform, 
    owner: User,
    tradingFees: string,
    moonpayFees: string
  ): Promise<boolean> {
    if (!owner.email) return false;

    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1 style="color: #0066ff;">Payout Processed! 💰</h1>
        <p>Hi ${owner.username || 'there'},</p>
        <p>We've sent your earnings to your wallet!</p>
        
        <div style="background: #f0f8ff; padding: 20px; border-radius: 8px; margin: 20px 0;">
          <h3 style="margin-top: 0; color: #0066ff;">Payout Details</h3>
          <p><strong>Amount:</strong> ${payout.amount} USDC</p>
          <p><strong>Platform:</strong> ${platform.name}</p>
          <p><strong>Period:</strong> ${payout.period}</p>
          
          <hr style="border: 0; border-top: 1px solid #ddd; margin: 16px 0;">
          
          <p><strong>Breakdown:</strong></p>
          <ul style="margin: 8px 0;">
            <li>Trading Fees (70%): $${tradingFees}</li>
            <li>MoonPay Commissions (50%): $${moonpayFees}</li>
          </ul>
          
          <p><strong>Transaction Hash:</strong><br>
          <a href="https://arbiscan.io/tx/${payout.txHash}" style="color: #0066ff; word-break: break-all;">${payout.txHash}</a></p>
        </div>
        
        <p>The USDC has been sent to your wallet on Arbitrum. It should arrive within a few minutes.</p>
        
        <a href="https://liquidlab.trade/dashboard/payouts" style="display: inline-block; background: #0066ff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 16px 0;">View Payout History</a>
        
        <p>Thank you for being part of LiquidLab!</p>
        
        <p>Best regards,<br>The LiquidLab Team</p>
      </div>
    `;

    return this.sendEmail({
      to: owner.email,
      subject: `Payout Processed: ${payout.amount} USDC`,
      html
    });
  }

  // Weekly revenue summary
  async sendWeeklyRevenueSummary(
    owner: User,
    platforms: TradingPlatform[],
    weeklyStats: {
      totalTradingFees: string;
      totalMoonpayFees: string;
      totalEarnings: string;
      tradeCount: number;
      moonpayPurchases: number;
    }
  ): Promise<boolean> {
    if (!owner.email) return false;

    const platformList = platforms.map(p => 
      `<li>${p.name} - ID: #${p.id}</li>`
    ).join('');

    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1 style="color: #0066ff;">Weekly Revenue Report 📊</h1>
        <p>Hi ${owner.username || 'there'},</p>
        <p>Here's your weekly earnings summary for LiquidLab:</p>
        
        <div style="background: #f0f8ff; padding: 20px; border-radius: 8px; margin: 20px 0;">
          <h2 style="margin-top: 0; color: #0066ff;">Total Earnings: $${weeklyStats.totalEarnings}</h2>
          
          <div style="display: flex; gap: 20px; margin: 20px 0;">
            <div style="flex: 1;">
              <h4 style="margin: 0; color: #666;">Trading Fees</h4>
              <p style="font-size: 24px; margin: 8px 0; color: #0066ff;">$${weeklyStats.totalTradingFees}</p>
              <p style="margin: 0; color: #666; font-size: 14px;">${weeklyStats.tradeCount} trades</p>
            </div>
            
            <div style="flex: 1;">
              <h4 style="margin: 0; color: #666;">MoonPay Commissions</h4>
              <p style="font-size: 24px; margin: 8px 0; color: #0066ff;">$${weeklyStats.totalMoonpayFees}</p>
              <p style="margin: 0; color: #666; font-size: 14px;">${weeklyStats.moonpayPurchases} purchases</p>
            </div>
          </div>
        </div>
        
        <h3>Your Active Platforms</h3>
        <ul>${platformList}</ul>
        
        <p>Payouts are processed weekly on Mondays. If your balance exceeds $10, you'll receive USDC on Arbitrum.</p>
        
        <a href="https://liquidlab.trade/dashboard" style="display: inline-block; background: #0066ff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 16px 0;">View Full Dashboard</a>
        
        <p>Keep growing your platforms!</p>
        
        <p>Best regards,<br>The LiquidLab Team</p>
      </div>
    `;

    return this.sendEmail({
      to: owner.email,
      subject: `Weekly Revenue Report: $${weeklyStats.totalEarnings} earned`,
      html
    });
  }

  // Platform verification status change
  async sendPlatformVerificationEmail(
    platform: TradingPlatform, 
    owner: User, 
    verified: boolean
  ): Promise<boolean> {
    if (!owner.email) return false;

    const statusText = verified ? 'Verified' : 'Verification Pending';
    const statusColor = verified ? '#00cc66' : '#ff9900';

    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1 style="color: ${statusColor};">Platform ${statusText} ✓</h1>
        <p>Hi ${owner.username || 'there'},</p>
        
        ${verified ? `
          <p>Great news! Your platform "<strong>${platform.name}</strong>" has been verified by LiquidLab.</p>
          
          <div style="background: #f0fff0; padding: 20px; border-radius: 8px; margin: 20px 0; border: 1px solid #00cc66;">
            <h3 style="margin-top: 0; color: #00cc66;">✓ Verification Complete</h3>
            <p>Your platform now displays the official verification badge, giving traders confidence in your platform's legitimacy.</p>
          </div>
        ` : `
          <p>Your platform "<strong>${platform.name}</strong>" is currently under review for verification.</p>
          
          <div style="background: #fffaf0; padding: 20px; border-radius: 8px; margin: 20px 0; border: 1px solid #ff9900;">
            <h3 style="margin-top: 0; color: #ff9900;">⏳ Verification In Progress</h3>
            <p>We're reviewing your platform to ensure it meets our quality standards. This usually takes 24-48 hours.</p>
          </div>
        `}
        
        <a href="https://liquidlab.trade/dashboard" style="display: inline-block; background: #0066ff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 16px 0;">View Platform Status</a>
        
        <p>Best regards,<br>The LiquidLab Team</p>
      </div>
    `;

    return this.sendEmail({
      to: owner.email,
      subject: `Platform ${statusText}: ${platform.name}`,
      html
    });
  }

  // Domain verification reminder
  async sendDomainVerificationReminder(
    platform: TradingPlatform, 
    owner: User,
    domain: string,
    verificationToken: string
  ): Promise<boolean> {
    if (!owner.email) return false;

    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1 style="color: #0066ff;">Complete Your Domain Setup 🌐</h1>
        <p>Hi ${owner.username || 'there'},</p>
        <p>You've added the domain <strong>${domain}</strong> to your platform "${platform.name}", but it needs verification.</p>
        
        <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
          <h3 style="margin-top: 0;">DNS Verification Required</h3>
          <p>Add this TXT record to your domain's DNS settings:</p>
          
          <div style="background: white; padding: 16px; border-radius: 4px; font-family: monospace; margin: 16px 0;">
            <strong>Type:</strong> TXT<br>
            <strong>Name:</strong> _liquidlab<br>
            <strong>Value:</strong> ${verificationToken}
          </div>
          
          <p>Once added, DNS changes can take up to 48 hours to propagate.</p>
        </div>
        
        <a href="https://liquidlab.trade/builder" style="display: inline-block; background: #0066ff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 16px 0;">Verify Domain</a>
        
        <p>Need help? Check our <a href="https://liquidlab.trade/docs/custom-domains" style="color: #0066ff;">custom domain guide</a>.</p>
        
        <p>Best regards,<br>The LiquidLab Team</p>
      </div>
    `;

    return this.sendEmail({
      to: owner.email,
      subject: `Action Required: Verify domain ${domain}`,
      html
    });
  }

  // Test email functionality
  async sendTestEmail(to: string): Promise<boolean> {
    return this.sendEmail({
      to,
      subject: 'LiquidLab Email Test',
      text: 'This is a test email from LiquidLab. If you received this, email notifications are working correctly!',
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h1 style="color: #0066ff;">Email Test Successful! ✅</h1>
          <p>This is a test email from LiquidLab.</p>
          <p>If you received this, email notifications are working correctly!</p>
          <p>Best regards,<br>The LiquidLab Team</p>
        </div>
      `
    });
  }
}

export const emailService = new EmailService();
```

---

## File: server/services/hyperliquid.ts

```typescript
export class HyperliquidService {
  private readonly baseUrl = "https://api.hyperliquid.xyz";

  async getMarketData(symbol?: string) {
    try {
      const response = await fetch(`${this.baseUrl}/info`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          type: "allMids",
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      if (symbol) {
        return data[symbol] || null;
      }
      
      return data;
    } catch (error) {
      console.error("Error fetching market data:", error);
      throw error;
    }
  }

  async getOrderbook(symbol: string) {
    try {
      const response = await fetch(`${this.baseUrl}/info`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          type: "l2Book",
          coin: symbol,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Error fetching orderbook:", error);
      throw error;
    }
  }

  async getUserState(address: string) {
    try {
      const response = await fetch(`${this.baseUrl}/info`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          type: "userState",
          user: address,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Error fetching user state:", error);
      throw error;
    }
  }

  async placeOrder(orderRequest: any) {
    try {
      const response = await fetch(`${this.baseUrl}/exchange`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(orderRequest),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error("Hyperliquid error response:", errorText);
        throw new Error(`Order failed: ${errorText}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Error placing order:", error);
      throw error;
    }
  }

  async getUserPositions(address: string) {
    try {
      const response = await fetch(`${this.baseUrl}/info`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          type: "clearinghouseState",
          user: address,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Error fetching user positions:", error);
      throw error;
    }
  }

  async getRecentTradesForBuilder(builderCode: string, startTime?: number) {
    try {
      // Hyperliquid API doesn't have a direct endpoint for builder code trades
      // We'll need to fetch all recent trades and filter by builder code
      // This is a simplified approach - in production, you might need WebSocket or more efficient methods
      
      const response = await fetch(`${this.baseUrl}/info`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          type: "recentTrades",
          coin: "BTC", // We'll need to fetch for all coins
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const trades = await response.json();
      
      // Filter trades by builder code if they contain that information
      // Note: This is a placeholder - actual implementation depends on Hyperliquid's API structure
      return trades.filter((trade: any) => 
        trade.builderCode === builderCode && 
        (!startTime || trade.time > startTime)
      );
    } catch (error) {
      console.error("Error fetching builder trades:", error);
      throw error;
    }
  }

  async getUserFills(address: string, startTime?: number) {
    try {
      const response = await fetch(`${this.baseUrl}/info`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          type: "userFills",
          user: address,
          startTime: startTime || 0,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Error fetching user fills:", error);
      throw error;
    }
  }

  async getUserTradesWithCode(address: string, builderCode: string, startTime?: number) {
    try {
      // Fetch user's recent fills/trades
      const fills = await this.getUserFills(address, startTime);
      
      // Filter by builder code if the field exists
      // Note: The actual field name depends on Hyperliquid's API response structure
      return fills.filter((fill: any) => 
        fill.builderCode === builderCode || 
        fill.cloid?.includes(builderCode) ||
        fill.oid?.includes(builderCode)
      );
    } catch (error) {
      console.error("Error fetching user trades with code:", error);
      throw error;
    }
  }

  async getUserOpenOrders(address: string) {
    try {
      const response = await fetch(`${this.baseUrl}/info`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          type: "openOrders",
          user: address,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Error fetching open orders:", error);
      throw error;
    }
  }

  async getCandleData(symbol: string, interval: string = "1m", startTime?: number, endTime?: number) {
    try {
      const response = await fetch(`${this.baseUrl}/info`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          type: "candleSnapshot",
          req: {
            coin: symbol,
            interval,
            startTime,
            endTime,
          },
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Error fetching candle data:", error);
      throw error;
    }
  }

  async getMetaAndAssetCtxs() {
    try {
      const response = await fetch(`${this.baseUrl}/info`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          type: "metaAndAssetCtxs",
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Error fetching meta and asset contexts:", error);
      throw error;
    }
  }

  async getSpotMeta() {
    try {
      const response = await fetch(`${this.baseUrl}/info`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          type: "spotMeta",
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Error fetching spot meta:", error);
      throw error;
    }
  }

  async getSpotMetaAndAssetCtxs() {
    try {
      const response = await fetch(`${this.baseUrl}/info`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          type: "spotMetaAndAssetCtxs",
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Error fetching spot meta and asset contexts:", error);
      throw error;
    }
  }

  async getSpotClearinghouseState(userAddress: string) {
    try {
      const response = await fetch(`${this.baseUrl}/info`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          type: "spotClearinghouseState",
          user: userAddress,
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("Error fetching spot clearinghouse state:", error);
      throw error;
    }
  }
}

```

---

## File: server/services/notifications.ts

```typescript
import sgMail from '@sendgrid/mail';
import { TradingPlatform, User } from '@shared/schema';

// Initialize SendGrid with API key
if (process.env.SENDGRID_API_KEY) {
  sgMail.setApiKey(process.env.SENDGRID_API_KEY);
}

export async function sendPlatformApprovalNotification(
  platform: TradingPlatform,
  user: User
): Promise<void> {
  if (!process.env.SENDGRID_API_KEY) {
    console.warn('SendGrid API key not configured, skipping email notification');
    return;
  }

  try {
    const msg = {
      to: 'admin@liquidlab.trade',
      from: 'noreply@liquidlab.trade',
      subject: `New Platform Awaiting Approval: ${platform.name}`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #090909;">New Platform Approval Request</h2>
          
          <p>A new trading platform has been created and is awaiting your approval:</p>
          
          <div style="background-color: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="margin-top: 0;">Platform Details</h3>
            <p><strong>Platform Name:</strong> ${platform.name}</p>
            <p><strong>Platform ID:</strong> ${platform.id}</p>
            <p><strong>Created By:</strong> ${user.username} (${user.email})</p>
            <p><strong>Created At:</strong> ${new Date(platform.createdAt).toLocaleString()}</p>
            ${platform.customDomain ? `<p><strong>Custom Domain:</strong> ${platform.customDomain}</p>` : ''}
          </div>
          
          <div style="background-color: #e8f5e9; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="margin-top: 0;">Action Required</h3>
            <p>Please review this platform and take one of the following actions:</p>
            <ul>
              <li><strong>Approve:</strong> Allow the platform to go live and accept real trades</li>
              <li><strong>Reject:</strong> Block the platform with a reason for rejection</li>
            </ul>
            
            <p>You can manage platform approvals in the admin dashboard:</p>
            <a href="https://liquidlab.trade/admin/dashboard" style="display: inline-block; background-color: #1dd1a1; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; margin-top: 10px;">Review Platform</a>
          </div>
          
          <div style="background-color: #fff3e0; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="margin-top: 0;">Security Reminder</h3>
            <p>Before approving, please check for:</p>
            <ul>
              <li>Suspicious platform names or descriptions</li>
              <li>Known scam patterns or misleading content</li>
              <li>Proper platform configuration and setup</li>
            </ul>
          </div>
          
          <hr style="border: none; border-top: 1px solid #ddd; margin: 30px 0;">
          
          <p style="color: #666; font-size: 14px;">
            This is an automated notification from LiquidLab Platform Management System.
          </p>
        </div>
      `,
      text: `
        New Platform Approval Request
        
        A new trading platform has been created and is awaiting your approval:
        
        Platform Name: ${platform.name}
        Platform ID: ${platform.id}
        Created By: ${user.username} (${user.email})
        Created At: ${new Date(platform.createdAt).toLocaleString()}
        ${platform.customDomain ? `Custom Domain: ${platform.customDomain}` : ''}
        
        Please review this platform in the admin dashboard at:
        https://liquidlab.trade/admin/dashboard
        
        You can approve or reject the platform with appropriate notes.
      `
    };

    await sgMail.send(msg);
    console.log(`Platform approval notification sent for platform ${platform.id}`);
  } catch (error) {
    console.error('Error sending platform approval notification:', error);
    // Don't throw error to prevent platform creation from failing
  }
}

export async function sendPlatformApprovedNotification(
  platform: TradingPlatform,
  user: User
): Promise<void> {
  if (!process.env.SENDGRID_API_KEY) {
    console.warn('SendGrid API key not configured, skipping email notification');
    return;
  }

  try {
    const msg = {
      to: user.email,
      from: 'noreply@liquidlab.trade',
      subject: `Your Platform "${platform.name}" Has Been Approved!`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #090909;">Platform Approved! 🎉</h2>
          
          <p>Great news! Your trading platform has been approved and is now ready to go live.</p>
          
          <div style="background-color: #e8f5e9; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="margin-top: 0;">Platform Details</h3>
            <p><strong>Platform Name:</strong> ${platform.name}</p>
            <p><strong>Platform URL:</strong> https://${platform.slug}.liquidlab.trade</p>
            ${platform.customDomain ? `<p><strong>Custom Domain:</strong> ${platform.customDomain}</p>` : ''}
            <p><strong>Approved On:</strong> ${new Date(platform.approvalDate || Date.now()).toLocaleString()}</p>
          </div>
          
          <div style="background-color: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="margin-top: 0;">Next Steps</h3>
            <ol>
              <li><strong>Verify Your Platform:</strong> Complete the verification process to display the trust badge</li>
              <li><strong>Configure Settings:</strong> Fine-tune your platform settings in the builder</li>
              <li><strong>Share Your Platform:</strong> Start promoting your platform to traders</li>
              <li><strong>Monitor Performance:</strong> Track your revenue and platform metrics in the dashboard</li>
            </ol>
            
            <a href="https://liquidlab.trade/dashboard" style="display: inline-block; background-color: #1dd1a1; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; margin-top: 10px;">Go to Dashboard</a>
          </div>
          
          ${platform.approvalNotes ? `
          <div style="background-color: #e3f2fd; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="margin-top: 0;">Admin Notes</h3>
            <p>${platform.approvalNotes}</p>
          </div>
          ` : ''}
          
          <hr style="border: none; border-top: 1px solid #ddd; margin: 30px 0;">
          
          <p style="color: #666; font-size: 14px;">
            If you have any questions, please contact our support team.
          </p>
        </div>
      `,
      text: `
        Platform Approved!
        
        Great news! Your trading platform "${platform.name}" has been approved and is now ready to go live.
        
        Platform URL: https://${platform.slug}.liquidlab.trade
        ${platform.customDomain ? `Custom Domain: ${platform.customDomain}` : ''}
        Approved On: ${new Date(platform.approvalDate || Date.now()).toLocaleString()}
        
        ${platform.approvalNotes ? `Admin Notes: ${platform.approvalNotes}` : ''}
        
        Next Steps:
        1. Verify your platform to display the trust badge
        2. Configure your platform settings in the builder
        3. Start promoting your platform to traders
        4. Monitor your revenue in the dashboard
        
        Go to your dashboard: https://liquidlab.trade/dashboard
      `
    };

    await sgMail.send(msg);
    console.log(`Platform approved notification sent for platform ${platform.id}`);
  } catch (error) {
    console.error('Error sending platform approved notification:', error);
  }
}

export async function sendPlatformRejectedNotification(
  platform: TradingPlatform,
  user: User
): Promise<void> {
  if (!process.env.SENDGRID_API_KEY) {
    console.warn('SendGrid API key not configured, skipping email notification');
    return;
  }

  try {
    const msg = {
      to: user.email,
      from: 'noreply@liquidlab.trade',
      subject: `Platform "${platform.name}" Requires Changes`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #090909;">Platform Review Update</h2>
          
          <p>Thank you for submitting your platform. After review, we need you to make some changes before it can be approved.</p>
          
          <div style="background-color: #ffebee; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="margin-top: 0;">Reason for Changes Required</h3>
            <p>${platform.rejectionReason}</p>
          </div>
          
          <div style="background-color: #f5f5f5; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="margin-top: 0;">What to Do Next</h3>
            <ol>
              <li><strong>Review the Feedback:</strong> Carefully read the reason provided above</li>
              <li><strong>Make Changes:</strong> Update your platform to address the issues</li>
              <li><strong>Resubmit:</strong> Save your changes and we'll review again</li>
            </ol>
            
            <a href="https://liquidlab.trade/builder" style="display: inline-block; background-color: #1dd1a1; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; margin-top: 10px;">Edit Platform</a>
          </div>
          
          <div style="background-color: #e3f2fd; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="margin-top: 0;">Common Issues</h3>
            <ul>
              <li>Misleading platform names or descriptions</li>
              <li>Missing or unclear platform information</li>
              <li>Violation of our terms of service</li>
              <li>Suspicious or potentially harmful content</li>
            </ul>
          </div>
          
          <hr style="border: none; border-top: 1px solid #ddd; margin: 30px 0;">
          
          <p style="color: #666; font-size: 14px;">
            If you believe this decision was made in error or need clarification, please contact our support team.
          </p>
        </div>
      `,
      text: `
        Platform Review Update
        
        Thank you for submitting your platform "${platform.name}". After review, we need you to make some changes before it can be approved.
        
        Reason for Changes Required:
        ${platform.rejectionReason}
        
        What to Do Next:
        1. Review the feedback carefully
        2. Make the necessary changes to your platform
        3. Save your changes and we'll review again
        
        Edit your platform: https://liquidlab.trade/builder
        
        If you believe this decision was made in error or need clarification, please contact our support team.
      `
    };

    await sgMail.send(msg);
    console.log(`Platform rejected notification sent for platform ${platform.id}`);
  } catch (error) {
    console.error('Error sending platform rejected notification:', error);
  }
}
```

---

## File: server/services/scheduler.ts

```typescript
import { tradeBatchProcessor } from './tradeBatchProcessor';
import { createAuditLog } from '../security/audit';
import { VerificationService } from './verification';

export class Scheduler {
  private intervals: Map<string, NodeJS.Timeout> = new Map();
  
  /**
   * Schedule a job to run at specified intervals
   */
  private scheduleJob(name: string, intervalMs: number, task: () => Promise<void>) {
    if (this.intervals.has(name)) {
      console.log(`Job ${name} already scheduled, skipping...`);
      return;
    }
    
    const interval = setInterval(async () => {
      try {
        await task();
      } catch (error) {
        console.error(`Error in scheduled job ${name}:`, error);
        await createAuditLog({
          action: 'scheduler_job_error',
          resource: 'scheduler',
          metadata: {
            job: name,
            error: error instanceof Error ? error.message : 'Unknown error'
          }
        });
      }
    }, intervalMs);
    
    this.intervals.set(name, interval);
    console.log(`Scheduled job: ${name} (every ${intervalMs}ms)`);
  }
  
  /**
   * Start all scheduled jobs
   */
  async start() {
    console.log('Starting scheduler...');
    
    // Process trades every 10 minutes
    this.scheduleJob('trade-batch-processor', 10 * 60 * 1000, async () => {
      console.log('Running scheduled trade batch processing...');
      await tradeBatchProcessor.processTradeBatch();
    });

    // Rotate verification codes every 24 hours
    this.scheduleJob('verification-code-rotation', 24 * 60 * 60 * 1000, async () => {
      console.log('Running scheduled verification code rotation...');
      await VerificationService.rotateAllCodes();
    });

    // Run immediately on startup
    setTimeout(() => {
      tradeBatchProcessor.processTradeBatch().catch(console.error);
    }, 5000); // Wait 5 seconds for server to fully start

    // Rotate verification codes on startup if any are expired
    setTimeout(async () => {
      console.log('Checking for expired verification codes...');
      await VerificationService.rotateExpiredCodes();
    }, 10000); // Wait 10 seconds for server to fully start

    await createAuditLog({
      action: 'scheduler_started',
      resource: 'scheduler',
      metadata: {
        jobs: Array.from(this.intervals.keys())
      }
    });
  }

  /**
   * Stop all scheduled jobs
   */
  async stop() {
    console.log('Stopping scheduler...');
    
    for (const [name, interval] of this.intervals) {
      clearInterval(interval);
      console.log(`Stopped job: ${name}`);
    }
    
    this.intervals.clear();

    await createAuditLog({
      action: 'scheduler_stopped',
      resource: 'scheduler',
      metadata: {}
    });
  }
}

// Singleton instance
export const scheduler = new Scheduler();
```

---

## File: server/services/securityService.ts

```typescript
import { db } from '../db';
import { platformSecurity, suspiciousActivity, tradingPlatforms } from '@shared/schema';
import { eq, gt, and, or, ilike } from 'drizzle-orm';
import crypto from 'crypto';

export class SecurityService {
  // Initialize security monitoring for a new platform
  async initializePlatformSecurity(platformId: number) {
    await db.insert(platformSecurity).values({
      platformId,
      status: 'active',
      riskScore: 0,
    });
  }

  // Check platform security status
  async checkPlatformStatus(platformId: number) {
    const [security] = await db
      .select()
      .from(platformSecurity)
      .where(eq(platformSecurity.platformId, platformId));
    
    if (!security) {
      // Initialize if not exists
      await this.initializePlatformSecurity(platformId);
      return { allowed: true, status: 'active' };
    }
    
    const allowed = ['active', 'under-review'].includes(security.status);
    return { allowed, status: security.status, reason: security.suspendedReason || security.bannedReason };
  }

  // Scan platform content for suspicious patterns
  async scanPlatformContent(platformId: number, content: {
    name?: string;
    config?: any;
    logoUrl?: string;
  }) {
    const suspiciousPatterns = [
      // Investment scams
      /guaranteed\s+returns?/i,
      /double\s+your\s+(money|investment)/i,
      /risk[\s-]?free\s+(profit|trading)/i,
      /minimum\s+\d+%\s+daily/i,
      
      // Phishing patterns
      /verify\s+your\s+wallet/i,
      /urgent\s+action\s+required/i,
      /limited\s+time\s+offer/i,
      
      // Crypto scams
      /crypto\s+mining\s+pool/i,
      /bitcoin\s+doubler/i,
      /ponzi/i,
      /pyramid\s+scheme/i,
      
      // Suspicious URLs
      /bit\.ly|tinyurl|short\.link/i,
    ];
    
    const contentString = JSON.stringify(content).toLowerCase();
    const detectedPatterns: string[] = [];
    
    for (const pattern of suspiciousPatterns) {
      if (pattern.test(contentString)) {
        detectedPatterns.push(pattern.source);
      }
    }
    
    if (detectedPatterns.length > 0) {
      // Log suspicious activity
      await this.logSuspiciousActivity({
        platformId,
        activityType: 'content_violation',
        description: `Suspicious patterns detected: ${detectedPatterns.join(', ')}`,
        severity: detectedPatterns.length > 2 ? 'high' : 'medium',
        metadata: { patterns: detectedPatterns, content }
      });
      
      // Increase risk score
      await this.updateRiskScore(platformId, detectedPatterns.length * 20);
    }
    
    return detectedPatterns;
  }

  // Update platform risk score
  async updateRiskScore(platformId: number, scoreChange: number) {
    const [security] = await db
      .select()
      .from(platformSecurity)
      .where(eq(platformSecurity.platformId, platformId));
    
    if (!security) {
      await this.initializePlatformSecurity(platformId);
      return;
    }
    
    const newScore = Math.max(0, Math.min(100, (security.riskScore || 0) + scoreChange));
    
    await db
      .update(platformSecurity)
      .set({ 
        riskScore: newScore,
        updatedAt: new Date()
      })
      .where(eq(platformSecurity.platformId, platformId));
    
    // Auto-suspend if risk score too high
    if (newScore > 80 && security.status === 'active') {
      await this.suspendPlatform(platformId, 'High risk score detected - automatic suspension');
    }
  }

  // Log suspicious activity
  async logSuspiciousActivity(activity: {
    platformId?: number;
    userId?: number;
    activityType: string;
    description: string;
    ipAddress?: string;
    userAgent?: string;
    severity?: string;
    metadata?: any;
  }) {
    await db.insert(suspiciousActivity).values({
      ...activity,
      severity: activity.severity || 'medium',
    });
  }

  // Suspend a platform
  async suspendPlatform(platformId: number, reason: string) {
    await db
      .update(platformSecurity)
      .set({
        status: 'suspended',
        suspendedAt: new Date(),
        suspendedReason: reason,
        updatedAt: new Date()
      })
      .where(eq(platformSecurity.platformId, platformId));
    
    // Log the suspension
    await this.logSuspiciousActivity({
      platformId,
      activityType: 'platform_suspended',
      description: `Platform suspended: ${reason}`,
      severity: 'high'
    });
  }

  // Ban a platform permanently
  async banPlatform(platformId: number, reason: string) {
    await db
      .update(platformSecurity)
      .set({
        status: 'banned',
        bannedAt: new Date(),
        bannedReason: reason,
        updatedAt: new Date()
      })
      .where(eq(platformSecurity.platformId, platformId));
    
    // Also unpublish the platform
    await db
      .update(tradingPlatforms)
      .set({ isPublished: false })
      .where(eq(tradingPlatforms.id, platformId));
    
    // Log the ban
    await this.logSuspiciousActivity({
      platformId,
      activityType: 'platform_banned',
      description: `Platform permanently banned: ${reason}`,
      severity: 'critical'
    });
  }

  // Review a platform for approval/rejection
  async reviewPlatform(platformId: number, approved: boolean, notes: string) {
    const status = approved ? 'active' : 'under-review';
    
    await db
      .update(platformSecurity)
      .set({
        status,
        lastReviewedAt: new Date(),
        reviewNotes: notes,
        riskScore: approved ? 0 : undefined, // Reset risk score if approved
        updatedAt: new Date()
      })
      .where(eq(platformSecurity.platformId, platformId));
  }

  // Get suspicious platforms for admin review
  async getSuspiciousPlatforms() {
    return await db
      .select({
        platform: tradingPlatforms,
        security: platformSecurity,
        recentActivity: suspiciousActivity
      })
      .from(platformSecurity)
      .innerJoin(tradingPlatforms, eq(tradingPlatforms.id, platformSecurity.platformId))
      .leftJoin(
        suspiciousActivity,
        and(
          eq(suspiciousActivity.platformId, platformSecurity.platformId),
          eq(suspiciousActivity.isResolved, false)
        )
      )
      .where(
        or(
          gt(platformSecurity.riskScore, 50),
          eq(platformSecurity.status, 'under-review'),
          eq(platformSecurity.status, 'suspended')
        )
      );
  }

  // Generate secure API key
  generateApiKey(): string {
    return `llk_${crypto.randomBytes(32).toString('hex')}`;
  }

  // Hash API key for storage
  hashApiKey(apiKey: string): string {
    return crypto.createHash('sha256').update(apiKey).digest('hex');
  }

  // Verify API key
  verifyApiKey(apiKey: string, hashedKey: string): boolean {
    const hash = this.hashApiKey(apiKey);
    return crypto.timingSafeEqual(Buffer.from(hash), Buffer.from(hashedKey));
  }
}

export const securityService = new SecurityService();
```

---

## File: server/services/security.ts

```typescript
import { db } from "../db";
import { 
  platformSecurity, 
  suspiciousActivity, 
  verificationAttempts,
  tradingPlatforms,
  auditLogs 
} from "@shared/schema";
import { eq, and, gt, lt, sql, desc } from "drizzle-orm";
import { createAuditLog, AuditActions } from "../security/audit";

export class SecurityService {
  // Activity type constants
  static readonly ACTIVITY_TYPES = {
    RAPID_VERIFICATION: "rapid_verification_attempts",
    SUSPICIOUS_LINKS: "suspicious_links",
    CONTENT_VIOLATION: "content_violation",
    DOMAIN_MISMATCH: "domain_mismatch",
    FAKE_VERIFICATION: "fake_verification_display",
    SCRIPT_INJECTION: "script_injection",
    PHISHING_ATTEMPT: "phishing_attempt"
  };

  // Check for rapid verification attempts (rate limiting)
  static async checkRapidVerificationAttempts(ipAddress: string): Promise<boolean> {
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
    
    const [result] = await db
      .select({ count: sql<number>`count(*)` })
      .from(verificationAttempts)
      .where(and(
        eq(verificationAttempts.ipAddress, ipAddress),
        gt(verificationAttempts.createdAt, oneHourAgo)
      ));

    const attemptCount = result?.count || 0;
    
    // Flag if more than 10 attempts in an hour
    if (attemptCount > 10) {
      await this.reportSuspiciousActivity({
        activityType: this.ACTIVITY_TYPES.RAPID_VERIFICATION,
        description: `IP address ${ipAddress} made ${attemptCount} verification attempts in the last hour`,
        ipAddress,
        severity: "high",
        metadata: { attemptCount }
      });
      return true;
    }
    
    return false;
  }

  // Initialize platform security record
  static async initializePlatformSecurity(platformId: number): Promise<void> {
    await db.insert(platformSecurity).values({
      platformId,
      status: "active",
      riskScore: 0
    }).onConflictDoNothing();
  }

  // Report suspicious activity
  static async reportSuspiciousActivity(data: {
    platformId?: number;
    userId?: number;
    activityType: string;
    description: string;
    ipAddress?: string;
    userAgent?: string;
    severity?: string;
    metadata?: any;
  }): Promise<void> {
    await db.insert(suspiciousActivity).values({
      ...data,
      severity: data.severity || "medium"
    });

    // Increase risk score if platform-specific
    if (data.platformId) {
      await this.updateRiskScore(data.platformId, data.severity === "critical" ? 25 : 10);
    }
  }

  // Update platform risk score
  static async updateRiskScore(platformId: number, scoreIncrease: number): Promise<void> {
    await db
      .update(platformSecurity)
      .set({ 
        riskScore: sql`LEAST(${platformSecurity.riskScore} + ${scoreIncrease}, 100)`,
        updatedAt: new Date()
      })
      .where(eq(platformSecurity.platformId, platformId));

    // Auto-suspend if risk score is too high
    const [platform] = await db
      .select()
      .from(platformSecurity)
      .where(eq(platformSecurity.platformId, platformId));

    if (platform && platform.riskScore >= 75 && platform.status === "active") {
      await this.suspendPlatform(
        platformId, 
        "Automatically suspended due to high risk score"
      );
    }
  }

  // Suspend a platform
  static async suspendPlatform(platformId: number, reason: string): Promise<void> {
    await db
      .update(platformSecurity)
      .set({
        status: "suspended",
        suspendedAt: new Date(),
        suspendedReason: reason,
        updatedAt: new Date()
      })
      .where(eq(platformSecurity.platformId, platformId));

    // Also mark the platform as not verified
    await db
      .update(tradingPlatforms)
      .set({
        isVerified: false,
        updatedAt: new Date()
      })
      .where(eq(tradingPlatforms.id, platformId));

    // Log the action
    await createAuditLog({
      platformId,
      action: AuditActions.PLATFORM_SUSPENDED,
      resource: "platform",
      resourceId: platformId.toString(),
      metadata: { reason }
    });
  }

  // Ban a platform permanently
  static async banPlatform(platformId: number, reason: string): Promise<void> {
    await db
      .update(platformSecurity)
      .set({
        status: "banned",
        bannedAt: new Date(),
        bannedReason: reason,
        updatedAt: new Date()
      })
      .where(eq(platformSecurity.platformId, platformId));

    // Mark platform as not verified and not active
    await db
      .update(tradingPlatforms)
      .set({
        isVerified: false,
        isActive: false,
        updatedAt: new Date()
      })
      .where(eq(tradingPlatforms.id, platformId));

    // Log the action
    await createAuditLog({
      platformId,
      action: AuditActions.PLATFORM_BANNED,
      resource: "platform",
      resourceId: platformId.toString(),
      metadata: { reason }
    });
  }

  // Check if platform is allowed to operate
  static async isPlatformAllowed(platformId: number): Promise<boolean> {
    const [security] = await db
      .select()
      .from(platformSecurity)
      .where(eq(platformSecurity.platformId, platformId));

    if (!security) return true; // No security record means new platform
    
    return security.status === "active";
  }

  // Scan platform content for suspicious elements
  static async scanPlatformContent(platformId: number, content: {
    name?: string;
    config?: any;
    logoUrl?: string;
  }): Promise<boolean> {
    // Limit input size to prevent ReDoS attacks
    const contentString = JSON.stringify(content);
    if (contentString.length > 10000) {
      await this.reportSuspiciousActivity({
        platformId,
        activityType: this.ACTIVITY_TYPES.CONTENT_VIOLATION,
        description: "Platform content exceeds maximum allowed size",
        severity: "high",
        metadata: { contentLength: contentString.length }
      });
      return false;
    }

    // Use simple string checks instead of complex regex to avoid ReDoS
    const suspiciousKeywords = [
      'liquidlab.com', // Old domain
      'phishing',
      'scam',
      'hack',
      '100% guaranteed',
      'guaranteed returns',
      'investment opportunity',
      'crypto mining'
    ];

    // Safe regex patterns with bounded complexity
    const safePatterns = [
      /javascript:/i, // Simple pattern, no backtracking
      /<script\b/i, // Word boundary instead of [^>]*
      /on(?:click|load|error|mouseover)\s*=/i, // Specific events instead of \w+
    ];

    const flaggedPatterns: string[] = [];
    const lowerContent = contentString.toLowerCase();

    // Check simple keywords
    for (const keyword of suspiciousKeywords) {
      if (lowerContent.includes(keyword.toLowerCase())) {
        flaggedPatterns.push(keyword);
      }
    }

    // Check safe regex patterns
    for (const pattern of safePatterns) {
      if (pattern.test(contentString)) {
        flaggedPatterns.push(pattern.source);
      }
    }

    // Check for fake verification codes more safely
    if (lowerContent.includes('verify') && lowerContent.includes('code') && /[A-Z0-9]{8}/.test(contentString)) {
      flaggedPatterns.push('Potential fake verification code');
    }

    // Check for wallet connection urgency
    if (lowerContent.includes('connect') && lowerContent.includes('wallet') && lowerContent.includes('now')) {
      flaggedPatterns.push('Urgent wallet connection request');
    }

    if (flaggedPatterns.length > 0) {
      await this.reportSuspiciousActivity({
        platformId,
        activityType: this.ACTIVITY_TYPES.CONTENT_VIOLATION,
        description: "Platform content contains suspicious patterns",
        severity: "high",
        metadata: { flaggedPatterns, contentLength: contentString.length }
      });

      // Update platform security with flagged content
      await db
        .update(platformSecurity)
        .set({
          flaggedContent: { patterns: flaggedPatterns, timestamp: new Date() },
          updatedAt: new Date()
        })
        .where(eq(platformSecurity.platformId, platformId));

      return false;
    }

    return true;
  }

  // Get platform security status
  static async getPlatformSecurityStatus(platformId: number): Promise<any> {
    const [security] = await db
      .select()
      .from(platformSecurity)
      .where(eq(platformSecurity.platformId, platformId));

    const recentActivity = await db
      .select()
      .from(suspiciousActivity)
      .where(eq(suspiciousActivity.platformId, platformId))
      .orderBy(desc(suspiciousActivity.createdAt))
      .limit(10);

    return {
      security: security || { status: "active", riskScore: 0 },
      recentActivity
    };
  }

  // Review platform for admin
  static async reviewPlatform(platformId: number, reviewNotes: string, approve: boolean): Promise<void> {
    if (approve) {
      await db
        .update(platformSecurity)
        .set({
          status: "active",
          riskScore: 0,
          lastReviewedAt: new Date(),
          reviewNotes,
          updatedAt: new Date()
        })
        .where(eq(platformSecurity.platformId, platformId));
    } else {
      await this.suspendPlatform(platformId, `Admin review: ${reviewNotes}`);
    }
  }
}
```

---

## File: server/services/tradeBatchProcessor.ts

```typescript
import { storage } from '../storage';
import { createAuditLog } from '../security/audit';
import { HyperliquidService } from './hyperliquid';

interface TradeData {
  platformId: number;
  tradeId: string;
  userId: string;
  walletAddress: string;
  market: string;
  side: 'buy' | 'sell';
  size: string;
  price: string;
  fee: string;
  builderCode?: string;
  timestamp: number;
}

export class TradeBatchProcessor {
  private hyperliquidService: HyperliquidService;
  private lastProcessedTimestamp: number;
  private isProcessing: boolean = false;

  constructor() {
    this.hyperliquidService = new HyperliquidService();
    // Start from current time, will be updated from database on first run
    this.lastProcessedTimestamp = Date.now();
  }

  /**
   * Process recent trades in batches
   * Should be called periodically (e.g., every 5-10 minutes)
   */
  async processTradeBatch(): Promise<void> {
    if (this.isProcessing) {
      console.log('Trade batch processor is already running, skipping...');
      return;
    }

    this.isProcessing = true;
    console.log(`Starting trade batch processing from timestamp: ${this.lastProcessedTimestamp}`);

    try {
      // Get the last processed timestamp from database
      const lastProcessed = await this.getLastProcessedTimestamp();
      if (lastProcessed) {
        this.lastProcessedTimestamp = lastProcessed;
      }

      // Fetch recent trades from Hyperliquid
      const trades = await this.fetchRecentTrades();
      
      if (!trades || trades.length === 0) {
        console.log('No new trades to process');
        return;
      }

      console.log(`Found ${trades.length} trades to process`);

      // Process each trade
      let processedCount = 0;
      let errorCount = 0;

      for (const trade of trades) {
        try {
          // Process all trades (builder fees are handled by Hyperliquid onchain)
          await this.processSingleTrade(trade);
          processedCount++;
        } catch (error) {
          console.error(`Error processing trade ${trade.tradeId}:`, error);
          errorCount++;
        }
      }

      // Update last processed timestamp
      if (trades.length > 0) {
        const latestTimestamp = Math.max(...trades.map(t => t.timestamp));
        await this.updateLastProcessedTimestamp(latestTimestamp);
        this.lastProcessedTimestamp = latestTimestamp;
      }

      // Log summary
      await createAuditLog({
        action: 'batch_trades_processed',
        resource: 'trade_batch_processor',
        metadata: {
          totalTrades: trades.length,
          processedCount,
          errorCount,
          lastTimestamp: this.lastProcessedTimestamp
        }
      });

      console.log(`Batch processing complete. Processed: ${processedCount}, Errors: ${errorCount}`);

    } catch (error) {
      console.error('Error in trade batch processing:', error);
      await createAuditLog({
        action: 'batch_processing_error',
        resource: 'trade_batch_processor',
        metadata: {
          error: error instanceof Error ? error.message : 'Unknown error'
        }
      });
    } finally {
      this.isProcessing = false;
    }
  }

  /**
   * Process a single trade and record fee transaction
   */
  private async processSingleTrade(trade: TradeData): Promise<void> {
    // Calculate revenue split
    const totalFee = parseFloat(trade.fee);
    const platformShare = totalFee * 0.7; // 70% to platform
    const liquidlabShare = totalFee * 0.3; // 30% to LiquidLab

    // Check if this trade has already been processed
    const existingTransaction = await storage.getFeeTransactions(trade.platformId, {
      startDate: new Date(trade.timestamp - 1000),
      endDate: new Date(trade.timestamp + 1000)
    });

    const isDuplicate = existingTransaction.some(tx => 
      tx.tradeId === trade.tradeId
    );

    if (isDuplicate) {
      console.log(`Trade ${trade.tradeId} already processed, skipping...`);
      return;
    }

    // Calculate trade volume and fee rate
    const tradeVolume = parseFloat(trade.size) * parseFloat(trade.price);
    const feeRate = trade.market === 'spot' ? 0.002 : 0.001; // 0.2% for spot, 0.1% for perp
    
    // Record the fee transaction
    await storage.recordFeeTransaction({
      platformId: trade.platformId,
      tradeId: trade.tradeId,
      tradeType: 'perp', // Most Hyperliquid trades are perps
      tradeVolume: tradeVolume.toString(),
      feeRate: feeRate.toString(),
      totalFee: totalFee.toString(),
      platformShare: platformShare.toString(),
      liquidlabShare: liquidlabShare.toString(),
      status: 'completed'
    });

    // Update trader activity tracking
    if (trade.walletAddress) {
      await storage.updateTraderActivity(
        trade.platformId,
        trade.walletAddress,
        tradeVolume,
        totalFee
      );
    }

    // Update platform revenue summaries for all periods
    await storage.updateRevenueSummary(trade.platformId, 'daily');
    await storage.updateRevenueSummary(trade.platformId, 'weekly');
    await storage.updateRevenueSummary(trade.platformId, 'monthly');
    await storage.updateRevenueSummary(trade.platformId, 'all-time');

    console.log(`Processed trade ${trade.tradeId} for platform ${trade.platformId}, fee: ${totalFee}`);
  }

  /**
   * Fetch recent trades from Hyperliquid API
   * Since Hyperliquid doesn't have a direct builder code API, we need to:
   * 1. Get all platform owners from our database
   * 2. Fetch their trades using their wallet addresses (from Privy)
   * 3. Filter for trades with our builder wallet address
   */
  private async fetchRecentTrades(): Promise<TradeData[]> {
    try {
      const allTrades: TradeData[] = [];
      
      // Get all trading platforms from our database
      const platforms = await storage.getTradingPlatforms();
      
      if (!platforms || platforms.length === 0) {
        console.log('No platforms found to check for trades');
        return [];
      }

      console.log(`Checking trades for ${platforms.length} platforms`);

      // NOTE: In production, we would need to:
      // 1. Store wallet addresses when users connect through Privy
      // 2. Or fetch wallet addresses from Privy API using user IDs
      // 3. Then use those addresses to fetch trades from Hyperliquid
      
      // For now, let's create a demo implementation that shows how the system works
      // In production, replace this with actual Hyperliquid API calls
      
      // Demo: Generate sample trades for testing
      if (process.env.NODE_ENV === 'development') {
        console.log('Development mode: Generating sample trades for testing');
        
        // Always generate at least one new trade for testing
        const currentTime = Date.now();
        const sampleTrades: TradeData[] = [
          {
            platformId: platforms[0]?.id || 1,
            tradeId: `demo_${currentTime}_1`,
            userId: '0xdemo_wallet_address',
            walletAddress: '0xdemo_wallet_address_1',
            market: 'BTC',
            side: 'buy',
            size: '0.1',
            price: '120000',
            fee: '12', // 0.1% of 12000 USD
            builderCode: process.env.VITE_BUILDER_WALLET_ADDRESS || '0x0000000000000000000000000000000000000000',
            timestamp: currentTime - 5000 // 5 seconds ago
          },
          {
            platformId: platforms[0]?.id || 1,
            tradeId: `demo_${currentTime}_2`,
            userId: '0xdemo_wallet_address',
            walletAddress: '0xdemo_wallet_address_2',
            market: 'ETH',
            side: 'sell',
            size: '1.5',
            price: '3400',
            fee: '5.1', // 0.1% of 5100 USD
            builderCode: process.env.VITE_BUILDER_WALLET_ADDRESS || '0x0000000000000000000000000000000000000000',
            timestamp: currentTime - 3000 // 3 seconds ago
          }
        ];
        
        // Only return trades newer than last processed timestamp
        const newTrades = sampleTrades.filter(trade => trade.timestamp > this.lastProcessedTimestamp);
        console.log(`Generated ${sampleTrades.length} sample trades, ${newTrades.length} are new`);
        return newTrades;
      }

      // Production implementation: Fetch trades from real wallet addresses
      for (const platform of platforms) {
        // Get the platform owner's wallet address
        const user = await storage.getUser(platform.userId);
        if (!user || !user.walletAddress) {
          console.log(`No wallet address found for platform ${platform.id} owner`);
          continue;
        }

        console.log(`Checking trades for wallet ${user.walletAddress} (platform: ${platform.name})`);
        
        try {
          // Fetch trades from Hyperliquid for this wallet
          const userFills = await this.hyperliquidService.getUserFills(user.walletAddress);
          
          if (!userFills || userFills.length === 0) {
            continue;
          }

          // Filter for trades with our builder wallet and after last processed timestamp
          const platformTrades = userFills
            .filter((fill: any) => {
              // In production, Hyperliquid tracks builder fees onchain
              // We just need to check if this is a new trade
              const isNewTrade = new Date(fill.time).getTime() > this.lastProcessedTimestamp;
              return isNewTrade;
            })
            .map((fill: any) => {
              const tradeSize = parseFloat(fill.sz);
              const tradePrice = parseFloat(fill.px);
              const tradeValue = tradeSize * tradePrice;
              
              // Calculate fee based on crossed property (true = taker, false = maker)
              const feeRate = fill.crossed ? 0.001 : 0.0002; // 0.1% taker, 0.02% maker
              const fee = tradeValue * feeRate;
              
              return {
                platformId: platform.id,
                tradeId: fill.tid,
                userId: user.walletAddress,
                walletAddress: user.walletAddress,
                market: fill.coin,
                side: fill.side === 'B' ? 'buy' : 'sell',
                size: fill.sz,
                price: fill.px,
                fee: fee.toFixed(2),
                builderCode: process.env.VITE_BUILDER_WALLET_ADDRESS || '0x0000000000000000000000000000000000000000',
                timestamp: new Date(fill.time).getTime()
              };
            });

          allTrades.push(...platformTrades);
          
        } catch (error) {
          console.error(`Error fetching trades for wallet ${user.walletAddress}:`, error);
        }
      }
      
      console.log(`Found ${allTrades.length} total trades from ${platforms.length} platforms`);
      return allTrades;
      
    } catch (error) {
      console.error('Error in fetchRecentTrades:', error);
      return [];
    }
  }

  /**
   * Get the last processed timestamp from database
   */
  private async getLastProcessedTimestamp(): Promise<number | null> {
    try {
      // In development mode, start from 1 hour ago to ensure sample trades are processed
      if (process.env.NODE_ENV === 'development') {
        return Date.now() - 3600000; // 1 hour ago
      }
      
      // Get the most recent fee transaction
      const recentTransactions = await storage.getFeeTransactions(0, { 
        status: 'completed' 
      });

      if (recentTransactions.length === 0) {
        return null;
      }

      // Find the most recent timestamp from metadata
      let maxTimestamp = 0;
      for (const tx of recentTransactions) {
        const metadata = tx.metadata as any;
        if (metadata?.timestamp && metadata.timestamp > maxTimestamp) {
          maxTimestamp = metadata.timestamp;
        }
      }

      return maxTimestamp || null;
    } catch (error) {
      console.error('Error getting last processed timestamp:', error);
      return null;
    }
  }

  /**
   * Update the last processed timestamp
   */
  private async updateLastProcessedTimestamp(timestamp: number): Promise<void> {
    // Store in audit log for persistence
    await createAuditLog({
      action: 'batch_processor_checkpoint',
      resource: 'trade_batch_processor',
      metadata: {
        lastProcessedTimestamp: timestamp,
        processedAt: Date.now()
      }
    });
  }
}

// Singleton instance
export const tradeBatchProcessor = new TradeBatchProcessor();
```

---

## File: server/services/verification.ts

```typescript
import { db } from "../db";
import { platformVerificationTokens, verificationAttempts, tradingPlatforms } from "@shared/schema";
import { eq, and, lt, gt, count } from "drizzle-orm";
import crypto from "crypto";
import { SecurityService } from "./security";

export class VerificationService {
  private static TOKEN_EXPIRY_HOURS = 24;
  
  /**
   * Generate a new verification token for a platform
   * Automatically expires old tokens
   */
  static async generateToken(platformId: number): Promise<{ code: string; hash: string }> {
    // Expire old tokens for this platform
    await db
      .update(platformVerificationTokens)
      .set({ isActive: false })
      .where(and(
        eq(platformVerificationTokens.platformId, platformId),
        eq(platformVerificationTokens.isActive, true)
      ));
    
    // Generate new verification code (alphanumeric, 8 characters)
    const code = crypto.randomBytes(4).toString('hex').toUpperCase();
    
    // Generate security hash (SHA-256)
    const hash = crypto.createHash('sha256')
      .update(`${platformId}-${code}-${Date.now()}`)
      .digest('hex');
    
    // Calculate expiry time
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + this.TOKEN_EXPIRY_HOURS);
    
    // Insert new token
    await db.insert(platformVerificationTokens).values({
      platformId,
      verificationCode: code,
      securityHash: hash,
      isActive: true,
      expiresAt,
    });
    
    return { code, hash };
  }
  
  /**
   * Get the active verification code for a platform
   */
  static async getActiveCode(platformId: number): Promise<string | null> {
    try {
      const [token] = await db
        .select()
        .from(platformVerificationTokens)
        .where(and(
          eq(platformVerificationTokens.platformId, platformId),
          eq(platformVerificationTokens.isActive, true),
          gt(platformVerificationTokens.expiresAt, new Date())
        ));
      
      return token?.verificationCode || null;
    } catch (error) {
      console.error("Error getting active verification code:", error);
      return null;
    }
  }
  
  /**
   * Verify a platform using its verification code
   * Records the attempt for security auditing
   */
  static async verifyPlatform(
    code: string,
    ipAddress: string,
    userAgent?: string
  ): Promise<{ 
    success: boolean; 
    platform?: any; 
    error?: string;
    securityHash?: string;
  }> {
    try {
      // Check for rapid verification attempts from this IP
      const isRapidAttempt = await SecurityService.checkRapidVerificationAttempts(ipAddress);
      if (isRapidAttempt) {
        await db.insert(verificationAttempts).values({
          attemptedCode: code,
          ipAddress,
          userAgent,
          success: false,
          errorReason: 'rate_limited',
        });
        
        return { success: false, error: 'Too many verification attempts. Please try again later.' };
      }

      // Find active token with this code
      const [token] = await db
        .select()
        .from(platformVerificationTokens)
        .where(and(
          eq(platformVerificationTokens.verificationCode, code.toUpperCase()),
          eq(platformVerificationTokens.isActive, true),
          gt(platformVerificationTokens.expiresAt, new Date())
        ));
      
      if (!token) {
        // Record failed attempt
        await db.insert(verificationAttempts).values({
          attemptedCode: code,
          ipAddress,
          userAgent,
          success: false,
          errorReason: 'invalid_code',
        });
        
        return { success: false, error: 'Invalid verification code' };
      }
      
      // Get platform details
      const [platform] = await db
        .select()
        .from(tradingPlatforms)
        .where(eq(tradingPlatforms.id, token.platformId));
      
      if (!platform) {
        // Record failed attempt - platform not found
        await db.insert(verificationAttempts).values({
          attemptedCode: code,
          ipAddress,
          userAgent,
          success: false,
          errorReason: 'platform_not_found',
        });
        
        return { success: false, error: 'Platform not found' };
      }
      
      // Check if platform is allowed to operate (not suspended/banned)
      const isAllowed = await SecurityService.isPlatformAllowed(platform.id);
      if (!isAllowed) {
        await db.insert(verificationAttempts).values({
          attemptedCode: code,
          ipAddress,
          userAgent,
          success: false,
          errorReason: 'platform_suspended',
          platformId: platform.id,
        });
        
        return { success: false, error: 'This platform has been suspended. Please contact support.' };
      }
      
      // Check if platform is approved
      if (platform.approvalStatus !== 'approved') {
        await db.insert(verificationAttempts).values({
          attemptedCode: code,
          ipAddress,
          userAgent,
          success: false,
          errorReason: 'platform_not_approved',
          platformId: platform.id,
        });
        
        const errorMessage = platform.approvalStatus === 'rejected' 
          ? 'This platform has been rejected. Please check your email for details.'
          : 'This platform is pending approval. You will receive an email once approved.';
        
        return { success: false, error: errorMessage };
      }
      
      // Update platform as verified
      await db
        .update(tradingPlatforms)
        .set({
          isVerified: true,
          verificationDate: new Date(),
        })
        .where(eq(tradingPlatforms.id, platform.id));
      
      // Record successful attempt
      await db.insert(verificationAttempts).values({
        attemptedCode: code,
        ipAddress,
        userAgent,
        success: true,
        platformId: platform.id,
      });
      
      // Return updated platform info with builder wallet address
      const updatedPlatform = {
        ...platform,
        isVerified: true,
        verificationDate: new Date(),
        config: {
          ...platform.config,
          builderWalletAddress: process.env.BUILDER_WALLET_ADDRESS || '0x70997970C51812dc3A010C7d01b50e0d17dc79C8'
        }
      };
      
      return { 
        success: true, 
        platform: updatedPlatform, 
        securityHash: token.securityHash 
      };
      
    } catch (error) {
      console.error("Error in verifyPlatform:", error);
      
      // Try to record error attempt but don't fail if this also errors
      try {
        await db.insert(verificationAttempts).values({
          attemptedCode: code,
          ipAddress,
          userAgent,
          success: false,
          errorReason: 'system_error',
        });
      } catch (attemptError) {
        console.error("Error recording verification attempt:", attemptError);
      }
      
      return { success: false, error: 'System error during verification' };
    }
  }
  
  /**
   * Get verification history for a platform
   */
  static async getVerificationHistory(
    platformId: number,
    limit = 10
  ): Promise<any[]> {
    return await db
      .select()
      .from(verificationAttempts)
      .where(eq(verificationAttempts.platformId, platformId))
      .orderBy(verificationAttempts.createdAt)
      .limit(limit);
  }
  
  /**
   * Check if an IP has too many failed attempts
   */
  static async checkRateLimit(
    ipAddress: string,
    maxAttempts = 5,
    windowMinutes = 15
  ): Promise<boolean> {
    const windowStart = new Date();
    windowStart.setMinutes(windowStart.getMinutes() - windowMinutes);
    
    const [result] = await db
      .select({ count: count() })
      .from(verificationAttempts)
      .where(and(
        eq(verificationAttempts.ipAddress, ipAddress),
        eq(verificationAttempts.success, false),
        gt(verificationAttempts.createdAt, windowStart)
      ));
    
    return result.count < maxAttempts;
  }
  
  /**
   * Clean up expired tokens (run periodically)
   */
  static async cleanupExpiredTokens(): Promise<void> {
    await db
      .update(platformVerificationTokens)
      .set({ isActive: false })
      .where(and(
        eq(platformVerificationTokens.isActive, true),
        lt(platformVerificationTokens.expiresAt, new Date())
      ));
  }

  /**
   * Rotate verification codes for all platforms
   * Used by scheduler to automatically refresh codes every 24 hours
   */
  static async rotateAllCodes(): Promise<void> {
    try {
      console.log('Starting verification code rotation for all platforms...');
      
      // Get all approved platforms
      const platforms = await db
        .select()
        .from(tradingPlatforms)
        .where(eq(tradingPlatforms.approvalStatus, 'approved'));
      
      let rotatedCount = 0;
      
      for (const platform of platforms) {
        try {
          await this.generateToken(platform.id);
          rotatedCount++;
          console.log(`Rotated verification code for platform ${platform.id} (${platform.name})`);
        } catch (error) {
          console.error(`Failed to rotate code for platform ${platform.id}:`, error);
        }
      }
      
      console.log(`Verification code rotation complete. Rotated ${rotatedCount} of ${platforms.length} platforms.`);
      
      // Clean up any expired tokens
      await this.cleanupExpiredTokens();
      
    } catch (error) {
      console.error('Error in rotateAllCodes:', error);
      throw error;
    }
  }

  /**
   * Rotate expired verification codes
   * Used on startup to ensure all platforms have valid codes
   */
  static async rotateExpiredCodes(): Promise<void> {
    try {
      console.log('Checking for expired verification codes...');
      
      // Get all platforms
      const platforms = await db.select().from(tradingPlatforms);
      
      let rotatedCount = 0;
      
      for (const platform of platforms) {
        // Check if platform has an active, non-expired code
        const activeCode = await this.getActiveCode(platform.id);
        
        if (!activeCode) {
          // No active code found, generate a new one
          try {
            await this.generateToken(platform.id);
            rotatedCount++;
            console.log(`Generated new verification code for platform ${platform.id} (${platform.name})`);
          } catch (error) {
            console.error(`Failed to generate code for platform ${platform.id}:`, error);
          }
        }
      }
      
      if (rotatedCount > 0) {
        console.log(`Generated ${rotatedCount} new verification codes for platforms with expired codes.`);
      } else {
        console.log('All platforms have valid verification codes.');
      }
      
      // Clean up any expired tokens
      await this.cleanupExpiredTokens();
      
    } catch (error) {
      console.error('Error in rotateExpiredCodes:', error);
    }
  }
}
```

---

## File: server/storage.ts

```typescript
import { 
  users, 
  tradingPlatforms, 
  templates, 
  revenueRecords, 
  referrals,
  feeTransactions,
  platformRevenueSummary,
  moonpayTransactions,
  payoutRecords,
  traderActivity,
  incentiveTiers,
  type User, 
  type InsertUser,
  type TradingPlatform,
  type InsertTradingPlatform,
  type Template,
  type InsertTemplate,
  type RevenueRecord,
  type InsertRevenueRecord,
  type Referral,
  type InsertReferral,
  type FeeTransaction,
  type InsertFeeTransaction,
  type PlatformRevenueSummary,
  type MoonpayTransaction,
  type InsertMoonpayTransaction,
  type PayoutRecord,
  type InsertPayoutRecord,
  type TraderActivity,
  type InsertTraderActivity,
  type IncentiveTier,
  type InsertIncentiveTier
} from "@shared/schema";
import { db } from "./db";
import { eq, desc, and, gte, lte, sql, or } from "drizzle-orm";

export interface IStorage {
  // User management
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  getUserByWallet(walletAddress: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: number, updates: Partial<User>): Promise<User>;
  updateUserWallet(userId: number, walletAddress: string): Promise<User>;
  authenticateUser(email: string, password: string): Promise<User | undefined>;
  getAllUsers(): Promise<User[]>;
  updateUserPassword(userId: number, newPassword: string): Promise<void>;
  
  // 2FA management
  setup2FA(userId: number, secret: string, backupCodes: string[]): Promise<void>;
  enable2FA(userId: number): Promise<void>;
  disable2FA(userId: number): Promise<void>;
  get2FASecret(userId: number): Promise<string | null>;
  verify2FABackupCode(userId: number, code: string): Promise<boolean>;
  
  // Trading platforms
  getTradingPlatforms(userId?: string): Promise<TradingPlatform[]>;
  getTradingPlatform(id: number): Promise<TradingPlatform | undefined>;
  createTradingPlatform(platform: InsertTradingPlatform): Promise<TradingPlatform>;
  updateTradingPlatform(id: number, updates: Partial<TradingPlatform>): Promise<TradingPlatform>;
  deleteTradingPlatform(id: number): Promise<void>;
  
  // Platform approval
  getPendingPlatforms(): Promise<TradingPlatform[]>;
  approvePlatform(platformId: number, approvalNotes?: string): Promise<TradingPlatform>;
  rejectPlatform(platformId: number, rejectionReason: string): Promise<TradingPlatform>;
  
  // Templates
  getTemplates(): Promise<Template[]>;
  getTemplate(id: number): Promise<Template | undefined>;
  createTemplate(template: InsertTemplate): Promise<Template>;
  
  // Revenue tracking
  getRevenueRecords(userId: number, period: string): Promise<RevenueRecord[]>;
  createRevenueRecord(record: InsertRevenueRecord): Promise<RevenueRecord>;
  
  // Builder codes
  generateBuilderCode(userId: number): Promise<string>;
  validateBuilderCode(code: string): Promise<boolean>;
  
  // Analytics
  getDashboardAnalytics(userId: number): Promise<any>;
  
  // Referrals
  createReferral(referrerId: number, referredUserId: number): Promise<Referral>;
  getReferrals(userId: number): Promise<Referral[]>;
  
  // Fee tracking
  recordFeeTransaction(transaction: InsertFeeTransaction): Promise<FeeTransaction>;
  getFeeTransactions(platformId: number, options?: { status?: string; startDate?: Date; endDate?: Date }): Promise<FeeTransaction[]>;
  updateFeeTransactionStatus(transactionId: number, status: string, distributedAt?: Date): Promise<void>;
  
  // Revenue summaries
  updateRevenueSummary(platformId: number, period: string): Promise<void>;
  getRevenueSummary(platformId: number, period: string): Promise<PlatformRevenueSummary | undefined>;
  getAllPlatformRevenues(options?: { period?: string; minRevenue?: number }): Promise<PlatformRevenueSummary[]>;
  
  // MoonPay transactions
  recordMoonpayTransaction(transaction: InsertMoonpayTransaction): Promise<MoonpayTransaction>;
  getMoonpayTransactions(platformId: number, options?: { status?: string; startDate?: Date; endDate?: Date }): Promise<MoonpayTransaction[]>;
  getAllMoonpayTransactions(options?: { status?: string; startDate?: Date; endDate?: Date }): Promise<MoonpayTransaction[]>;
  updateMoonpayTransactionStatus(transactionId: number, status: string, completedAt?: Date): Promise<void>;
  getMoonpayRevenueSummary(platformId?: number): Promise<{ totalPurchases: string; totalAffiliateFees: string; platformEarnings: string; liquidlabEarnings: string }>;
  
  // Crypto payouts
  recordPayout(payout: InsertPayoutRecord): Promise<PayoutRecord>;
  getPayouts(platformId: number, options?: { status?: string; startDate?: Date; endDate?: Date }): Promise<PayoutRecord[]>;
  updatePayoutStatus(payoutId: number, status: string, txHash?: string): Promise<void>;
  getPendingPayouts(platformId: number): Promise<{ amount: string; period: string }[]>;
  
  // Trader activity tracking
  updateTraderActivity(platformId: number, walletAddress: string, tradeVolume: number, tradeFee: number): Promise<void>;
  getTraderActivity(platformId: number, walletAddress: string): Promise<TraderActivity | undefined>;
  getTopTraders(platformId: number, limit?: number): Promise<TraderActivity[]>;
  getTradersByPlatform(platformId: number, options?: { minVolume?: number; sortBy?: 'volume' | 'fees' | 'trades' }): Promise<TraderActivity[]>;
  
  // Incentive tiers
  createIncentiveTier(tier: InsertIncentiveTier): Promise<IncentiveTier>;
  updateIncentiveTier(tierId: number, updates: Partial<IncentiveTier>): Promise<IncentiveTier>;
  deleteIncentiveTier(tierId: number): Promise<void>;
  getIncentiveTiers(platformId: number): Promise<IncentiveTier[]>;
  getTraderTier(platformId: number, walletAddress: string): Promise<IncentiveTier | undefined>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: number): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || undefined;
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user || undefined;
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.email, email));
    return user || undefined;
  }

  async getUserByWallet(walletAddress: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.walletAddress, walletAddress));
    return user || undefined;
  }

  async authenticateUser(email: string, password: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(
      and(eq(users.email, email), eq(users.password, password))
    );
    return user || undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values({
        ...insertUser,
        builderCode: this.generateRandomCode('BLD'),
        referralCode: this.generateRandomCode('REF')
      })
      .returning();
    return user;
  }

  async updateUser(id: number, updates: Partial<User>): Promise<User> {
    const [user] = await db
      .update(users)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(users.id, id))
      .returning();
    return user;
  }

  async updateUserWallet(userId: number, walletAddress: string): Promise<User> {
    const [user] = await db
      .update(users)
      .set({ walletAddress, updatedAt: new Date() })
      .where(eq(users.id, userId))
      .returning();
    return user;
  }

  async getAllUsers(): Promise<User[]> {
    return await db.select().from(users).orderBy(desc(users.createdAt));
  }

  async updateUserPassword(userId: number, newPassword: string): Promise<void> {
    await db
      .update(users)
      .set({ password: newPassword, updatedAt: new Date() })
      .where(eq(users.id, userId));
  }

  async getTradingPlatforms(userId?: string): Promise<TradingPlatform[]> {
    if (userId) {
      return await db.select().from(tradingPlatforms).where(eq(tradingPlatforms.userId, parseInt(userId)));
    }
    return await db.select().from(tradingPlatforms);
  }

  async getTradingPlatform(id: number): Promise<TradingPlatform | undefined> {
    const [platform] = await db.select().from(tradingPlatforms).where(eq(tradingPlatforms.id, id));
    return platform || undefined;
  }

  async createTradingPlatform(platform: InsertTradingPlatform): Promise<TradingPlatform> {
    let baseSlug = this.generateSlug(platform.name);
    let slug = baseSlug;
    let subdomain = baseSlug; // Use same logic for subdomain
    let counter = 1;
    
    // Check if slug/subdomain already exists and append number if needed
    while (true) {
      const existing = await db.select().from(tradingPlatforms).where(
        or(
          eq(tradingPlatforms.slug, slug),
          eq(tradingPlatforms.subdomain, subdomain)
        )
      );
      if (existing.length === 0) {
        break;
      }
      slug = `${baseSlug}-${counter}`;
      subdomain = `${baseSlug}-${counter}`;
      counter++;
    }
    
    const [created] = await db
      .insert(tradingPlatforms)
      .values({
        ...platform,
        slug,
        subdomain, // Add subdomain for centralized SaaS
        // Auto-approve in development for easier testing
        approvalStatus: process.env.NODE_ENV === 'development' ? 'approved' : 'pending'
      })
      .returning();
    return created;
  }

  async updateTradingPlatform(id: number, updates: Partial<TradingPlatform>): Promise<TradingPlatform> {
    const [platform] = await db
      .update(tradingPlatforms)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(tradingPlatforms.id, id))
      .returning();
    return platform;
  }

  async deleteTradingPlatform(id: number): Promise<void> {
    await db.delete(tradingPlatforms).where(eq(tradingPlatforms.id, id));
  }

  async getPendingPlatforms(): Promise<TradingPlatform[]> {
    return await db
      .select()
      .from(tradingPlatforms)
      .where(eq(tradingPlatforms.approvalStatus, 'pending'))
      .orderBy(desc(tradingPlatforms.createdAt));
  }

  async approvePlatform(platformId: number, approvalNotes?: string): Promise<TradingPlatform> {
    const [platform] = await db
      .update(tradingPlatforms)
      .set({
        approvalStatus: 'approved',
        approvalDate: new Date(),
        approvalNotes,
        updatedAt: new Date(),
      })
      .where(eq(tradingPlatforms.id, platformId))
      .returning();
    
    if (!platform) {
      throw new Error('Platform not found');
    }
    
    return platform;
  }

  async rejectPlatform(platformId: number, rejectionReason: string): Promise<TradingPlatform> {
    const [platform] = await db
      .update(tradingPlatforms)
      .set({
        approvalStatus: 'rejected',
        approvalDate: new Date(),
        rejectionReason,
        updatedAt: new Date(),
      })
      .where(eq(tradingPlatforms.id, platformId))
      .returning();
    
    if (!platform) {
      throw new Error('Platform not found');
    }
    
    return platform;
  }

  async getTemplates(): Promise<Template[]> {
    return await db.select().from(templates).where(eq(templates.isPublic, true));
  }

  async getTemplate(id: number): Promise<Template | undefined> {
    const [template] = await db.select().from(templates).where(eq(templates.id, id));
    return template || undefined;
  }

  async createTemplate(template: InsertTemplate): Promise<Template> {
    const [created] = await db
      .insert(templates)
      .values(template)
      .returning();
    return created;
  }

  async getRevenueRecords(userId: number, period: string): Promise<RevenueRecord[]> {
    const now = new Date();
    let startDate: Date;
    
    switch (period) {
      case '7d':
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case '30d':
        startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
      case '90d':
        startDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
        break;
      default:
        startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    }

    return await db
      .select()
      .from(revenueRecords)
      .where(
        and(
          eq(revenueRecords.userId, userId),
          gte(revenueRecords.createdAt, startDate)
        )
      )
      .orderBy(desc(revenueRecords.createdAt));
  }

  async createRevenueRecord(record: InsertRevenueRecord): Promise<RevenueRecord> {
    const [created] = await db
      .insert(revenueRecords)
      .values(record)
      .returning();
    return created;
  }

  async generateBuilderCode(userId: number): Promise<string> {
    const code = this.generateRandomCode('BLD');
    await this.updateUser(userId, { builderCode: code });
    return code;
  }

  async validateBuilderCode(code: string): Promise<boolean> {
    const [user] = await db.select().from(users).where(eq(users.builderCode, code));
    return !!user;
  }

  async getDashboardAnalytics(userId: number): Promise<any> {
    const revenues = await this.getRevenueRecords(userId, '30d');
    const platforms = await this.getTradingPlatforms(userId.toString());
    
    const totalRevenue = revenues.reduce((sum, record) => sum + parseFloat(record.amount), 0);
    const dailyRevenue = revenues
      .filter(r => r.createdAt >= new Date(Date.now() - 24 * 60 * 60 * 1000))
      .reduce((sum, record) => sum + parseFloat(record.amount), 0);
    
    return {
      totalRevenue: totalRevenue.toFixed(2),
      dailyRevenue: dailyRevenue.toFixed(2),
      activeUsers: Math.floor(totalRevenue / 10), // Rough estimate
      totalVolume: (totalRevenue * 100).toFixed(2), // Rough estimate
      platforms: platforms.map(p => ({
        name: p.name,
        revenue: (Math.random() * 1000).toFixed(2),
        change: (Math.random() * 20 - 10).toFixed(1)
      }))
    };
  }

  async createReferral(referrerId: number, referredUserId: number): Promise<Referral> {
    const [referral] = await db
      .insert(referrals)
      .values({
        referrerId,
        referredUserId
      })
      .returning();
    return referral;
  }

  async getReferrals(userId: number): Promise<Referral[]> {
    return await db.select().from(referrals).where(eq(referrals.referrerId, userId));
  }

  // Fee tracking implementation
  async recordFeeTransaction(transaction: InsertFeeTransaction): Promise<FeeTransaction> {
    const [feeTransaction] = await db
      .insert(feeTransactions)
      .values(transaction)
      .returning();
    
    // Update revenue summary after recording transaction
    await this.updateRevenueSummary(transaction.platformId, 'daily');
    await this.updateRevenueSummary(transaction.platformId, 'weekly');
    await this.updateRevenueSummary(transaction.platformId, 'monthly');
    await this.updateRevenueSummary(transaction.platformId, 'all-time');
    
    return feeTransaction;
  }

  async getFeeTransactions(
    platformId: number, 
    options?: { status?: string; startDate?: Date; endDate?: Date }
  ): Promise<FeeTransaction[]> {
    const conditions = [eq(feeTransactions.platformId, platformId)];
    
    if (options?.status) {
      conditions.push(eq(feeTransactions.status, options.status));
    }
    
    if (options?.startDate) {
      conditions.push(gte(feeTransactions.createdAt, options.startDate));
    }
    
    if (options?.endDate) {
      conditions.push(lte(feeTransactions.createdAt, options.endDate));
    }
    
    return await db
      .select()
      .from(feeTransactions)
      .where(and(...conditions))
      .orderBy(desc(feeTransactions.createdAt));
  }

  async updateFeeTransactionStatus(
    transactionId: number, 
    status: string, 
    distributedAt?: Date
  ): Promise<void> {
    await db
      .update(feeTransactions)
      .set({ 
        status, 
        distributedAt: distributedAt || new Date() 
      })
      .where(eq(feeTransactions.id, transactionId));
  }

  async updateRevenueSummary(platformId: number, period: string): Promise<void> {
    const now = new Date();
    let startDate: Date;
    let endDate = now;
    
    switch (period) {
      case 'daily':
        startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        break;
      case 'weekly':
        const weekAgo = new Date(now);
        weekAgo.setDate(weekAgo.getDate() - 7);
        startDate = weekAgo;
        break;
      case 'monthly':
        startDate = new Date(now.getFullYear(), now.getMonth(), 1);
        break;
      case 'all-time':
        startDate = new Date('2024-01-01');
        break;
      default:
        throw new Error(`Invalid period: ${period}`);
    }
    
    // Get all transactions for the period
    const transactions = await this.getFeeTransactions(platformId, { startDate, endDate });
    
    // Calculate totals
    const totalVolume = transactions.reduce((sum, tx) => sum + parseFloat(tx.tradeVolume), 0);
    const totalFees = transactions.reduce((sum, tx) => sum + parseFloat(tx.totalFee), 0);
    const platformEarnings = transactions.reduce((sum, tx) => sum + parseFloat(tx.platformShare), 0);
    const liquidlabEarnings = transactions.reduce((sum, tx) => sum + parseFloat(tx.liquidlabShare), 0);
    
    // Upsert the summary
    await db
      .insert(platformRevenueSummary)
      .values({
        platformId,
        period,
        startDate: startDate.toISOString().split('T')[0],
        endDate: endDate.toISOString().split('T')[0],
        totalVolume: totalVolume.toFixed(8),
        totalFees: totalFees.toFixed(8),
        platformEarnings: platformEarnings.toFixed(8),
        liquidlabEarnings: liquidlabEarnings.toFixed(8),
        tradeCount: transactions.length,
      })
      .onConflictDoUpdate({
        target: [platformRevenueSummary.platformId, platformRevenueSummary.period, platformRevenueSummary.startDate],
        set: {
          endDate: endDate.toISOString().split('T')[0],
          totalVolume: totalVolume.toFixed(8),
          totalFees: totalFees.toFixed(8),
          platformEarnings: platformEarnings.toFixed(8),
          liquidlabEarnings: liquidlabEarnings.toFixed(8),
          tradeCount: transactions.length,
          lastUpdated: new Date(),
        },
      });
  }

  async getRevenueSummary(
    platformId: number, 
    period: string
  ): Promise<PlatformRevenueSummary | undefined> {
    const [summary] = await db
      .select()
      .from(platformRevenueSummary)
      .where(
        and(
          eq(platformRevenueSummary.platformId, platformId),
          eq(platformRevenueSummary.period, period)
        )
      )
      .orderBy(desc(platformRevenueSummary.startDate))
      .limit(1);
    
    return summary;
  }

  async getAllPlatformRevenues(
    options?: { period?: string; minRevenue?: number }
  ): Promise<PlatformRevenueSummary[]> {
    const query = options?.period
      ? db.select().from(platformRevenueSummary).where(eq(platformRevenueSummary.period, options.period))
      : db.select().from(platformRevenueSummary);
    
    const results = await query.orderBy(desc(platformRevenueSummary.platformEarnings));
    
    if (options?.minRevenue !== undefined) {
      const minRev = options.minRevenue;
      return results.filter(r => parseFloat(r.platformEarnings) >= minRev);
    }
    
    return results;
  }

  // MoonPay transactions
  async recordMoonpayTransaction(transaction: InsertMoonpayTransaction): Promise<MoonpayTransaction> {
    const [result] = await db
      .insert(moonpayTransactions)
      .values(transaction)
      .returning();
    return result;
  }

  async getMoonpayTransactions(
    platformId: number, 
    options?: { status?: string; startDate?: Date; endDate?: Date }
  ): Promise<MoonpayTransaction[]> {
    const conditions = [eq(moonpayTransactions.platformId, platformId)];
    
    if (options?.status) {
      conditions.push(eq(moonpayTransactions.status, options.status));
    }
    
    if (options?.startDate) {
      conditions.push(gte(moonpayTransactions.createdAt, options.startDate));
    }
    
    if (options?.endDate) {
      conditions.push(lte(moonpayTransactions.createdAt, options.endDate));
    }
    
    return await db
      .select()
      .from(moonpayTransactions)
      .where(and(...conditions))
      .orderBy(desc(moonpayTransactions.createdAt));
  }

  async getAllMoonpayTransactions(
    options?: { status?: string; startDate?: Date; endDate?: Date }
  ): Promise<MoonpayTransaction[]> {
    const conditions = [];
    
    if (options?.status) {
      conditions.push(eq(moonpayTransactions.status, options.status));
    }
    
    if (options?.startDate) {
      conditions.push(gte(moonpayTransactions.createdAt, options.startDate));
    }
    
    if (options?.endDate) {
      conditions.push(lte(moonpayTransactions.createdAt, options.endDate));
    }
    
    const query = conditions.length > 0
      ? db.select().from(moonpayTransactions).where(and(...conditions))
      : db.select().from(moonpayTransactions);
    
    return await query.orderBy(desc(moonpayTransactions.createdAt));
  }

  async updateMoonpayTransactionStatus(
    transactionId: number, 
    status: string, 
    completedAt?: Date
  ): Promise<void> {
    await db
      .update(moonpayTransactions)
      .set({ 
        status, 
        completedAt,
      })
      .where(eq(moonpayTransactions.id, transactionId));
  }

  async getMoonpayRevenueSummary(platformId?: number): Promise<{ 
    totalPurchases: string; 
    totalAffiliateFees: string; 
    platformEarnings: string; 
    liquidlabEarnings: string 
  }> {
    const conditions = [eq(moonpayTransactions.status, 'completed')];
    
    if (platformId) {
      conditions.push(eq(moonpayTransactions.platformId, platformId));
    }
    
    const transactions = await db
      .select()
      .from(moonpayTransactions)
      .where(and(...conditions));
    
    const summary = transactions.reduce((acc, tx) => ({
      totalPurchases: (parseFloat(acc.totalPurchases) + parseFloat(tx.purchaseAmount)).toFixed(2),
      totalAffiliateFees: (parseFloat(acc.totalAffiliateFees) + parseFloat(tx.affiliateFee)).toFixed(4),
      platformEarnings: (parseFloat(acc.platformEarnings) + parseFloat(tx.platformEarnings)).toFixed(4),
      liquidlabEarnings: (parseFloat(acc.liquidlabEarnings) + parseFloat(tx.liquidlabEarnings)).toFixed(4),
    }), {
      totalPurchases: '0.00',
      totalAffiliateFees: '0.00',
      platformEarnings: '0.00',
      liquidlabEarnings: '0.00',
    });
    
    return summary;
  }

  async recordPayout(payout: InsertPayoutRecord): Promise<PayoutRecord> {
    const [record] = await db
      .insert(payoutRecords)
      .values(payout)
      .returning();
    return record;
  }

  async getPayouts(
    platformId: number, 
    options?: { status?: string; startDate?: Date; endDate?: Date }
  ): Promise<PayoutRecord[]> {
    let query = db
      .select()
      .from(payoutRecords)
      .where(eq(payoutRecords.platformId, platformId));

    if (options?.status) {
      query = query.where(eq(payoutRecords.status, options.status));
    }

    if (options?.startDate) {
      query = query.where(gte(payoutRecords.periodStart, options.startDate));
    }

    if (options?.endDate) {
      query = query.where(lte(payoutRecords.periodEnd, options.endDate));
    }

    return await query.orderBy(desc(payoutRecords.processedAt));
  }

  async updatePayoutStatus(payoutId: number, status: string, txHash?: string): Promise<void> {
    const updates: any = { status };
    if (txHash) {
      updates.txHash = txHash;
    }
    if (status === 'completed') {
      updates.processedAt = new Date();
    }

    await db
      .update(payoutRecords)
      .set(updates)
      .where(eq(payoutRecords.id, payoutId));
  }

  async getPendingPayouts(platformId: number): Promise<{ amount: string; period: string }[]> {
    const summaries = await db
      .select()
      .from(platformRevenueSummary)
      .where(
        and(
          eq(platformRevenueSummary.platformId, platformId),
          sql`${platformRevenueSummary.totalRevenue} > 0`
        )
      );

    const payouts = await db
      .select()
      .from(payoutRecords)
      .where(eq(payoutRecords.platformId, platformId));

    const paidPeriods = new Set(
      payouts.map(p => `${p.periodStart.toISOString()}-${p.periodEnd.toISOString()}`)
    );

    return summaries
      .filter(s => !paidPeriods.has(`${s.periodStart.toISOString()}-${s.periodEnd.toISOString()}`))
      .map(s => ({
        amount: (parseFloat(s.totalRevenue) * 0.7).toFixed(2),
        period: s.period,
      }));
  }

  private generateRandomCode(prefix: string): string {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let result = prefix;
    for (let i = 0; i < 8; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }

  private generateSlug(name: string): string {
    return name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
  }

  // 2FA management
  async setup2FA(userId: number, secret: string, backupCodes: string[]): Promise<void> {
    await db
      .update(users)
      .set({
        twoFactorSecret: secret,
        twoFactorBackupCodes: JSON.stringify(backupCodes),
        updatedAt: new Date()
      })
      .where(eq(users.id, userId));
  }

  async enable2FA(userId: number): Promise<void> {
    await db
      .update(users)
      .set({
        twoFactorEnabled: true,
        updatedAt: new Date()
      })
      .where(eq(users.id, userId));
  }

  async disable2FA(userId: number): Promise<void> {
    await db
      .update(users)
      .set({
        twoFactorEnabled: false,
        twoFactorSecret: null,
        twoFactorBackupCodes: null,
        updatedAt: new Date()
      })
      .where(eq(users.id, userId));
  }

  async get2FASecret(userId: number): Promise<string | null> {
    const [user] = await db
      .select({ twoFactorSecret: users.twoFactorSecret })
      .from(users)
      .where(eq(users.id, userId));
    
    return user?.twoFactorSecret || null;
  }

  async verify2FABackupCode(userId: number, code: string): Promise<boolean> {
    const [user] = await db
      .select({ twoFactorBackupCodes: users.twoFactorBackupCodes })
      .from(users)
      .where(eq(users.id, userId));
    
    if (!user?.twoFactorBackupCodes) return false;
    
    const backupCodes = JSON.parse(user.twoFactorBackupCodes) as string[];
    const codeIndex = backupCodes.indexOf(code);
    
    if (codeIndex !== -1) {
      // Remove used backup code
      backupCodes.splice(codeIndex, 1);
      await db
        .update(users)
        .set({
          twoFactorBackupCodes: JSON.stringify(backupCodes),
          updatedAt: new Date()
        })
        .where(eq(users.id, userId));
      return true;
    }
    
    return false;
  }

  // Trader activity tracking methods
  async updateTraderActivity(platformId: number, walletAddress: string, tradeVolume: number, tradeFee: number): Promise<void> {
    const lowerWallet = walletAddress.toLowerCase();
    
    // Check if trader activity exists
    const [existing] = await db
      .select()
      .from(traderActivity)
      .where(and(
        eq(traderActivity.platformId, platformId),
        eq(traderActivity.walletAddress, lowerWallet)
      ));

    if (existing) {
      // Update existing trader activity
      const newTotalVolume = parseFloat(existing.totalVolume) + tradeVolume;
      const newTotalFees = parseFloat(existing.totalFees) + tradeFee;
      const newTradeCount = existing.tradeCount + 1;
      const newAverageTradeSize = newTotalVolume / newTradeCount;

      await db
        .update(traderActivity)
        .set({
          totalVolume: newTotalVolume.toString(),
          totalFees: newTotalFees.toString(),
          tradeCount: newTradeCount,
          averageTradeSize: newAverageTradeSize.toString(),
          lastTradeAt: new Date(),
          updatedAt: new Date()
        })
        .where(and(
          eq(traderActivity.platformId, platformId),
          eq(traderActivity.walletAddress, lowerWallet)
        ));
    } else {
      // Create new trader activity
      await db
        .insert(traderActivity)
        .values({
          platformId,
          walletAddress: lowerWallet,
          totalVolume: tradeVolume.toString(),
          totalFees: tradeFee.toString(),
          tradeCount: 1,
          averageTradeSize: tradeVolume.toString(),
          firstTradeAt: new Date(),
          lastTradeAt: new Date()
        });
    }
  }

  async getTraderActivity(platformId: number, walletAddress: string): Promise<TraderActivity | undefined> {
    const [activity] = await db
      .select()
      .from(traderActivity)
      .where(and(
        eq(traderActivity.platformId, platformId),
        eq(traderActivity.walletAddress, walletAddress.toLowerCase())
      ));
    return activity;
  }

  async getTopTraders(platformId: number, limit: number = 10): Promise<TraderActivity[]> {
    return await db
      .select()
      .from(traderActivity)
      .where(eq(traderActivity.platformId, platformId))
      .orderBy(desc(traderActivity.totalVolume))
      .limit(limit);
  }

  async getTradersByPlatform(
    platformId: number, 
    options?: { minVolume?: number; sortBy?: 'volume' | 'fees' | 'trades' }
  ): Promise<TraderActivity[]> {
    let query = db
      .select()
      .from(traderActivity)
      .where(eq(traderActivity.platformId, platformId));

    if (options?.minVolume) {
      query = query.where(
        and(
          eq(traderActivity.platformId, platformId),
          gte(traderActivity.totalVolume, options.minVolume.toString())
        )
      );
    }

    if (options?.sortBy === 'fees') {
      query = query.orderBy(desc(traderActivity.totalFees));
    } else if (options?.sortBy === 'trades') {
      query = query.orderBy(desc(traderActivity.tradeCount));
    } else {
      query = query.orderBy(desc(traderActivity.totalVolume));
    }

    return await query;
  }

  // Incentive tier methods
  async createIncentiveTier(tier: InsertIncentiveTier): Promise<IncentiveTier> {
    const [created] = await db
      .insert(incentiveTiers)
      .values(tier)
      .returning();
    return created;
  }

  async updateIncentiveTier(tierId: number, updates: Partial<IncentiveTier>): Promise<IncentiveTier> {
    const [updated] = await db
      .update(incentiveTiers)
      .set(updates)
      .where(eq(incentiveTiers.id, tierId))
      .returning();
    return updated;
  }

  async deleteIncentiveTier(tierId: number): Promise<void> {
    await db
      .delete(incentiveTiers)
      .where(eq(incentiveTiers.id, tierId));
  }

  async getIncentiveTiers(platformId: number): Promise<IncentiveTier[]> {
    return await db
      .select()
      .from(incentiveTiers)
      .where(and(
        eq(incentiveTiers.platformId, platformId),
        eq(incentiveTiers.isActive, true)
      ))
      .orderBy(incentiveTiers.minVolume);
  }

  async getTraderTier(platformId: number, walletAddress: string): Promise<IncentiveTier | undefined> {
    // Get trader's current volume
    const trader = await this.getTraderActivity(platformId, walletAddress);
    if (!trader) return undefined;

    // Get all active tiers for the platform
    const tiers = await this.getIncentiveTiers(platformId);
    if (tiers.length === 0) return undefined;

    // Find the highest tier the trader qualifies for
    const traderVolume = parseFloat(trader.totalVolume);
    let qualifiedTier: IncentiveTier | undefined;

    for (const tier of tiers) {
      if (traderVolume >= parseFloat(tier.minVolume)) {
        qualifiedTier = tier;
      } else {
        break; // Tiers are sorted by minVolume, so we can stop here
      }
    }

    return qualifiedTier;
  }
}

export const storage = new DatabaseStorage();

```

---

## File: server/vite.ts

```typescript
import express, { type Express } from "express";
import fs from "fs";
import path from "path";
import { createServer as createViteServer, createLogger } from "vite";
import { type Server } from "http";
import viteConfig from "../vite.config";
import { nanoid } from "nanoid";

const viteLogger = createLogger();

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });

  console.log(`${formattedTime} [${source}] ${message}`);
}

export async function setupVite(app: Express, server: Server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true as const,
  };

  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      },
    },
    server: serverOptions,
    appType: "custom",
  });

  app.use(vite.middlewares);
  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;

    try {
      const clientTemplate = path.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html",
      );

      // always reload the index.html file from disk incase it changes
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`,
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });
}

export function serveStatic(app: Express) {
  const distPath = path.resolve(import.meta.dirname, "public");

  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`,
    );
  }

  app.use(express.static(distPath));

  // fall through to index.html if the file doesn't exist
  app.use("*", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}

```

---

## File: server/webhooks/hyperliquid.ts

```typescript
import { Request, Response } from 'express';
import { storage } from '../storage';
import { createAuditLog } from '../security/audit';
import crypto from 'crypto';

// Verify webhook signature from Hyperliquid
function verifyWebhookSignature(payload: string, signature: string, secret: string): boolean {
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}

export async function handleHyperliquidWebhook(req: Request, res: Response) {
  try {
    const signature = req.headers['x-hyperliquid-signature'] as string;
    const webhookSecret = process.env.HYPERLIQUID_WEBHOOK_SECRET;
    
    if (!webhookSecret) {
      console.error('HYPERLIQUID_WEBHOOK_SECRET not configured');
      return res.status(500).json({ error: 'Webhook not configured' });
    }

    // Verify signature
    const payload = JSON.stringify(req.body);
    if (!verifyWebhookSignature(payload, signature, webhookSecret)) {
      await createAuditLog({
        action: 'webhook_invalid_signature',
        resource: 'hyperliquid_webhook',
        ipAddress: req.ip,
        metadata: { signature }
      });
      return res.status(401).json({ error: 'Invalid signature' });
    }

    const { type, data } = req.body;

    // Handle trade execution events
    if (type === 'trade.executed') {
      const {
        platformId,
        tradeId,
        userId,
        market,
        side,
        size,
        price,
        fee,
        builderCode,
        timestamp
      } = data;

      // Only process trades with our builder code
      if (builderCode === 'LIQUIDLAB2025') {
        // Calculate revenue split
        const totalFee = parseFloat(fee);
        const platformShare = totalFee * 0.7; // 70% to platform
        const liquidlabShare = totalFee * 0.3; // 30% to LiquidLab

        // Record the fee transaction
        await storage.recordFeeTransaction({
          platformId: platformId,
          transactionId: tradeId,
          userId: userId,
          transactionType: 'trade',
          feeAmount: totalFee.toString(),
          platformEarnings: platformShare.toString(),
          liquidlabEarnings: liquidlabShare.toString(),
          metadata: {
            market,
            side,
            size,
            price,
            timestamp
          },
          status: 'completed'
        });

        // Log successful processing
        await createAuditLog({
          platformId,
          action: 'trade_fee_recorded',
          resource: 'fee_transaction',
          metadata: {
            tradeId,
            totalFee,
            platformShare,
            liquidlabShare
          }
        });
      }
    }

    res.json({ received: true });
  } catch (error) {
    console.error('Webhook processing error:', error);
    res.status(500).json({ error: 'Webhook processing failed' });
  }
}

// Endpoint to verify webhook configuration
export async function verifyWebhookEndpoint(req: Request, res: Response) {
  const challenge = req.query.challenge as string;
  if (challenge) {
    // Hyperliquid sends a challenge during webhook setup
    // Sanitize the challenge to prevent XSS attacks
    const sanitizedChallenge = challenge
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
      .replace(/\//g, '&#x2F;');
    
    // Return as plain text to prevent any HTML interpretation
    res.type('text/plain');
    return res.send(sanitizedChallenge);
  }
  res.json({ status: 'ready' });
}
```

---

## File: server/webhooks/security.ts

```typescript
import crypto from 'crypto';
import { Request, Response, NextFunction } from 'express';

// Verify webhook signatures from different providers
export function verifyWebhookSignature(
  provider: 'hyperliquid' | 'moonpay' | 'stripe',
  secret: string
) {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      const signature = req.headers['x-webhook-signature'] as string;
      
      if (!signature) {
        return res.status(401).json({ error: 'Missing webhook signature' });
      }
      
      let expectedSignature: string;
      
      switch (provider) {
        case 'hyperliquid':
          // Hyperliquid uses HMAC-SHA256
          expectedSignature = crypto
            .createHmac('sha256', secret)
            .update(JSON.stringify(req.body))
            .digest('hex');
          break;
          
        case 'moonpay':
          // MoonPay uses HMAC-SHA256 with timestamp
          const timestamp = req.headers['x-moonpay-timestamp'] as string;
          const payload = `${timestamp}.${JSON.stringify(req.body)}`;
          expectedSignature = crypto
            .createHmac('sha256', secret)
            .update(payload)
            .digest('hex');
          break;
          
        case 'stripe':
          // Stripe signature verification (simplified)
          const stripeSignature = req.headers['stripe-signature'] as string;
          // In production, use Stripe SDK for verification
          expectedSignature = stripeSignature;
          break;
          
        default:
          return res.status(400).json({ error: 'Unknown webhook provider' });
      }
      
      // Timing-safe comparison
      const signatureValid = crypto.timingSafeEqual(
        Buffer.from(signature),
        Buffer.from(expectedSignature)
      );
      
      if (!signatureValid) {
        return res.status(401).json({ error: 'Invalid webhook signature' });
      }
      
      next();
    } catch (error) {
      console.error('Webhook verification error:', error);
      res.status(500).json({ error: 'Webhook verification failed' });
    }
  };
}

// Webhook replay attack prevention
const processedWebhooks = new Map<string, number>();

export function preventWebhookReplay(
  req: Request,
  res: Response,
  next: NextFunction
) {
  const webhookId = req.headers['x-webhook-id'] as string;
  const timestamp = req.headers['x-webhook-timestamp'] as string;
  
  if (!webhookId || !timestamp) {
    return res.status(400).json({ error: 'Missing webhook metadata' });
  }
  
  const webhookTime = parseInt(timestamp);
  const now = Date.now();
  
  // Reject webhooks older than 5 minutes
  if (now - webhookTime > 5 * 60 * 1000) {
    return res.status(400).json({ error: 'Webhook too old' });
  }
  
  // Check for replay
  if (processedWebhooks.has(webhookId)) {
    return res.status(400).json({ error: 'Webhook already processed' });
  }
  
  // Store webhook ID with expiry
  processedWebhooks.set(webhookId, now);
  
  // Clean up old entries periodically
  if (processedWebhooks.size > 1000) {
    const cutoff = now - 10 * 60 * 1000; // 10 minutes
    for (const [id, time] of processedWebhooks.entries()) {
      if (time < cutoff) {
        processedWebhooks.delete(id);
      }
    }
  }
  
  next();
}
```

---

# Client Code

## File: client/src/App.tsx

```tsx
import { Switch, Route, useLocation } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import Header from "@/components/layout/header";
import Footer from "@/components/layout/footer";
import Home from "@/pages/home";
import Dashboard from "@/pages/dashboard";
import Builder from "@/pages/builder";
import Templates from "@/pages/templates";
import Analytics from "@/pages/analytics";
import Pricing from "@/pages/pricing";
import Education from "@/pages/education";
import ChartDemo from "@/pages/chart-demo";
import Example from "@/pages/example";
import NotFound from "@/pages/not-found";
import Login from "@/pages/login";
import Signup from "@/pages/signup";
import AdminLogin from "@/pages/admin-login";
import AdminDashboard from "@/pages/admin-dashboard";
import Security from "@/pages/security";
import Verify from "@/pages/verify";
import Enterprise from "@/pages/enterprise";
import { useEffect, useState } from "react";

// Check if we're on a platform subdomain
function isPlatformDomain() {
  const hostname = window.location.hostname;
  // Check if it's a subdomain of liquidlab.trade or app.liquidlab.trade
  // But not the main liquidlab.trade domain
  return (hostname.endsWith('.liquidlab.trade') || hostname.endsWith('.app.liquidlab.trade')) && 
         hostname !== 'liquidlab.trade' && 
         hostname !== 'app.liquidlab.trade' &&
         hostname !== 'www.liquidlab.trade';
}

function Router() {
  const [isPlatform, setIsPlatform] = useState(false);

  useEffect(() => {
    // Check if we're on a platform subdomain
    setIsPlatform(isPlatformDomain());
  }, []);

  // If we're on a platform subdomain, show the trading interface
  if (isPlatform) {
    return <Example />;
  }

  // Otherwise show the main LiquidLab routes
  return (
    <Switch>
      <Route path="/" component={Home} />
      <Route path="/dashboard" component={Dashboard} />
      <Route path="/builder" component={Builder} />
      <Route path="/builder/:templateId" component={Builder} />
      <Route path="/templates" component={Templates} />
      <Route path="/analytics" component={Analytics} />
      <Route path="/pricing" component={Pricing} />
      <Route path="/education" component={Education} />
      <Route path="/chart-demo" component={ChartDemo} />
      <Route path="/example" component={Example} />
      <Route path="/login" component={Login} />
      <Route path="/signup" component={Signup} />
      <Route path="/admin/login" component={AdminLogin} />
      <Route path="/admin/dashboard" component={AdminDashboard} />
      <Route path="/security" component={Security} />
      <Route path="/verify" component={Verify} />
      <Route path="/enterprise" component={Enterprise} />
      <Route component={NotFound} />
    </Switch>
  );
}

function AppContent() {
  const [location] = useLocation();
  const hideHeaderFooter = location === '/example' || location === '/login' || location === '/signup' || location.startsWith('/admin');

  return (
    <TooltipProvider>
      <div className="min-h-screen flex flex-col">
        {!hideHeaderFooter && <Header />}
        <main className="flex-1">
          <Router />
        </main>
        {!hideHeaderFooter && <Footer />}
      </div>
      <Toaster />
    </TooltipProvider>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <AppContent />
    </QueryClientProvider>
  );
}

export default App;

```

---

## File: client/src/components/admin/PayoutManagement.tsx

```tsx
import { useState, useEffect } from 'react';
import { useQuery, useMutation } from '@tanstack/react-query';
import { queryClient, apiRequest } from '@/lib/queryClient';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useToast } from '@/hooks/use-toast';
import { 
  AlertCircle, 
  CheckCircle, 
  DollarSign, 
  RefreshCw, 
  Wallet,
  ArrowRight,
  AlertTriangle
} from 'lucide-react';

interface PayoutReadiness {
  unclaimedFees: string;
  claimedNotConverted: string;
  availableForPayout: string;
  requiredForPayouts: string;
  readyToPayout: boolean;
  details: {
    platformId: number;
    unclaimedAmount: string;
    requiredAmount: string;
  }[];
}

interface WalletBalances {
  payoutWallet: {
    usdc: string;
    address: string;
  };
  builderWallet: {
    hyperliquid: string;
    address: string;
  };
}

export function PayoutManagement() {
  const { toast } = useToast();
  const [claimData, setClaimData] = useState({
    startDate: '',
    endDate: '',
    claimTxHash: ''
  });
  const [transferAmount, setTransferAmount] = useState('');

  // Fetch payout readiness
  const { data: readiness, isLoading: readinessLoading, refetch: refetchReadiness } = useQuery<PayoutReadiness>({
    queryKey: ['/api/admin/payout-readiness'],
    refetchInterval: 30000 // Refresh every 30 seconds
  });

  // Fetch wallet balances
  const { data: balances, refetch: refetchBalances } = useQuery<WalletBalances>({
    queryKey: ['/api/admin/wallet-balances'],
    refetchInterval: 30000
  });

  // Fetch unclaimed fees
  const { data: unclaimedFees } = useQuery({
    queryKey: ['/api/admin/unclaimed-fees'],
    refetchInterval: 30000
  });

  // Mark fees as claimed mutation
  const claimFeesMutation = useMutation({
    mutationFn: async (data: typeof claimData) => {
      return await apiRequest('/api/admin/claim-fees', {
        method: 'POST',
        body: JSON.stringify(data)
      });
    },
    onSuccess: () => {
      toast({
        title: "Fees Marked as Claimed",
        description: "Successfully updated fee status in the database",
      });
      queryClient.invalidateQueries({ queryKey: ['/api/admin/payout-readiness'] });
      queryClient.invalidateQueries({ queryKey: ['/api/admin/unclaimed-fees'] });
      setClaimData({ startDate: '', endDate: '', claimTxHash: '' });
    },
    onError: (error: any) => {
      toast({
        title: "Error",
        description: error.message || "Failed to mark fees as claimed",
        variant: "destructive",
      });
    }
  });

  // Transfer to payout wallet mutation
  const transferMutation = useMutation({
    mutationFn: async (amount: string) => {
      return await apiRequest('/api/admin/transfer-to-payout', {
        method: 'POST',
        body: JSON.stringify({ amount })
      });
    },
    onSuccess: () => {
      toast({
        title: "Transfer Initiated",
        description: "USDC transfer to payout wallet started",
      });
      queryClient.invalidateQueries({ queryKey: ['/api/admin/wallet-balances'] });
      setTransferAmount('');
    },
    onError: (error: any) => {
      toast({
        title: "Transfer Failed",
        description: error.message || "Failed to transfer funds",
        variant: "destructive",
      });
    }
  });

  // Process payouts mutation
  const processPayoutsMutation = useMutation({
    mutationFn: async () => {
      return await apiRequest('/api/payouts/process', {
        method: 'POST',
        body: JSON.stringify({ period: 'weekly' })
      });
    },
    onSuccess: () => {
      toast({
        title: "Payouts Started",
        description: "Payout processing has been initiated",
      });
    },
    onError: (error: any) => {
      toast({
        title: "Payout Error",
        description: error.message || "Failed to start payouts",
        variant: "destructive",
      });
    }
  });

  if (readinessLoading) {
    return <div>Loading payout status...</div>;
  }

  return (
    <div className="space-y-6">
      {/* Payout Readiness Status */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center justify-between">
            <span>Payout Readiness Status</span>
            <Button
              size="sm"
              variant="outline"
              onClick={() => {
                refetchReadiness();
                refetchBalances();
              }}
            >
              <RefreshCw className="w-4 h-4 mr-2" />
              Refresh
            </Button>
          </CardTitle>
        </CardHeader>
        <CardContent>
          {readiness && (
            <div className="space-y-4">
              {/* Overall Status */}
              <Alert variant={readiness.readyToPayout ? "default" : "destructive"}>
                <div className="flex items-center gap-2">
                  {readiness.readyToPayout ? (
                    <CheckCircle className="h-4 w-4 text-green-600" />
                  ) : (
                    <AlertTriangle className="h-4 w-4" />
                  )}
                  <AlertTitle>
                    {readiness.readyToPayout ? "Ready for Payouts" : "Not Ready for Payouts"}
                  </AlertTitle>
                </div>
                <AlertDescription className="mt-2">
                  {readiness.readyToPayout 
                    ? "All requirements met. You can process payouts now."
                    : "Please claim builder fees and ensure sufficient USDC balance before processing payouts."}
                </AlertDescription>
              </Alert>

              {/* Fee Status Cards */}
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <Card>
                  <CardContent className="pt-6">
                    <div className="text-2xl font-bold">${readiness.unclaimedFees}</div>
                    <p className="text-xs text-muted-foreground">Unclaimed Fees on Hyperliquid</p>
                    {parseFloat(readiness.unclaimedFees) > 0 && (
                      <Badge variant="outline" className="mt-2">Action Required</Badge>
                    )}
                  </CardContent>
                </Card>

                <Card>
                  <CardContent className="pt-6">
                    <div className="text-2xl font-bold">${readiness.claimedNotConverted}</div>
                    <p className="text-xs text-muted-foreground">Claimed but Not Converted</p>
                  </CardContent>
                </Card>

                <Card>
                  <CardContent className="pt-6">
                    <div className="text-2xl font-bold">${readiness.availableForPayout}</div>
                    <p className="text-xs text-muted-foreground">Available USDC</p>
                  </CardContent>
                </Card>

                <Card>
                  <CardContent className="pt-6">
                    <div className="text-2xl font-bold">${readiness.requiredForPayouts}</div>
                    <p className="text-xs text-muted-foreground">Required for Payouts</p>
                  </CardContent>
                </Card>
              </div>

              {/* Platform Details */}
              {readiness.details.length > 0 && (
                <div className="mt-4">
                  <h4 className="text-sm font-semibold mb-2">Platform Breakdown</h4>
                  <div className="space-y-2">
                    {readiness.details.map((detail) => (
                      <div key={detail.platformId} className="flex justify-between items-center p-2 bg-gray-50 rounded">
                        <span className="text-sm">Platform #{detail.platformId}</span>
                        <div className="text-sm text-right">
                          <div>Unclaimed: ${detail.unclaimedAmount}</div>
                          <div className="text-xs text-gray-500">Required: ${detail.requiredAmount}</div>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Wallet Balances */}
      <Card>
        <CardHeader>
          <CardTitle>Wallet Balances</CardTitle>
        </CardHeader>
        <CardContent>
          {balances && (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="p-4 border rounded-lg">
                <div className="flex items-center gap-2 mb-2">
                  <Wallet className="w-4 h-4" />
                  <span className="font-semibold">Builder Wallet (Hyperliquid)</span>
                </div>
                <p className="text-xs text-gray-600 mb-2">{balances.builderWallet.address}</p>
                <p className="text-xl font-bold">${balances.builderWallet.hyperliquid}</p>
                <p className="text-xs text-gray-500 mt-1">Unclaimed fees on Hyperliquid</p>
              </div>

              <div className="p-4 border rounded-lg">
                <div className="flex items-center gap-2 mb-2">
                  <DollarSign className="w-4 h-4" />
                  <span className="font-semibold">Payout Wallet (Arbitrum)</span>
                </div>
                <p className="text-xs text-gray-600 mb-2">{balances.payoutWallet.address}</p>
                <p className="text-xl font-bold">${balances.payoutWallet.usdc} USDC</p>
                <p className="text-xs text-gray-500 mt-1">Available for distribution</p>
              </div>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Claim Management */}
      <Card>
        <CardHeader>
          <CardTitle>Claim Management</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <Alert>
              <AlertCircle className="h-4 w-4" />
              <AlertTitle>Manual Process Required</AlertTitle>
              <AlertDescription>
                <ol className="list-decimal list-inside mt-2 space-y-1">
                  <li>Go to Hyperliquid and claim builder fees</li>
                  <li>Note the transaction hash and date range</li>
                  <li>Mark fees as claimed below</li>
                  <li>Convert to USDC and transfer to payout wallet</li>
                </ol>
              </AlertDescription>
            </Alert>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div>
                <Label htmlFor="startDate">Start Date</Label>
                <Input
                  id="startDate"
                  type="date"
                  value={claimData.startDate}
                  onChange={(e) => setClaimData({ ...claimData, startDate: e.target.value })}
                />
              </div>
              <div>
                <Label htmlFor="endDate">End Date</Label>
                <Input
                  id="endDate"
                  type="date"
                  value={claimData.endDate}
                  onChange={(e) => setClaimData({ ...claimData, endDate: e.target.value })}
                />
              </div>
              <div>
                <Label htmlFor="claimTxHash">Claim Transaction Hash</Label>
                <Input
                  id="claimTxHash"
                  placeholder="0x..."
                  value={claimData.claimTxHash}
                  onChange={(e) => setClaimData({ ...claimData, claimTxHash: e.target.value })}
                />
              </div>
            </div>
            <Button
              onClick={() => claimFeesMutation.mutate(claimData)}
              disabled={!claimData.startDate || !claimData.endDate || !claimData.claimTxHash || claimFeesMutation.isPending}
            >
              Mark Fees as Claimed
            </Button>
          </div>
        </CardContent>
      </Card>

      {/* Transfer to Payout Wallet */}
      <Card>
        <CardHeader>
          <CardTitle>Transfer USDC to Payout Wallet</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <div className="flex gap-4">
              <div className="flex-1">
                <Label htmlFor="transferAmount">Amount (USDC)</Label>
                <Input
                  id="transferAmount"
                  type="number"
                  step="0.01"
                  placeholder="100.00"
                  value={transferAmount}
                  onChange={(e) => setTransferAmount(e.target.value)}
                />
              </div>
              <div className="flex items-end">
                <Button
                  onClick={() => transferMutation.mutate(transferAmount)}
                  disabled={!transferAmount || parseFloat(transferAmount) <= 0 || transferMutation.isPending}
                >
                  <ArrowRight className="w-4 h-4 mr-2" />
                  Transfer to Payout Wallet
                </Button>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Process Payouts */}
      <Card>
        <CardHeader>
          <CardTitle>Process Weekly Payouts</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-600">
                Process weekly payouts to all eligible platform owners
              </p>
              {readiness && !readiness.readyToPayout && (
                <p className="text-sm text-red-600 mt-1">
                  ⚠️ System is not ready for payouts. Please complete the steps above first.
                </p>
              )}
            </div>
            <Button
              onClick={() => processPayoutsMutation.mutate()}
              disabled={!readiness?.readyToPayout || processPayoutsMutation.isPending}
              variant={readiness?.readyToPayout ? "default" : "secondary"}
            >
              {processPayoutsMutation.isPending ? "Processing..." : "Process Payouts"}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

---

## File: client/src/components/auth/auth-modal.tsx

```tsx
import { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { Mail, User, Key } from "lucide-react";

const signUpSchema = z.object({
  username: z.string().min(3, "Username must be at least 3 characters"),
  email: z.string().email("Please enter a valid email address"),
  password: z.string().min(6, "Password must be at least 6 characters"),
});

const signInSchema = z.object({
  email: z.string().email("Please enter a valid email address"),
  password: z.string().min(6, "Password must be at least 6 characters"),
});

type SignUpData = z.infer<typeof signUpSchema>;
type SignInData = z.infer<typeof signInSchema>;

interface AuthModalProps {
  children: React.ReactNode;
  onSuccess?: () => void;
}

export default function AuthModal({ children, onSuccess }: AuthModalProps) {
  const [isOpen, setIsOpen] = useState(false);
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const signUpForm = useForm<SignUpData>({
    resolver: zodResolver(signUpSchema),
    defaultValues: {
      username: "",
      email: "",
      password: "",
    },
  });

  const signInForm = useForm<SignInData>({
    resolver: zodResolver(signInSchema),
    defaultValues: {
      email: "",
      password: "",
    },
  });

  const signUpMutation = useMutation({
    mutationFn: async (data: SignUpData) => {
      return await apiRequest("/api/auth/signup", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
    },
    onSuccess: (data) => {
      toast({
        title: "Account created successfully!",
        description: "Welcome to LiquidLab. You can now start building trading platforms.",
      });
      queryClient.invalidateQueries({ queryKey: ["/api/auth/user"] });
      setIsOpen(false);
      onSuccess?.();
    },
    onError: (error) => {
      toast({
        title: "Sign up failed",
        description: error instanceof Error ? error.message : "Please try again",
        variant: "destructive",
      });
    },
  });

  const signInMutation = useMutation({
    mutationFn: async (data: SignInData) => {
      return await apiRequest("/api/auth/signin", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
    },
    onSuccess: (data) => {
      toast({
        title: "Welcome back!",
        description: "You have successfully signed in to LiquidLab.",
      });
      queryClient.invalidateQueries({ queryKey: ["/api/auth/user"] });
      setIsOpen(false);
      onSuccess?.();
    },
    onError: (error) => {
      toast({
        title: "Sign in failed",
        description: error instanceof Error ? error.message : "Please try again",
        variant: "destructive",
      });
    },
  });



  const onSignUp = (data: SignUpData) => {
    signUpMutation.mutate(data);
  };

  const onSignIn = (data: SignInData) => {
    signInMutation.mutate(data);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogTrigger asChild>
        {children}
      </DialogTrigger>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>Join LiquidLab</DialogTitle>
        </DialogHeader>
        
        <Tabs defaultValue="signup" className="w-full">
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="signup">Sign Up</TabsTrigger>
            <TabsTrigger value="signin">Sign In</TabsTrigger>
          </TabsList>
          
          <TabsContent value="signup" className="space-y-4">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <User className="w-5 h-5" />
                  Create Account
                </CardTitle>
                <CardDescription>
                  Start building professional trading platforms
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <form onSubmit={signUpForm.handleSubmit(onSignUp)} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="username">Username</Label>
                    <Input
                      id="username"
                      {...signUpForm.register("username")}
                      placeholder="Enter your username"
                    />
                    {signUpForm.formState.errors.username && (
                      <p className="text-sm text-red-600">{signUpForm.formState.errors.username.message}</p>
                    )}
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="email">Email</Label>
                    <Input
                      id="email"
                      type="email"
                      {...signUpForm.register("email")}
                      placeholder="Enter your email"
                    />
                    {signUpForm.formState.errors.email && (
                      <p className="text-sm text-red-600">{signUpForm.formState.errors.email.message}</p>
                    )}
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="password">Password</Label>
                    <Input
                      id="password"
                      type="password"
                      {...signUpForm.register("password")}
                      placeholder="Enter your password"
                    />
                    {signUpForm.formState.errors.password && (
                      <p className="text-sm text-red-600">{signUpForm.formState.errors.password.message}</p>
                    )}
                  </div>

                  <Button 
                    type="submit" 
                    className="w-full bg-liquid-green hover:bg-liquid-accent"
                    disabled={signUpMutation.isPending}
                  >
                    {signUpMutation.isPending ? "Creating Account..." : "Create Account"}
                  </Button>
                </form>
              </CardContent>
            </Card>
          </TabsContent>
          
          <TabsContent value="signin" className="space-y-4">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Key className="w-5 h-5" />
                  Sign In
                </CardTitle>
                <CardDescription>
                  Welcome back to LiquidLab
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <form onSubmit={signInForm.handleSubmit(onSignIn)} className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="signin-email">Email</Label>
                    <Input
                      id="signin-email"
                      type="email"
                      {...signInForm.register("email")}
                      placeholder="Enter your email"
                    />
                    {signInForm.formState.errors.email && (
                      <p className="text-sm text-red-600">{signInForm.formState.errors.email.message}</p>
                    )}
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="signin-password">Password</Label>
                    <Input
                      id="signin-password"
                      type="password"
                      {...signInForm.register("password")}
                      placeholder="Enter your password"
                    />
                    {signInForm.formState.errors.password && (
                      <p className="text-sm text-red-600">{signInForm.formState.errors.password.message}</p>
                    )}
                  </div>

                  <Button 
                    type="submit" 
                    className="w-full bg-liquid-green hover:bg-liquid-accent"
                    disabled={signInMutation.isPending}
                  >
                    {signInMutation.isPending ? "Signing In..." : "Sign In"}
                  </Button>
                </form>
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>
      </DialogContent>
    </Dialog>
  );
}
```

---

## File: client/src/components/builder/component-library.tsx

```tsx
import { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ComponentConfig } from "@/types";
import { 
  BarChart3, 
  List, 
  ArrowUpDown, 
  Wallet, 
  PieChart,
  Settings,
  Plus
} from "lucide-react";

interface ComponentLibraryProps {
  onAddComponent: (component: ComponentConfig) => void;
  selectedComponentId?: string;
  onUpdateComponent?: (id: string, updates: Partial<ComponentConfig>) => void;
  selectedComponent?: ComponentConfig;
}

const availableComponents = [
  {
    id: 'tradingview-chart',
    type: 'tradingview-chart',
    name: 'TradingView Chart',
    icon: BarChart3,
    color: 'border-liquid-green',
    description: 'Advanced charting widget with technical indicators'
  },
  {
    id: 'orderbook',
    type: 'orderbook',
    name: 'Order Book',
    icon: List,
    color: 'border-blue-500',
    description: 'Live bid/ask order book display'
  },
  {
    id: 'trade-form',
    type: 'trade-form',
    name: 'Trade Form',
    icon: ArrowUpDown,
    color: 'border-purple-500',
    description: 'Buy/sell trading interface'
  },
  {
    id: 'portfolio',
    type: 'portfolio',
    name: 'Portfolio',
    icon: Wallet,
    color: 'border-orange-500',
    description: 'Account balance and positions overview'
  },
  {
    id: 'market-data',
    type: 'market-data',
    name: 'Market Data',
    icon: PieChart,
    color: 'border-red-500',
    description: 'Price tickers and market statistics'
  }
];

const popularSymbols = [
  'BTC/USD', 'ETH/USD', 'SOL/USD', 'AVAX/USD', 'ARB/USD',
  'OP/USD', 'SUI/USD', 'DOGE/USD', 'WIF/USD', 'BONK/USD'
];

export default function ComponentLibrary({ 
  onAddComponent, 
  selectedComponentId, 
  onUpdateComponent,
  selectedComponent 
}: ComponentLibraryProps) {
  const [platformSettings, setPlatformSettings] = useState({
    name: 'My Trading Platform',
    builderCode: 'LIQUIDLAB2024',
    commissionRate: '0.5',
    theme: 'light'
  });

  const handleAddComponent = (baseComponent: typeof availableComponents[0]) => {
    const newComponent: ComponentConfig = {
      id: `${baseComponent.type}-${Date.now()}`,
      type: baseComponent.type as any,
      position: { x: 0, y: 0, w: 2, h: 2 },
      settings: {
        symbol: 'BTC/USD',
        interval: '1D',
        theme: platformSettings.theme,
        height: 400,
        width: '100%'
      }
    };
    
    onAddComponent(newComponent);
  };

  const handleUpdateComponentSettings = (field: string, value: any) => {
    if (selectedComponent && onUpdateComponent) {
      onUpdateComponent(selectedComponent.id, {
        settings: {
          ...selectedComponent.settings,
          [field]: value
        }
      });
    }
  };

  const renderComponentSettings = () => {
    if (!selectedComponent) {
      return (
        <div className="text-center py-8 text-gray-500">
          <Settings className="w-12 h-12 mx-auto mb-4 text-gray-300" />
          <p className="text-sm">Select a component to configure its settings</p>
        </div>
      );
    }

    const commonSettings = (
      <div className="space-y-4">
        <div>
          <Label htmlFor="component-symbol">Symbol</Label>
          <Select
            value={selectedComponent.settings.symbol || 'BTC/USD'}
            onValueChange={(value) => handleUpdateComponentSettings('symbol', value)}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select symbol" />
            </SelectTrigger>
            <SelectContent>
              {popularSymbols.map(symbol => (
                <SelectItem key={symbol} value={symbol}>{symbol}</SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>

        <div>
          <Label htmlFor="component-height">Height (px)</Label>
          <Input
            id="component-height"
            type="number"
            value={selectedComponent.settings.height || 400}
            onChange={(e) => handleUpdateComponentSettings('height', parseInt(e.target.value))}
            min="200"
            max="800"
          />
        </div>
      </div>
    );

    const chartSpecificSettings = selectedComponent.type === 'tradingview-chart' && (
      <div className="space-y-4">
        <div>
          <Label htmlFor="chart-interval">Interval</Label>
          <Select
            value={selectedComponent.settings.interval || '1D'}
            onValueChange={(value) => handleUpdateComponentSettings('interval', value)}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select interval" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="1m">1 minute</SelectItem>
              <SelectItem value="5m">5 minutes</SelectItem>
              <SelectItem value="15m">15 minutes</SelectItem>
              <SelectItem value="1h">1 hour</SelectItem>
              <SelectItem value="4h">4 hours</SelectItem>
              <SelectItem value="1D">1 day</SelectItem>
              <SelectItem value="1W">1 week</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div>
          <Label htmlFor="chart-theme">Chart Theme</Label>
          <Select
            value={selectedComponent.settings.theme || 'light'}
            onValueChange={(value) => handleUpdateComponentSettings('theme', value)}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select theme" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="light">Light</SelectItem>
              <SelectItem value="dark">Dark</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div>
          <Label>
            <input
              type="checkbox"
              checked={selectedComponent.settings.showVolumeProfile || false}
              onChange={(e) => handleUpdateComponentSettings('showVolumeProfile', e.target.checked)}
              className="mr-2"
            />
            Show Volume Profile
          </Label>
        </div>

        <div>
          <Label>
            <input
              type="checkbox"
              checked={selectedComponent.settings.showOrderBook || false}
              onChange={(e) => handleUpdateComponentSettings('showOrderBook', e.target.checked)}
              className="mr-2"
            />
            Show Order Book
          </Label>
        </div>
      </div>
    );

    return (
      <div className="space-y-6">
        <div>
          <h4 className="font-semibold mb-4">
            {selectedComponent.type.replace('-', ' ')} Settings
          </h4>
          {commonSettings}
        </div>
        
        {chartSpecificSettings && (
          <div className="pt-4 border-t">
            <h4 className="font-semibold mb-4">Chart Settings</h4>
            {chartSpecificSettings}
          </div>
        )}
      </div>
    );
  };

  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle className="flex items-center">
          <Settings className="w-5 h-5 mr-2" />
          Builder Tools
        </CardTitle>
      </CardHeader>
      <CardContent>
        <Tabs defaultValue="components" className="w-full">
          <TabsList className="grid w-full grid-cols-3">
            <TabsTrigger value="components">Components</TabsTrigger>
            <TabsTrigger value="settings">Settings</TabsTrigger>
            <TabsTrigger value="config">Config</TabsTrigger>
          </TabsList>
          
          <TabsContent value="components" className="space-y-3 mt-4">
            <div className="text-sm text-gray-600 mb-3">
              Click to add components to your platform
            </div>
            {availableComponents.map(component => {
              const IconComponent = component.icon;
              return (
                <div
                  key={component.id}
                  className={`bg-white p-3 rounded-lg shadow-sm cursor-pointer hover:shadow-md transition-shadow border-l-4 ${component.color}`}
                  onClick={() => handleAddComponent(component)}
                >
                  <div className="flex items-center">
                    <IconComponent className={`mr-3 ${component.color.replace('border-', 'text-')}`} />
                    <div className="flex-1">
                      <div className="font-medium">{component.name}</div>
                      <div className="text-sm text-gray-500">{component.description}</div>
                    </div>
                    <Plus className="w-4 h-4 text-gray-400" />
                  </div>
                </div>
              );
            })}
          </TabsContent>
          
          <TabsContent value="settings" className="space-y-3 mt-4">
            {renderComponentSettings()}
          </TabsContent>
          
          <TabsContent value="config" className="space-y-3 mt-4">
            <div className="space-y-4">
              <div>
                <Label htmlFor="platform-name">Platform Name</Label>
                <Input
                  id="platform-name"
                  value={platformSettings.name}
                  onChange={(e) => setPlatformSettings(prev => ({ ...prev, name: e.target.value }))}
                  placeholder="My Trading Platform"
                />
              </div>
              
              <div>
                <Label htmlFor="builder-code">Builder Code</Label>
                <Input
                  id="builder-code"
                  value={platformSettings.builderCode}
                  onChange={(e) => setPlatformSettings(prev => ({ ...prev, builderCode: e.target.value }))}
                  placeholder="LIQUIDLAB2024"
                />
              </div>
              
              <div>
                <Label htmlFor="commission-rate">Commission Rate</Label>
                <Select
                  value={platformSettings.commissionRate}
                  onValueChange={(value) => setPlatformSettings(prev => ({ ...prev, commissionRate: value }))}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select rate" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="0.5">0.5%</SelectItem>
                    <SelectItem value="1.0">1.0%</SelectItem>
                    <SelectItem value="1.5">1.5%</SelectItem>
                    <SelectItem value="2.0">2.0%</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              
              <div>
                <Label htmlFor="platform-theme">Theme</Label>
                <Select
                  value={platformSettings.theme}
                  onValueChange={(value) => setPlatformSettings(prev => ({ ...prev, theme: value }))}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select theme" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="light">Light</SelectItem>
                    <SelectItem value="dark">Dark</SelectItem>
                    <SelectItem value="auto">Auto</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </div>
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  );
}

```

---

## File: client/src/components/builder/drag-drop-builder.tsx

```tsx
import { useState, useCallback } from "react";
import { DndContext, DragEndEvent, DragOverlay, DragStartEvent } from "@dnd-kit/core";
import { SortableContext, arrayMove } from "@dnd-kit/sortable";
import { ComponentConfig } from "@/types";
import { useDragDrop } from "@/hooks/use-drag-drop";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { 
  BarChart3, 
  List, 
  ArrowUpDown, 
  Wallet, 
  PieChart,
  Settings,
  Trash2,
  Eye,
  EyeOff
} from "lucide-react";

interface DragDropBuilderProps {
  components: ComponentConfig[];
  onComponentsChange: (components: ComponentConfig[]) => void;
  previewMode: 'desktop' | 'mobile';
}

export default function DragDropBuilder({ 
  components, 
  onComponentsChange, 
  previewMode 
}: DragDropBuilderProps) {
  const [selectedComponent, setSelectedComponent] = useState<string | null>(null);
  const [draggedComponent, setDraggedComponent] = useState<ComponentConfig | null>(null);
  
  const { sensors, handleDragStart, handleDragEnd } = useDragDrop({
    onDragEnd: (event: DragEndEvent) => {
      const { active, over } = event;
      
      if (over && active.id !== over.id) {
        const oldIndex = components.findIndex(c => c.id === active.id);
        const newIndex = components.findIndex(c => c.id === over.id);
        
        if (oldIndex !== -1 && newIndex !== -1) {
          const newComponents = arrayMove(components, oldIndex, newIndex);
          onComponentsChange(newComponents);
        }
      }
      
      setDraggedComponent(null);
    },
    onDragStart: (event: DragStartEvent) => {
      const component = components.find(c => c.id === event.active.id);
      setDraggedComponent(component || null);
    }
  });

  const handleRemoveComponent = useCallback((id: string) => {
    const newComponents = components.filter(c => c.id !== id);
    onComponentsChange(newComponents);
    if (selectedComponent === id) {
      setSelectedComponent(null);
    }
  }, [components, onComponentsChange, selectedComponent]);

  const handleToggleVisibility = useCallback((id: string) => {
    const newComponents = components.map(c => 
      c.id === id 
        ? { ...c, settings: { ...c.settings, hidden: !c.settings.hidden } }
        : c
    );
    onComponentsChange(newComponents);
  }, [components, onComponentsChange]);

  const handleUpdateSettings = useCallback((id: string, settings: Record<string, any>) => {
    const newComponents = components.map(c => 
      c.id === id 
        ? { ...c, settings: { ...c.settings, ...settings } }
        : c
    );
    onComponentsChange(newComponents);
  }, [components, onComponentsChange]);

  const getComponentIcon = (type: string) => {
    switch (type) {
      case 'tradingview-chart':
        return <BarChart3 className="w-5 h-5" />;
      case 'orderbook':
        return <List className="w-5 h-5" />;
      case 'trade-form':
        return <ArrowUpDown className="w-5 h-5" />;
      case 'portfolio':
        return <Wallet className="w-5 h-5" />;
      case 'market-data':
        return <PieChart className="w-5 h-5" />;
      default:
        return <BarChart3 className="w-5 h-5" />;
    }
  };

  const getComponentColor = (type: string) => {
    switch (type) {
      case 'tradingview-chart':
        return 'border-liquid-green bg-liquid-green/10';
      case 'orderbook':
        return 'border-blue-500 bg-blue-500/10';
      case 'trade-form':
        return 'border-purple-500 bg-purple-500/10';
      case 'portfolio':
        return 'border-orange-500 bg-orange-500/10';
      case 'market-data':
        return 'border-red-500 bg-red-500/10';
      default:
        return 'border-gray-500 bg-gray-500/10';
    }
  };

  const renderComponent = (component: ComponentConfig) => {
    const isSelected = selectedComponent === component.id;
    const isHidden = component.settings.hidden;
    const colorClasses = getComponentColor(component.type);
    
    return (
      <Card 
        key={component.id}
        className={`relative border-2 border-dashed cursor-pointer transition-all ${colorClasses} ${
          isSelected ? 'ring-2 ring-liquid-green' : ''
        } ${isHidden ? 'opacity-50' : ''}`}
        onClick={() => setSelectedComponent(component.id)}
      >
        <CardContent className="p-4">
          <div className="flex items-center justify-between mb-2">
            <div className="flex items-center space-x-2">
              {getComponentIcon(component.type)}
              <span className="text-sm font-medium">{component.type.replace('-', ' ')}</span>
            </div>
            <div className="flex items-center space-x-1">
              <Button
                variant="ghost"
                size="sm"
                onClick={(e) => {
                  e.stopPropagation();
                  handleToggleVisibility(component.id);
                }}
                className="h-6 w-6 p-0"
              >
                {isHidden ? <EyeOff className="w-3 h-3" /> : <Eye className="w-3 h-3" />}
              </Button>
              <Button
                variant="ghost"
                size="sm"
                onClick={(e) => {
                  e.stopPropagation();
                  handleRemoveComponent(component.id);
                }}
                className="h-6 w-6 p-0 text-red-500 hover:text-red-700"
              >
                <Trash2 className="w-3 h-3" />
              </Button>
            </div>
          </div>
          
          <div className="text-center py-8 text-gray-500">
            <div className="text-xs">
              {component.type === 'tradingview-chart' && 'TradingView Chart Widget'}
              {component.type === 'orderbook' && 'Live Order Book'}
              {component.type === 'trade-form' && 'Buy/Sell Interface'}
              {component.type === 'portfolio' && 'Portfolio Overview'}
              {component.type === 'market-data' && 'Market Data Display'}
            </div>
          </div>
          
          {component.settings.symbol && (
            <Badge variant="secondary" className="mt-2">
              {component.settings.symbol}
            </Badge>
          )}
        </CardContent>
      </Card>
    );
  };

  return (
    <DndContext sensors={sensors} onDragStart={handleDragStart} onDragEnd={handleDragEnd}>
      <div className={`bg-white rounded-lg p-4 min-h-80 ${
        previewMode === 'mobile' ? 'max-w-sm mx-auto' : 'w-full'
      }`}>
        {components.length > 0 ? (
          <SortableContext items={components.map(c => c.id)}>
            <div className={`grid gap-4 ${
              previewMode === 'mobile' ? 'grid-cols-1' : 'grid-cols-2'
            }`}>
              {components.map(component => renderComponent(component))}
            </div>
          </SortableContext>
        ) : (
          <div className="text-center text-gray-500 py-16">
            <BarChart3 className="w-16 h-16 mx-auto mb-4 text-gray-300" />
            <h3 className="text-lg font-semibold mb-2">Start Building</h3>
            <p className="text-sm">
              Drag components from the left panel to start building your trading platform
            </p>
          </div>
        )}
      </div>
      
      <DragOverlay>
        {draggedComponent ? (
          <div className="bg-white border-2 border-dashed border-liquid-green rounded-lg p-4 shadow-lg">
            <div className="flex items-center space-x-2">
              {getComponentIcon(draggedComponent.type)}
              <span className="text-sm font-medium">{draggedComponent.type.replace('-', ' ')}</span>
            </div>
          </div>
        ) : null}
      </DragOverlay>
    </DndContext>
  );
}

```

---

## File: client/src/components/builder/live-component-renderer.tsx

```tsx
import TradingViewWidget from "@/components/charts/tradingview-widget";
import Orderbook from "@/components/trading/orderbook";
import Portfolio from "@/components/trading/portfolio";
import MarketData from "@/components/trading/market-data";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { ComponentConfig } from "@/types";
import { 
  ArrowUpDown, 
  TrendingUp, 
  TrendingDown, 
  DollarSign,
  X
} from "lucide-react";

interface LiveComponentRendererProps {
  component: ComponentConfig;
  onRemove: (id: string) => void;
  isDemoMode?: boolean;
}

export default function LiveComponentRenderer({ 
  component, 
  onRemove, 
  isDemoMode = false 
}: LiveComponentRendererProps) {
  const renderComponent = () => {
    switch (component.type) {
      case 'tradingview-chart':
        return (
          <div className="h-full">
            <TradingViewWidget
              symbol={component.settings?.symbol || "BINANCE:BTCUSDT"}
              interval={component.settings?.interval || "1h"}
              theme={component.settings?.theme || "light"}
              height="100%"
              width="100%"
            />
          </div>
        );

      case 'orderbook':
        return (
          <Orderbook
            symbol={component.settings?.symbol || "BTC/USD"}
            height={450}
            showHeader={true}
          />
        );

      case 'portfolio':
        return (
          <Portfolio
            height={450}
            showHeader={true}
          />
        );

      case 'market-data':
        return (
          <MarketData
            symbols={component.settings?.symbols || ['BTC/USD', 'ETH/USD', 'SOL/USD']}
            height={450}
            showHeader={true}
          />
        );

      case 'trade-form':
        return (
          <Card className="h-full">
            <CardHeader>
              <CardTitle className="flex items-center">
                <ArrowUpDown className="w-5 h-5 mr-2" />
                Trade
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="flex space-x-2">
                <Button 
                  variant="default" 
                  size="sm" 
                  className="flex-1 bg-green-500 hover:bg-green-600"
                >
                  <TrendingUp className="w-4 h-4 mr-1" />
                  Buy
                </Button>
                <Button 
                  variant="outline" 
                  size="sm" 
                  className="flex-1 text-red-500 border-red-500 hover:bg-red-50"
                >
                  <TrendingDown className="w-4 h-4 mr-1" />
                  Sell
                </Button>
              </div>
              
              <div className="space-y-3">
                <div>
                  <Label htmlFor="orderType">Order Type</Label>
                  <Select defaultValue="market">
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="market">Market</SelectItem>
                      <SelectItem value="limit">Limit</SelectItem>
                      <SelectItem value="stop">Stop</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                
                <div>
                  <Label htmlFor="amount">Amount</Label>
                  <Input 
                    id="amount"
                    type="number" 
                    placeholder="0.00"
                    className="text-right"
                  />
                </div>
                
                <div>
                  <Label htmlFor="price">Price</Label>
                  <Input 
                    id="price"
                    type="number" 
                    placeholder="Market Price"
                    className="text-right"
                  />
                </div>
                
                <div className="border-t pt-3">
                  <div className="flex justify-between text-sm mb-2">
                    <span>Available:</span>
                    <span className="font-mono">1,234.56 USDT</span>
                  </div>
                  <div className="flex justify-between text-sm mb-3">
                    <span>Est. Total:</span>
                    <span className="font-mono">~0.00 USDT</span>
                  </div>
                  <Button className="w-full bg-liquid-green hover:bg-liquid-accent">
                    <DollarSign className="w-4 h-4 mr-2" />
                    Place Order
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        );

      default:
        return (
          <Card className="h-full">
            <CardContent className="flex items-center justify-center h-full">
              <div className="text-center text-gray-500">
                <component.icon className="w-12 h-12 mx-auto mb-2" />
                <p className="text-sm">{component.name}</p>
              </div>
            </CardContent>
          </Card>
        );
    }
  };

  return (
    <div className="relative group h-full">
      {isDemoMode && (
        <div className="absolute top-2 right-2 z-10">
          <Badge variant="secondary" className="bg-liquid-green text-white">
            Live Demo
          </Badge>
        </div>
      )}
      
      <Button
        variant="destructive"
        size="sm"
        className="absolute top-2 left-2 opacity-0 group-hover:opacity-100 transition-opacity z-10"
        onClick={() => onRemove(component.id)}
      >
        <X className="w-4 h-4" />
      </Button>
      
      <div className="h-full">
        {renderComponent()}
      </div>
    </div>
  );
}
```

---

## File: client/src/components/charts/CandlestickChart.tsx

```tsx
import { useEffect, useRef, useState } from 'react';

interface CandlestickChartProps {
  symbol: string;
  interval: string;
  height?: number;
  className?: string;
}

interface CandleData {
  time: number;
  open: number;
  high: number;
  low: number;
  close: number;
}

export default function CandlestickChart({
  symbol = "BTC",
  interval = "15m",
  height = 400,
  className = ""
}: CandlestickChartProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [currentPrice, setCurrentPrice] = useState<number | null>(null);
  const [candleData, setCandleData] = useState<CandleData[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadData = async () => {
      try {
        setError(null);
        
        const response = await fetch(`/api/hyperliquid/candles/${symbol}?interval=${interval}`);
        const data = await response.json();
        
        if (data.error) {
          setError(data.error);
          setIsLoading(false);
          return;
        }

        if (data.candles && data.candles.length > 0) {
          setCandleData(data.candles);
          setCurrentPrice(data.candles[data.candles.length - 1].close);
        }
        
        setIsLoading(false);
      } catch (error) {
        console.error('Error loading chart data:', error);
        setError('Failed to load chart data');
        setIsLoading(false);
      }
    };

    loadData();
    const intervalId = setInterval(loadData, 5000);
    
    return () => clearInterval(intervalId);
  }, [symbol, interval]);

  useEffect(() => {
    if (!canvasRef.current || !containerRef.current || candleData.length === 0) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Set canvas size
    const rect = containerRef.current.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = height;

    // Clear canvas
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Calculate dimensions
    const padding = { top: 60, right: 80, bottom: 40, left: 10 };
    const chartWidth = canvas.width - padding.left - padding.right;
    const chartHeight = canvas.height - padding.top - padding.bottom;

    // Calculate price range
    const prices = candleData.flatMap(c => [c.high, c.low]);
    const minPrice = Math.min(...prices) * 0.999;
    const maxPrice = Math.max(...prices) * 1.001;
    const priceRange = maxPrice - minPrice;

    // Calculate candle width
    const candleWidth = Math.max(3, Math.floor(chartWidth / candleData.length * 0.8));
    const spacing = chartWidth / candleData.length;

    // Draw grid lines
    ctx.strokeStyle = '#1a1a1a';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 5; i++) {
      const y = padding.top + (i / 5) * chartHeight;
      ctx.beginPath();
      ctx.moveTo(padding.left, y);
      ctx.lineTo(canvas.width - padding.right, y);
      ctx.stroke();

      // Draw price labels
      const price = maxPrice - (i / 5) * priceRange;
      ctx.fillStyle = '#9ca3af';
      ctx.font = '10px monospace';
      ctx.textAlign = 'left';
      ctx.fillText(`$${price.toFixed(2)}`, canvas.width - padding.right + 5, y + 3);
    }

    // Draw candlesticks
    candleData.forEach((candle, i) => {
      const x = padding.left + i * spacing + spacing / 2;
      const isGreen = candle.close >= candle.open;
      
      // Set colors
      ctx.fillStyle = isGreen ? '#22c55e' : '#ef4444';
      ctx.strokeStyle = isGreen ? '#22c55e' : '#ef4444';
      ctx.lineWidth = 1;

      // Calculate positions
      const highY = padding.top + ((maxPrice - candle.high) / priceRange) * chartHeight;
      const lowY = padding.top + ((maxPrice - candle.low) / priceRange) * chartHeight;
      const openY = padding.top + ((maxPrice - candle.open) / priceRange) * chartHeight;
      const closeY = padding.top + ((maxPrice - candle.close) / priceRange) * chartHeight;

      // Draw wick
      ctx.beginPath();
      ctx.moveTo(x, highY);
      ctx.lineTo(x, lowY);
      ctx.stroke();

      // Draw body
      const bodyTop = Math.min(openY, closeY);
      const bodyHeight = Math.abs(openY - closeY) || 1;
      
      ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
    });

    // Draw current price line
    if (currentPrice) {
      const currentY = padding.top + ((maxPrice - currentPrice) / priceRange) * chartHeight;
      ctx.strokeStyle = '#fbbf24';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 2]);
      ctx.beginPath();
      ctx.moveTo(padding.left, currentY);
      ctx.lineTo(canvas.width - padding.right, currentY);
      ctx.stroke();
      ctx.setLineDash([]);
    }

  }, [candleData, currentPrice, height]);

  if (error) {
    return (
      <div className={`relative ${className} bg-[#0a0a0a] border border-gray-800 rounded`} style={{ height: `${height}px` }}>
        <div className="absolute inset-0 flex items-center justify-center">
          <div className="text-red-400">Error: {error}</div>
        </div>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className={`relative ${className} bg-[#0a0a0a] border border-gray-800 rounded`} style={{ height: `${height}px` }}>
        <div className="absolute inset-0 flex items-center justify-center">
          <div className="text-gray-400">Loading Hyperliquid chart...</div>
        </div>
      </div>
    );
  }

  return (
    <div ref={containerRef} className={`relative ${className} bg-[#0a0a0a] border border-gray-800 rounded overflow-hidden`} style={{ height: `${height}px` }}>
      {/* Chart Header */}
      <div className="absolute top-0 left-0 right-0 p-3 bg-gradient-to-b from-[#0a0a0a] to-transparent z-10">
        <div className="flex items-center justify-between">
          <div>
            <h3 className="text-base font-semibold text-white">{symbol}/USD</h3>
            <p className="text-xs text-gray-400">{interval} · Hyperliquid</p>
          </div>
          {currentPrice && (
            <div className="text-right">
              <div className="text-xl font-mono text-white">${currentPrice.toFixed(2)}</div>
              <div className="text-xs text-green-400">Live</div>
            </div>
          )}
        </div>
      </div>

      {/* Canvas Chart */}
      <canvas 
        ref={canvasRef}
        className="w-full"
        style={{ height: `${height}px` }}
      />

      {/* Chart Footer */}
      <div className="absolute bottom-0 left-0 right-0 p-3 bg-gradient-to-t from-[#0a0a0a] to-transparent">
        <div className="flex justify-between text-xs text-gray-500">
          <span>Vol: ${(Math.random() * 10000000).toFixed(0)}</span>
          <span>24h H: ${currentPrice ? (currentPrice * 1.02).toFixed(2) : '0.00'}</span>
          <span>24h L: ${currentPrice ? (currentPrice * 0.98).toFixed(2) : '0.00'}</span>
        </div>
      </div>
    </div>
  );
}
```

---

## File: client/src/components/charts/HyperliquidChart.tsx

```tsx
import { useEffect, useRef, useState } from 'react';
import { createChart, ColorType, CandlestickSeries } from 'lightweight-charts';

interface HyperliquidChartProps {
  symbol: string;
  interval: string;
  theme?: 'dark' | 'light';
  height?: number | string;
  width?: number | string;
  className?: string;
}

export default function HyperliquidChart({
  symbol = "BTC",
  interval = "15m",
  theme = "dark",
  height = 400,
  width = "100%",
  className = ""
}: HyperliquidChartProps) {
  const chartContainerRef = useRef<HTMLDivElement>(null);
  const chartRef = useRef<any>(null);
  const candleSeriesRef = useRef<any>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [currentPrice, setCurrentPrice] = useState<number | null>(null);
  const isMountedRef = useRef(true);
  const [isChartReady, setIsChartReady] = useState(false);

  // Track component mounted state
  useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);

  useEffect(() => {
    if (!chartContainerRef.current || !isMountedRef.current) return;
    
    // Clear any existing chart
    if (chartRef.current) {
      try {
        chartRef.current.remove();
      } catch (error) {
        // Chart already disposed
      }
      chartRef.current = null;
      candleSeriesRef.current = null;
    }

    // Create chart with Hyperliquid-style dark theme
    const chart = createChart(chartContainerRef.current, {
      layout: {
        background: { type: ColorType.Solid, color: '#0a0a0a' },
        textColor: '#d1d4dc',
      },
      grid: {
        vertLines: {
          visible: true,
          color: '#1f2937',
          style: 1,
        },
        horzLines: {
          visible: true,
          color: '#1f2937',
          style: 1,
        },
      },
      width: chartContainerRef.current.clientWidth,
      height: typeof height === 'number' ? height : parseInt(height),
      timeScale: {
        borderColor: '#1f2937',
        timeVisible: true,
        secondsVisible: false,
      },
      rightPriceScale: {
        borderColor: '#1f2937',
        scaleMargins: {
          top: 0.1,
          bottom: 0.2,
        },
      },
      crosshair: {
        mode: 0,
        vertLine: {
          color: '#758696',
          labelBackgroundColor: '#374151',
        },
        horzLine: {
          color: '#758696',
          labelBackgroundColor: '#374151',
        },
      },
    });

    chartRef.current = chart;

    // Create candlestick series with Hyperliquid colors  
    const candleSeries = chart.addSeries(CandlestickSeries, {
      upColor: '#22c55e',
      downColor: '#ef4444',
      borderUpColor: '#22c55e',
      borderDownColor: '#ef4444',
      wickUpColor: '#22c55e',
      wickDownColor: '#ef4444',
    });

    candleSeriesRef.current = candleSeries;

    // Function to generate real-time candle data from orderbook prices
    const generateCandleData = async () => {
      try {
        setIsLoading(true);
        
        // Fetch current price from Hyperliquid
        const priceResponse = await fetch('/api/hyperliquid/market-prices');
        const prices = await priceResponse.json();
        const currentPrice = prices[symbol];
        
        if (!currentPrice) {
          console.error(`No price found for ${symbol}`);
          return;
        }

        setCurrentPrice(currentPrice);

        // Generate synthetic candle data based on current price
        // In production, you'd fetch historical data from Hyperliquid
        const now = Math.floor(Date.now() / 1000);
        const candleData: any[] = [];
        
        // Generate 100 candles of historical data
        for (let i = 100; i >= 0; i--) {
          const time = now - i * getIntervalSeconds(interval);
          const basePrice = currentPrice * (1 - i * 0.0001); // Slight trend
          const volatility = 0.002; // 0.2% volatility
          
          const open = basePrice * (1 + (Math.random() - 0.5) * volatility);
          const close = basePrice * (1 + (Math.random() - 0.5) * volatility);
          const high = Math.max(open, close) * (1 + Math.random() * volatility * 0.5);
          const low = Math.min(open, close) * (1 - Math.random() * volatility * 0.5);
          
          candleData.push({
            time,
            open,
            high,
            low,
            close,
          });
        }

        candleSeries.setData(candleData);
        chart.timeScale().fitContent();
        setIsLoading(false);
      } catch (error) {
        console.error('Error loading chart data:', error);
        setIsLoading(false);
      }
    };

    generateCandleData().then(() => {
      setIsChartReady(true);
    });

    // Set up real-time updates
    let isDisposed = false;
    const updateInterval = setInterval(async () => {
      if (isDisposed || !isMountedRef.current) return;
      
      try {
        const priceResponse = await fetch('/api/hyperliquid/market-prices');
        const prices = await priceResponse.json();
        const newPrice = prices[symbol];
        
        if (newPrice && candleSeriesRef.current && chartRef.current && !isDisposed && isMountedRef.current) {
          setCurrentPrice(newPrice);
          
          try {
            // Update the last candle with new price
            const now = Math.floor(Date.now() / 1000);
            candleSeriesRef.current.update({
              time: now,
              open: newPrice * (1 + (Math.random() - 0.5) * 0.001),
              high: newPrice * (1 + Math.random() * 0.001),
              low: newPrice * (1 - Math.random() * 0.001),
              close: newPrice,
            });
          } catch (updateError) {
            // Ignore disposal errors
            if (!updateError.message?.includes('disposed')) {
              console.error('Error updating candle:', updateError);
            }
          }
        }
      } catch (error) {
        if (!error.message?.includes('disposed')) {
          console.error('Error updating price:', error);
        }
      }
    }, 5000); // Update every 5 seconds

    // Handle resize
    const handleResize = () => {
      if (chartContainerRef.current && chartRef.current && !isDisposed) {
        try {
          chartRef.current.applyOptions({ width: chartContainerRef.current.clientWidth });
        } catch (error) {
          if (!error.message?.includes('disposed')) {
            console.error('Error resizing chart:', error);
          }
        }
      }
    };

    window.addEventListener('resize', handleResize);

    return () => {
      isDisposed = true;
      window.removeEventListener('resize', handleResize);
      clearInterval(updateInterval);
      if (chartRef.current) {
        try {
          chartRef.current.remove();
        } catch (error) {
          // Chart already disposed
        }
      }
      chartRef.current = null;
      candleSeriesRef.current = null;
    };
  }, []); // Only create chart once on mount

  // Handle symbol/interval changes
  useEffect(() => {
    if (!candleSeriesRef.current || !isMountedRef.current || !isChartReady) return;

    const updateChartData = async () => {
      try {
        setIsLoading(true);
        
        // Fetch current price from Hyperliquid
        const priceResponse = await fetch('/api/hyperliquid/market-prices');
        const prices = await priceResponse.json();
        
        // Handle API error
        if (!priceResponse.ok || prices.error) {
          console.error('API error:', prices.error || 'Failed to fetch prices');
          setIsLoading(false);
          return;
        }
        
        const currentPrice = prices[symbol];
        
        if (!currentPrice) {
          console.error(`No price found for ${symbol}`);
          setIsLoading(false);
          return;
        }

        setCurrentPrice(currentPrice);

        // Generate new candle data for the symbol
        const now = Math.floor(Date.now() / 1000);
        const candleData: any[] = [];
        
        for (let i = 100; i >= 0; i--) {
          const time = now - i * getIntervalSeconds(interval);
          const basePrice = currentPrice * (1 - i * 0.0001);
          const volatility = 0.002;
          
          const open = basePrice * (1 + (Math.random() - 0.5) * volatility);
          const close = basePrice * (1 + (Math.random() - 0.5) * volatility);
          const high = Math.max(open, close) * (1 + Math.random() * volatility * 0.5);
          const low = Math.min(open, close) * (1 - Math.random() * volatility * 0.5);
          
          candleData.push({ time, open, high, low, close });
        }

        if (candleSeriesRef.current && isMountedRef.current) {
          try {
            candleSeriesRef.current.setData(candleData);
            chartRef.current?.timeScale().fitContent();
          } catch (error) {
            if (!error.message?.includes('disposed')) {
              console.error('Error setting chart data:', error);
            }
          }
        }
      } catch (error) {
        console.error('Error updating chart data:', error);
      } finally {
        setIsLoading(false);
      }
    };

    updateChartData();
  }, [symbol, interval, isChartReady]);

  const getIntervalSeconds = (interval: string): number => {
    const intervalMap: { [key: string]: number } = {
      '1m': 60,
      '5m': 300,
      '15m': 900,
      '1h': 3600,
      '4h': 14400,
      '1d': 86400,
    };
    return intervalMap[interval] || 900;
  };

  return (
    <div className={`relative ${className}`} style={{ height: typeof height === 'number' ? `${height}px` : height, width }}>
      {isLoading && (
        <div className="absolute inset-0 flex items-center justify-center bg-[#0a0a0a]">
          <div className="text-gray-400">Loading Hyperliquid chart...</div>
        </div>
      )}
      <div ref={chartContainerRef} style={{ height: '100%', width: '100%' }} />
      {currentPrice && (
        <div className="absolute top-2 right-2 bg-gray-800/80 px-3 py-1 rounded text-sm">
          <span className="text-gray-400">Live: </span>
          <span className="text-white font-mono">${currentPrice.toFixed(2)}</span>
        </div>
      )}
    </div>
  );
}
```

---

## File: client/src/components/charts/SimpleHyperliquidChart.tsx

```tsx
import { useEffect, useState } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, AreaChart, Area } from 'recharts';

interface SimpleHyperliquidChartProps {
  symbol: string;
  interval: string;
  theme?: 'dark' | 'light';
  height?: number | string;
  width?: number | string;
  className?: string;
}

interface CandleData {
  time: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume?: number;
}

export default function SimpleHyperliquidChart({
  symbol = "BTC",
  interval = "15m",
  theme = "dark",
  height = 400,
  width = "100%",
  className = ""
}: SimpleHyperliquidChartProps) {
  const [isLoading, setIsLoading] = useState(true);
  const [currentPrice, setCurrentPrice] = useState<number | null>(null);
  const [candleData, setCandleData] = useState<CandleData[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadData = async () => {
      try {
        setIsLoading(true);
        setError(null);
        
        const response = await fetch(`/api/hyperliquid/candles/${symbol}?interval=${interval}`);
        const data = await response.json();
        
        if (data.error) {
          setError(data.error);
          setIsLoading(false);
          return;
        }

        if (data.candles && data.candles.length > 0) {
          const formattedCandles = data.candles.map((candle: any, index: number) => ({
            time: candle.time,
            open: candle.open,
            high: candle.high,
            low: candle.low,
            close: candle.close,
            volume: candle.volume || Math.random() * 1000000,
            date: new Date(candle.time * 1000).toLocaleTimeString(),
            index: index
          }));
          setCandleData(formattedCandles);
          setCurrentPrice(formattedCandles[formattedCandles.length - 1].close);
        }
        
        setIsLoading(false);
      } catch (error) {
        console.error('Error loading chart data:', error);
        setError('Failed to load chart data');
        setIsLoading(false);
      }
    };

    loadData();
    const intervalId = setInterval(loadData, 5000); // Update every 5 seconds
    
    return () => clearInterval(intervalId);
  }, [symbol, interval]);

  if (error) {
    return (
      <div className={`relative ${className} bg-[#0a0a0a] border border-gray-800 rounded`} style={{ height: typeof height === 'number' ? `${height}px` : height, width }}>
        <div className="absolute inset-0 flex items-center justify-center">
          <div className="text-red-400">Error: {error}</div>
        </div>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className={`relative ${className} bg-[#0a0a0a] border border-gray-800 rounded`} style={{ height: typeof height === 'number' ? `${height}px` : height, width }}>
        <div className="absolute inset-0 flex items-center justify-center">
          <div className="text-gray-400">Loading Hyperliquid chart...</div>
        </div>
      </div>
    );
  }

  const chartTheme = {
    background: '#0a0a0a',
    grid: '#1a1a1a',
    text: '#9ca3af',
    tooltip: {
      background: '#1a1a1a',
      border: '#374151',
      text: '#ffffff'
    }
  };

  const CustomTooltip = ({ active, payload, label }: any) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload;
      return (
        <div className="bg-gray-900 border border-gray-700 rounded p-2 text-xs">
          <p className="text-gray-400">{data.date}</p>
          <p className="text-white">Open: ${data.open.toFixed(2)}</p>
          <p className="text-white">High: ${data.high.toFixed(2)}</p>
          <p className="text-white">Low: ${data.low.toFixed(2)}</p>
          <p className="text-white">Close: ${data.close.toFixed(2)}</p>
        </div>
      );
    }
    return null;
  };

  return (
    <div className={`relative ${className} bg-[#0a0a0a] border border-gray-800 rounded overflow-hidden`} style={{ height: typeof height === 'number' ? `${height}px` : height, width }}>
      {/* Chart Header */}
      <div className="absolute top-0 left-0 right-0 p-3 bg-gradient-to-b from-[#0a0a0a] to-transparent z-10">
        <div className="flex items-center justify-between">
          <div>
            <h3 className="text-base font-semibold text-white">{symbol}/USD</h3>
            <p className="text-xs text-gray-400">{interval} · Hyperliquid</p>
          </div>
          {currentPrice && (
            <div className="text-right">
              <div className="text-xl font-mono text-white">${currentPrice.toFixed(2)}</div>
              <div className="text-xs text-green-400">Live</div>
            </div>
          )}
        </div>
      </div>

      {/* Recharts Chart */}
      <div className="pt-16 pb-12 h-full">
        <ResponsiveContainer width="100%" height="100%">
          <AreaChart data={candleData} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
            <defs>
              <linearGradient id="colorPrice" x1="0" y1="0" x2="0" y2="1">
                <stop offset="5%" stopColor="#22c55e" stopOpacity={0.3}/>
                <stop offset="95%" stopColor="#22c55e" stopOpacity={0}/>
              </linearGradient>
            </defs>
            <CartesianGrid strokeDasharray="3 3" stroke={chartTheme.grid} />
            <XAxis 
              dataKey="index" 
              stroke={chartTheme.text}
              tick={{ fontSize: 10 }}
              tickFormatter={(value) => {
                if (candleData[value]) {
                  return new Date(candleData[value].time * 1000).toLocaleTimeString('en-US', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                  });
                }
                return '';
              }}
            />
            <YAxis 
              stroke={chartTheme.text}
              tick={{ fontSize: 10 }}
              domain={['dataMin - 100', 'dataMax + 100']}
              tickFormatter={(value) => `$${value.toFixed(0)}`}
            />
            <Tooltip content={<CustomTooltip />} />
            <Area 
              type="monotone" 
              dataKey="close" 
              stroke="#22c55e" 
              fillOpacity={1} 
              fill="url(#colorPrice)" 
              strokeWidth={2}
            />
          </AreaChart>
        </ResponsiveContainer>
      </div>

      {/* Chart Footer */}
      <div className="absolute bottom-0 left-0 right-0 p-3 bg-gradient-to-t from-[#0a0a0a] to-transparent">
        <div className="flex justify-between text-xs text-gray-500">
          <span>Vol: ${(Math.random() * 10000000).toFixed(0)}</span>
          <span>24h H: ${currentPrice ? (currentPrice * 1.02).toFixed(2) : '0.00'}</span>
          <span>24h L: ${currentPrice ? (currentPrice * 0.98).toFixed(2) : '0.00'}</span>
        </div>
      </div>
    </div>
  );
}
```

---

## File: client/src/components/charts/tradingview-widget.tsx

```tsx
interface TradingViewWidgetProps {
  symbol?: string;
  interval?: string;
  theme?: 'light' | 'dark';
  width?: number | string;
  height?: number | string;
  className?: string;
}

export default function TradingViewWidget({
  symbol = "BINANCE:BTCUSDT",
  interval = "D",
  theme = "light",
  width = "100%",
  height = 400,
  className = ""
}: TradingViewWidgetProps) {
  // Convert interval to TradingView format
  const getIntervalValue = (interval: string) => {
    const intervalMap: { [key: string]: string } = {
      "1m": "1",
      "5m": "5", 
      "15m": "15",
      "30m": "30",
      "1h": "60",
      "2h": "120",
      "4h": "240",
      "1d": "D",
      "1D": "D",
      "1w": "W",
      "1W": "W",
      "1M": "M",
      "1": "1",
      "5": "5", 
      "15": "15",
      "60": "60",
      "240": "240",
      "D": "D",
      "W": "W",
      "M": "M"
    };
    return intervalMap[interval] || "D";
  };

  // Create iframe URL with parameters
  const iframeUrl = `https://www.tradingview.com/widgetembed/?frameElementId=tradingview_widget&symbol=${encodeURIComponent(symbol)}&interval=${getIntervalValue(interval)}&theme=${theme}&style=1&locale=en&toolbar_bg=%23f1f3f6&enable_publishing=false&allow_symbol_change=true&details=true&hotlist=true&calendar=true`;
  
  return (
    <div className={`tradingview-widget-container ${className}`} style={{ height: typeof height === 'number' ? `${height}px` : height, width }}>
      <iframe
        src={iframeUrl}
        style={{ width: '100%', height: '100%', border: 0 }}
        allowFullScreen
        loading="lazy"
        title="TradingView Chart"
      />
    </div>
  );
}

```

---

## File: client/src/components/charts/TradingViewWidget.tsx

```tsx
import { useEffect, useRef, memo } from 'react';

interface TradingViewWidgetProps {
  symbol?: string;
  theme?: "light" | "dark";
  autosize?: boolean;
  interval?: string;
  timezone?: string;
  style?: string;
  locale?: string;
  toolbar_bg?: string;
  enable_publishing?: boolean;
  allow_symbol_change?: boolean;
  container_id?: string;
}

function TradingViewWidget({
  symbol = "BTCUSD",
  theme = "dark",
  autosize = true,
  interval = "D",
  timezone = "Etc/UTC",
  style = "1",
  locale = "en",
  toolbar_bg = "#f1f3f6",
  enable_publishing = false,
  allow_symbol_change = true,
  container_id = "tradingview_widget"
}: TradingViewWidgetProps) {
  const container = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!container.current) return;

    // Clear the container
    container.current.innerHTML = '';

    const script = document.createElement("script");
    script.src = "https://s3.tradingview.com/external-embedding/embed-widget-advanced-chart.js";
    script.type = "text/javascript";
    script.async = true;
    
    const widgetConfig = {
      "autosize": autosize,
      "symbol": symbol,
      "interval": interval,
      "timezone": timezone,
      "theme": theme,
      "style": style,
      "locale": locale,
      "toolbar_bg": toolbar_bg,
      "enable_publishing": enable_publishing,
      "allow_symbol_change": allow_symbol_change,
      "container_id": container_id,
      "height": "100%",
      "width": "100%",
      "hide_side_toolbar": false,
      "withdateranges": true,
      "details": true,
      "hotlist": true,
      "calendar": true,
      "show_popup_button": true,
      "popup_width": "1000",
      "popup_height": "650",
      "support_host": "https://www.tradingview.com"
    };

    script.textContent = JSON.stringify(widgetConfig);
    container.current.appendChild(script);

    return () => {
      if (container.current) {
        container.current.innerHTML = '';
      }
    };
  }, [symbol, theme, autosize, interval, timezone, style, locale, toolbar_bg, enable_publishing, allow_symbol_change, container_id]);

  return (
    <div className="tradingview-widget-container" ref={container} style={{ height: "100%", width: "100%" }}>
      <div id={container_id} style={{ height: "100%", width: "100%" }} />
    </div>
  );
}

export default memo(TradingViewWidget);
```

---

## File: client/src/components/CustomDomainManager.tsx

```tsx
import { useState } from "react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { CheckCircle2, Copy, ExternalLink, Loader2, X } from "lucide-react";
import { useToast } from "@/hooks/use-toast";

interface CustomDomainManagerProps {
  platformId: number;
}

interface Domain {
  id: number;
  domain: string;
  status: 'pending' | 'active';
  verificationToken: string;
  verifiedAt?: string;
}

export function CustomDomainManager({ platformId }: CustomDomainManagerProps) {
  const [domainInput, setDomainInput] = useState("");
  const [verificationInstructions, setVerificationInstructions] = useState<any>(null);
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Fetch existing domains
  const { data: domains = [], isLoading } = useQuery<Domain[]>({
    queryKey: ['/api/platforms', platformId, 'domains'],
    queryFn: async () => {
      const response = await fetch(`/api/platforms/${platformId}/domains`, {
        credentials: 'include'
      });
      if (!response.ok) throw new Error('Failed to fetch domains');
      return response.json();
    }
  });

  // Add domain mutation
  const addDomainMutation = useMutation({
    mutationFn: async (domain: string) => {
      const response = await fetch(`/api/platforms/${platformId}/domains`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ domain })
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to add domain');
      }
      return response.json();
    },
    onSuccess: (data) => {
      setVerificationInstructions(data.instructions);
      queryClient.invalidateQueries({ queryKey: ['/api/platforms', platformId, 'domains'] });
      toast({
        title: "Domain added",
        description: "Please follow the verification instructions to complete setup."
      });
      setDomainInput("");
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive"
      });
    }
  });

  // Verify domain mutation
  const verifyDomainMutation = useMutation({
    mutationFn: async (domain: string) => {
      const response = await fetch(`/api/platforms/${platformId}/domains/verify`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ domain })
      });
      if (!response.ok) throw new Error('Failed to verify domain');
      return response.json();
    },
    onSuccess: (data) => {
      if (data.verified) {
        toast({
          title: "Domain verified",
          description: "Your custom domain is now active!"
        });
        queryClient.invalidateQueries({ queryKey: ['/api/platforms', platformId, 'domains'] });
      } else {
        toast({
          title: "Verification pending",
          description: data.error || "DNS record not found yet. Please ensure the TXT record is added.",
          variant: "destructive"
        });
      }
    }
  });

  // Remove domain mutation
  const removeDomainMutation = useMutation({
    mutationFn: async (domain: string) => {
      const response = await fetch(`/api/platforms/${platformId}/domains/${domain}`, {
        method: 'DELETE',
        credentials: 'include'
      });
      if (!response.ok) throw new Error('Failed to remove domain');
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/platforms', platformId, 'domains'] });
      toast({
        title: "Domain removed",
        description: "The domain has been removed from your platform."
      });
    }
  });

  const handleAddDomain = () => {
    if (!domainInput.trim()) {
      toast({
        title: "Invalid input",
        description: "Please enter a domain name",
        variant: "destructive"
      });
      return;
    }
    
    // Basic domain validation
    const domainRegex = /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i;
    if (!domainRegex.test(domainInput)) {
      toast({
        title: "Invalid domain",
        description: "Please enter a valid domain name (e.g., example.com)",
        variant: "destructive"
      });
      return;
    }

    addDomainMutation.mutate(domainInput);
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
    toast({
      title: "Copied",
      description: "Value copied to clipboard"
    });
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Custom Domain</CardTitle>
        <CardDescription>
          Use your own domain for your trading platform
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Always show add domain input */}
        <div className="flex gap-2">
          <Input
            placeholder="yourdomain.com"
            value={domainInput}
            onChange={(e) => setDomainInput(e.target.value)}
            disabled={addDomainMutation.isPending}
          />
          <Button
            onClick={handleAddDomain}
            disabled={addDomainMutation.isPending || !domainInput}
          >
            {addDomainMutation.isPending && (
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            )}
            Add Domain
          </Button>
        </div>

        {/* Show existing domains */}
        {domains.length > 0 && (
          <div className="space-y-4">
            {domains.map((domain) => (
              <div key={domain.id} className="border rounded-lg p-4 space-y-3">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <span className="font-medium">{domain.domain}</span>
                    <Badge variant={domain.status === 'active' ? 'default' : 'secondary'}>
                      {domain.status}
                    </Badge>
                  </div>
                  <Button
                    size="sm"
                    variant="ghost"
                    onClick={() => removeDomainMutation.mutate(domain.domain)}
                    disabled={removeDomainMutation.isPending}
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>

                {domain.status === 'pending' && (
                  <div className="space-y-2">
                    <Alert>
                      <AlertTitle>DNS Verification Required</AlertTitle>
                      <AlertDescription>
                        <p className="mb-2">Add this DNS record to verify ownership:</p>
                        <div className="bg-muted p-3 rounded-md space-y-1 font-mono text-sm">
                          <div className="flex justify-between items-center">
                            <span>Type: TXT</span>
                            <Button
                              size="sm"
                              variant="ghost"
                              onClick={() => copyToClipboard('TXT')}
                            >
                              <Copy className="h-3 w-3" />
                            </Button>
                          </div>
                          <div className="flex justify-between items-center">
                            <span>Name: _liquidlab</span>
                            <Button
                              size="sm"
                              variant="ghost"
                              onClick={() => copyToClipboard('_liquidlab')}
                            >
                              <Copy className="h-3 w-3" />
                            </Button>
                          </div>
                          <div className="flex justify-between items-center">
                            <span className="break-all">Value: {domain.verificationToken}</span>
                            <Button
                              size="sm"
                              variant="ghost"
                              onClick={() => copyToClipboard(domain.verificationToken)}
                            >
                              <Copy className="h-3 w-3" />
                            </Button>
                          </div>
                        </div>
                      </AlertDescription>
                    </Alert>
                    <Button
                      size="sm"
                      onClick={() => verifyDomainMutation.mutate(domain.domain)}
                      disabled={verifyDomainMutation.isPending}
                    >
                      {verifyDomainMutation.isPending ? (
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      ) : (
                        <CheckCircle2 className="mr-2 h-4 w-4" />
                      )}
                      Verify Domain
                    </Button>
                  </div>
                )}

                {domain.status === 'active' && (
                  <div className="flex items-center gap-2 text-sm text-green-600">
                    <CheckCircle2 className="h-4 w-4" />
                    <span>Domain verified and active</span>
                    {domain.verifiedAt && (
                      <span className="text-muted-foreground">
                        (verified {new Date(domain.verifiedAt).toLocaleDateString()})
                      </span>
                    )}
                  </div>
                )}
              </div>
            ))}
          </div>
        )}

        <div className="mt-6 p-4 bg-muted rounded-lg">
          <h4 className="font-medium mb-2">How it works:</h4>
          <ol className="text-sm text-muted-foreground space-y-1 list-decimal list-inside">
            <li>Add your custom domain above</li>
            <li>Add the TXT record to your DNS provider</li>
            <li>Click "Verify Domain" after DNS propagation (usually 5-10 minutes)</li>
            <li>Configure your domain to point to our servers (we'll provide instructions)</li>
            <li>Your platform will be accessible at your custom domain!</li>
          </ol>
        </div>
      </CardContent>
    </Card>
  );
}
```

---

## File: client/src/components/dashboard/platform-performance.tsx

```tsx
import { useQuery } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { Link } from "wouter";
import { 
  BarChart3, 
  TrendingUp, 
  Users, 
  DollarSign,
  ArrowUp,
  ArrowDown,
  ExternalLink,
  Settings,
  Eye,
  Copy
} from "lucide-react";

interface PlatformPerformanceProps {
  userId: number;
}

export default function PlatformPerformance({ userId }: PlatformPerformanceProps) {
  const { data: platforms, isLoading: platformsLoading } = useQuery({
    queryKey: ['/api/platforms', userId],
    queryFn: async () => {
      const response = await fetch(`/api/platforms?userId=${userId}`);
      if (!response.ok) throw new Error('Failed to fetch platforms');
      return response.json();
    }
  });

  const { data: analytics, isLoading: analyticsLoading } = useQuery({
    queryKey: ['/api/analytics/dashboard', userId],
    queryFn: async () => {
      const response = await fetch(`/api/analytics/dashboard/${userId}`);
      if (!response.ok) throw new Error('Failed to fetch analytics');
      return response.json();
    }
  });

  const { data: user } = useQuery({
    queryKey: ['/api/users', userId],
    queryFn: async () => {
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) throw new Error('Failed to fetch user');
      return response.json();
    }
  });

  const handleCopyBuilderCode = async (code: string) => {
    try {
      await navigator.clipboard.writeText(code);
      // Could add toast notification here
    } catch (error) {
      console.error('Failed to copy builder code:', error);
    }
  };

  const formatCurrency = (amount: string | number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(typeof amount === 'string' ? parseFloat(amount) : amount);
  };

  const formatPercentage = (value: number) => {
    return `${value >= 0 ? '+' : ''}${value.toFixed(1)}%`;
  };

  if (platformsLoading || analyticsLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Platform Performance</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {[...Array(3)].map((_, i) => (
              <div key={i} className="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                <div className="flex items-center space-x-3">
                  <Skeleton className="w-3 h-3 rounded-full" />
                  <div>
                    <Skeleton className="h-4 w-32 mb-1" />
                    <Skeleton className="h-3 w-24" />
                  </div>
                </div>
                <div className="text-right">
                  <Skeleton className="h-4 w-16 mb-1" />
                  <Skeleton className="h-3 w-12" />
                </div>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center">
          <BarChart3 className="w-5 h-5 mr-2" />
          Platform Performance
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-6">
          {/* Platform List */}
          <div className="space-y-4">
            {platforms && platforms.length > 0 ? (
              platforms.map((platform: any, index: number) => {
                const mockRevenue = (Math.random() * 2000).toFixed(2);
                const mockChange = (Math.random() * 20 - 10).toFixed(1);
                const mockUsers = Math.floor(Math.random() * 1000) + 50;
                
                return (
                  <div key={platform.id} className="flex items-center justify-between p-4 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors">
                    <div className="flex items-center space-x-3">
                      <div className="w-3 h-3 bg-liquid-green rounded-full"></div>
                      <div>
                        <div className="font-medium text-gray-900">{platform.name}</div>
                        <div className="text-sm text-gray-500 flex items-center space-x-2">
                          <span>{platform.isPublished ? 'Published' : 'Draft'}</span>
                          <span>•</span>
                          <span>{mockUsers} users</span>
                        </div>
                      </div>
                    </div>
                    <div className="flex items-center space-x-4">
                      <div className="text-right">
                        <div className="font-semibold text-gray-900">{formatCurrency(mockRevenue)}</div>
                        <div className="text-sm flex items-center">
                          {parseFloat(mockChange) >= 0 ? (
                            <ArrowUp className="w-3 h-3 text-green-500 mr-1" />
                          ) : (
                            <ArrowDown className="w-3 h-3 text-red-500 mr-1" />
                          )}
                          <span className={`${parseFloat(mockChange) >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                            {formatPercentage(parseFloat(mockChange))}
                          </span>
                        </div>
                      </div>
                      <div className="flex items-center space-x-1">
                        <Badge variant={platform.isPublished ? 'default' : 'secondary'}>
                          {platform.isPublished ? 'Live' : 'Draft'}
                        </Badge>
                        <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                          <Eye className="w-4 h-4" />
                        </Button>
                        <Link href={`/builder/${platform.id}`}>
                          <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                            <Settings className="w-4 h-4" />
                          </Button>
                        </Link>
                        <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                          <ExternalLink className="w-4 h-4" />
                        </Button>
                      </div>
                    </div>
                  </div>
                );
              })
            ) : (
              <div className="text-center py-8 text-gray-500">
                <BarChart3 className="w-12 h-12 mx-auto mb-4 text-gray-300" />
                <h3 className="text-lg font-semibold text-gray-900 mb-2">No platforms yet</h3>
                <p className="text-gray-600 mb-4">
                  Create your first trading platform to start tracking performance
                </p>
                <Link href="/builder">
                  <Button className="bg-liquid-green text-white hover:bg-liquid-accent">
                    Create Your First Platform
                  </Button>
                </Link>
              </div>
            )}
          </div>
          
          {/* Builder Code Section */}
          <div className="pt-6 border-t border-gray-200">
            <h4 className="font-semibold mb-4">Builder Code Configuration</h4>
            <div className="space-y-3">
              <div className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                <div>
                  <span className="text-sm text-gray-600">Builder Code:</span>
                  <div className="font-mono text-sm bg-white px-2 py-1 rounded mt-1">
                    {user?.builderCode || 'LIQUIDLAB2024'}
                  </div>
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handleCopyBuilderCode(user?.builderCode || 'LIQUIDLAB2024')}
                >
                  <Copy className="w-4 h-4 mr-2" />
                  Copy
                </Button>
              </div>
              
              <div className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                <div>
                  <span className="text-sm text-gray-600">Commission Rate:</span>
                  <div className="font-semibold text-liquid-green text-lg">0.5%</div>
                </div>
                <Button variant="outline" size="sm">
                  Adjust
                </Button>
              </div>
              
              <div className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                <div>
                  <span className="text-sm text-gray-600">Referral Code:</span>
                  <div className="font-mono text-sm bg-white px-2 py-1 rounded mt-1">
                    {user?.referralCode || 'REF2024'}
                  </div>
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handleCopyBuilderCode(user?.referralCode || 'REF2024')}
                >
                  <Copy className="w-4 h-4 mr-2" />
                  Copy
                </Button>
              </div>
            </div>
          </div>
          
          {/* Performance Summary */}
          <div className="pt-6 border-t border-gray-200">
            <h4 className="font-semibold mb-4">Performance Summary</h4>
            <div className="grid grid-cols-2 gap-4">
              <div className="text-center p-4 bg-gray-50 rounded-lg">
                <div className="text-2xl font-bold text-liquid-green">
                  {platforms?.length || 0}
                </div>
                <div className="text-sm text-gray-600">Active Platforms</div>
              </div>
              <div className="text-center p-4 bg-gray-50 rounded-lg">
                <div className="text-2xl font-bold text-blue-600">
                  {analytics?.totalRevenue ? formatCurrency(analytics.totalRevenue) : '$0.00'}
                </div>
                <div className="text-sm text-gray-600">Total Revenue</div>
              </div>
            </div>
          </div>
          
          {/* Quick Actions */}
          <div className="pt-6 border-t border-gray-200">
            <h4 className="font-semibold mb-4">Quick Actions</h4>
            <div className="grid grid-cols-2 gap-3">
              <Link href="/builder">
                <Button variant="outline" className="w-full">
                  Create Platform
                </Button>
              </Link>
              <Link href="/analytics">
                <Button variant="outline" className="w-full">
                  View Analytics
                </Button>
              </Link>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

```

---

## File: client/src/components/dashboard/revenue-overview.tsx

```tsx
import { useQuery } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Skeleton } from "@/components/ui/skeleton";
import { RevenueData } from "@/types";
import { 
  TrendingUp, 
  DollarSign, 
  Calendar,
  ArrowUp,
  ArrowDown,
  BarChart3
} from "lucide-react";

interface RevenueOverviewProps {
  userId: number;
  period?: '7d' | '30d' | '90d';
}

export default function RevenueOverview({ userId, period = '30d' }: RevenueOverviewProps) {
  const { data: revenue, isLoading, error } = useQuery({
    queryKey: ['/api/revenue', userId, period],
    queryFn: async () => {
      const response = await fetch(`/api/revenue/${userId}?period=${period}`);
      if (!response.ok) throw new Error('Failed to fetch revenue data');
      return response.json();
    }
  });

  const { data: analytics } = useQuery({
    queryKey: ['/api/analytics/dashboard', userId],
    queryFn: async () => {
      const response = await fetch(`/api/analytics/dashboard/${userId}`);
      if (!response.ok) throw new Error('Failed to fetch analytics');
      return response.json();
    }
  });

  const formatCurrency = (amount: string | number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(typeof amount === 'string' ? parseFloat(amount) : amount);
  };

  const formatPercentage = (value: number) => {
    return `${value >= 0 ? '+' : ''}${value.toFixed(1)}%`;
  };

  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Revenue Overview</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-3 gap-4 mb-6">
            {[...Array(3)].map((_, i) => (
              <div key={i} className="text-center">
                <Skeleton className="h-6 w-16 mx-auto mb-2" />
                <Skeleton className="h-4 w-20 mx-auto" />
              </div>
            ))}
          </div>
          <Skeleton className="h-48 w-full" />
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Revenue Overview</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-center py-8 text-red-500">
            <p>Failed to load revenue data</p>
          </div>
        </CardContent>
      </Card>
    );
  }

  const totalRevenue = revenue?.reduce((sum: number, record: any) => sum + parseFloat(record.amount), 0) || 0;
  const dailyRevenue = revenue?.filter((r: any) => {
    const recordDate = new Date(r.createdAt);
    const today = new Date();
    return recordDate.toDateString() === today.toDateString();
  }).reduce((sum: number, record: any) => sum + parseFloat(record.amount), 0) || 0;

  const weeklyRevenue = revenue?.filter((r: any) => {
    const recordDate = new Date(r.createdAt);
    const weekAgo = new Date();
    weekAgo.setDate(weekAgo.getDate() - 7);
    return recordDate >= weekAgo;
  }).reduce((sum: number, record: any) => sum + parseFloat(record.amount), 0) || 0;

  // Calculate growth rates (mock data for demonstration)
  const dailyGrowth = Math.random() * 20 - 10; // -10% to +10%
  const weeklyGrowth = Math.random() * 15 - 5; // -5% to +10%
  const totalGrowth = Math.random() * 25; // 0% to +25%

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center justify-between">
          <div className="flex items-center">
            <TrendingUp className="w-5 h-5 mr-2" />
            Revenue Overview
          </div>
          <div className="flex space-x-2">
            <Button variant="outline" size="sm">
              <Calendar className="w-4 h-4 mr-2" />
              {period}
            </Button>
          </div>
        </CardTitle>
      </CardHeader>
      <CardContent>
        <Tabs defaultValue="summary" className="w-full">
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="summary">Summary</TabsTrigger>
            <TabsTrigger value="details">Details</TabsTrigger>
          </TabsList>
          
          <TabsContent value="summary" className="space-y-6">
            <div className="grid grid-cols-3 gap-4">
              <div className="text-center">
                <div className="text-2xl font-bold text-liquid-green">
                  {formatCurrency(totalRevenue)}
                </div>
                <div className="text-sm text-gray-600">Total Revenue</div>
                <div className="flex items-center justify-center mt-1">
                  {totalGrowth >= 0 ? (
                    <ArrowUp className="w-3 h-3 text-green-500 mr-1" />
                  ) : (
                    <ArrowDown className="w-3 h-3 text-red-500 mr-1" />
                  )}
                  <span className={`text-sm ${totalGrowth >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                    {formatPercentage(totalGrowth)}
                  </span>
                </div>
              </div>
              
              <div className="text-center">
                <div className="text-2xl font-bold text-blue-600">
                  {formatCurrency(weeklyRevenue)}
                </div>
                <div className="text-sm text-gray-600">Weekly Revenue</div>
                <div className="flex items-center justify-center mt-1">
                  {weeklyGrowth >= 0 ? (
                    <ArrowUp className="w-3 h-3 text-green-500 mr-1" />
                  ) : (
                    <ArrowDown className="w-3 h-3 text-red-500 mr-1" />
                  )}
                  <span className={`text-sm ${weeklyGrowth >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                    {formatPercentage(weeklyGrowth)}
                  </span>
                </div>
              </div>
              
              <div className="text-center">
                <div className="text-2xl font-bold text-purple-600">
                  {formatCurrency(dailyRevenue)}
                </div>
                <div className="text-sm text-gray-600">Daily Revenue</div>
                <div className="flex items-center justify-center mt-1">
                  {dailyGrowth >= 0 ? (
                    <ArrowUp className="w-3 h-3 text-green-500 mr-1" />
                  ) : (
                    <ArrowDown className="w-3 h-3 text-red-500 mr-1" />
                  )}
                  <span className={`text-sm ${dailyGrowth >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                    {formatPercentage(dailyGrowth)}
                  </span>
                </div>
              </div>
            </div>
            
            {/* Revenue Chart Placeholder */}
            <div className="h-48 bg-gradient-to-r from-liquid-green to-blue-500 rounded-lg opacity-20 flex items-center justify-center">
              <div className="text-center">
                <BarChart3 className="w-12 h-12 mx-auto mb-2 text-gray-500" />
                <p className="text-gray-500 text-sm">Revenue Chart</p>
              </div>
            </div>
          </TabsContent>
          
          <TabsContent value="details" className="space-y-4">
            <div className="space-y-3">
              {revenue && revenue.length > 0 ? (
                revenue.slice(0, 10).map((record: any, index: number) => (
                  <div key={index} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                    <div className="flex items-center space-x-3">
                      <div className={`w-2 h-2 rounded-full ${
                        record.type === 'builder_fee' ? 'bg-liquid-green' : 'bg-blue-500'
                      }`}></div>
                      <div>
                        <div className="font-medium">{record.type === 'builder_fee' ? 'Builder Fee' : 'Referral Fee'}</div>
                        <div className="text-sm text-gray-500">
                          {new Date(record.createdAt).toLocaleDateString()}
                        </div>
                      </div>
                    </div>
                    <div className="text-right">
                      <div className="font-bold">{formatCurrency(record.amount)}</div>
                      <Badge variant="outline" className="text-xs">
                        {record.currency}
                      </Badge>
                    </div>
                  </div>
                ))
              ) : (
                <div className="text-center py-8 text-gray-500">
                  <DollarSign className="w-12 h-12 mx-auto mb-4 text-gray-300" />
                  <p>No revenue records found</p>
                  <p className="text-sm">Start building platforms to generate revenue</p>
                </div>
              )}
            </div>
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  );
}

```

---

## File: client/src/components/layout/footer.tsx

```tsx
import { Link } from "wouter";
import { Github, Twitter, MessageCircle } from "lucide-react";
import logoImage from "@assets/Trade (6)_1752434284086.png";

export default function Footer() {
  return (
    <footer className="bg-liquid-dark text-white py-12">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="grid md:grid-cols-4 gap-8">
          <div className="md:col-span-1">
            <div className="flex items-center mb-4">
              <img 
                src={logoImage} 
                alt="LiquidLab Logo" 
                className="h-40 w-auto"
              />
            </div>
            <p className="text-gray-400 mb-4">
              Build professional trading platforms on Hyperliquid with zero coding required.
            </p>
            <div className="flex space-x-4">
              <a href="#" className="text-gray-400 hover:text-liquid-green transition-colors">
                <Twitter className="w-5 h-5" />
              </a>
              <a href="#" className="text-gray-400 hover:text-liquid-green transition-colors">
                <MessageCircle className="w-5 h-5" />
              </a>
              <a href="#" className="text-gray-400 hover:text-liquid-green transition-colors">
                <Github className="w-5 h-5" />
              </a>
            </div>
          </div>
          
          <div>
            <h4 className="font-semibold mb-4">Product</h4>
            <ul className="space-y-2 text-gray-400">
              <li>
                <Link href="/templates" className="hover:text-liquid-green transition-colors">Templates</Link>
              </li>
              <li>
                <Link href="/builder" className="hover:text-liquid-green transition-colors">Builder</Link>
              </li>
              <li>
                <Link href="/analytics" className="hover:text-liquid-green transition-colors">Analytics</Link>
              </li>
              <li>
                <Link href="/education" className="hover:text-liquid-green transition-colors">Education</Link>
              </li>
              <li>
                <a href="#" className="hover:text-liquid-green transition-colors">Integrations</a>
              </li>
            </ul>
          </div>
          
          <div>
            <h4 className="font-semibold mb-4">Resources</h4>
            <ul className="space-y-2 text-gray-400">
              <li>
                <a href="#" className="hover:text-liquid-green transition-colors">Documentation</a>
              </li>
              <li>
                <a href="#" className="hover:text-liquid-green transition-colors">API Reference</a>
              </li>
              <li>
                <a href="#" className="hover:text-liquid-green transition-colors">Community</a>
              </li>
              <li>
                <a href="#" className="hover:text-liquid-green transition-colors">Support</a>
              </li>
            </ul>
          </div>
          
          <div>
            <h4 className="font-semibold mb-4">Company</h4>
            <ul className="space-y-2 text-gray-400">
              <li>
                <a href="#" className="hover:text-liquid-green transition-colors">About</a>
              </li>
              <li>
                <a href="#" className="hover:text-liquid-green transition-colors">Blog</a>
              </li>
              <li>
                <a href="#" className="hover:text-liquid-green transition-colors">Careers</a>
              </li>
              <li>
                <a href="#" className="hover:text-liquid-green transition-colors">Privacy</a>
              </li>
            </ul>
          </div>
        </div>
        
        <div className="border-t border-gray-600 mt-8 pt-8 text-center text-gray-400">
          <p>&copy; 2025 LiquidLab. All rights reserved.</p>
        </div>
      </div>
    </footer>
  );
}

```

---

## File: client/src/components/layout/header.tsx

```tsx
import { useState, useEffect } from "react";
import { Link, useLocation } from "wouter";
import { Button } from "@/components/ui/button";
import { walletService } from "@/lib/wallet";
import { WalletState } from "@/types";
import { Wallet, Menu, X, User, LogOut } from "lucide-react";
import { useAuth } from "@/hooks/useAuth";
import { useToast } from "@/hooks/use-toast";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import logoImage from "@assets/Trade (5)_1752280465910.png";

export default function Header() {
  const [location] = useLocation();
  const [walletState, setWalletState] = useState<WalletState>(walletService.getWalletState());
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const { user, isAuthenticated, isLoading, logout } = useAuth();
  const { toast } = useToast();

  useEffect(() => {
    const unsubscribe = walletService.subscribe(setWalletState);
    return unsubscribe;
  }, []);

  const handleConnectWallet = async () => {
    try {
      await walletService.connectWallet();
    } catch (error) {
      console.error('Failed to connect wallet:', error);
    }
  };

  const handleDisconnectWallet = async () => {
    await walletService.disconnectWallet();
  };

  const formatAddress = (address: string) => {
    return `${address.slice(0, 6)}...${address.slice(-4)}`;
  };

  const handleLogout = async () => {
    try {
      await logout();
      toast({
        title: "Logged out successfully",
        description: "You have been logged out of LiquidLab",
      });
    } catch (error) {
      console.error('Logout error:', error);
      toast({
        title: "Logout failed",
        description: "Please try again.",
        variant: "destructive",
      });
    }
  };

  const isActive = (path: string) => location === path;

  return (
    <header className="bg-white shadow-sm border-b border-gray-200 sticky top-0 z-50">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex items-center justify-between h-24 md:h-36">
          {/* Logo */}
          <Link href="/" className="flex items-center">
            <img 
              src={logoImage} 
              alt="LiquidLab Logo" 
              className="h-28 md:h-32 w-auto"
            />
          </Link>
          
          {/* Desktop Navigation */}
          <nav className="hidden md:flex space-x-8">
            <Link href="/templates" className={`font-medium transition-colors ${
              isActive('/templates') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
            }`}>
              Templates
            </Link>
            <Link href="/pricing" className={`font-medium transition-colors ${
              isActive('/pricing') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
            }`}>
              Pricing
            </Link>
            <Link href="/education" className={`font-medium transition-colors ${
              isActive('/education') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
            }`}>
              Education
            </Link>
            <Link href="/builder" className={`font-medium transition-colors ${
              isActive('/builder') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
            }`}>
              Builder
            </Link>
            <Link href="/example" className={`font-medium transition-colors ${
              isActive('/example') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
            }`}>
              Example
            </Link>
            <Link href="/enterprise" className={`font-medium transition-colors ${
              isActive('/enterprise') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
            }`}>
              Enterprise
            </Link>
            {isAuthenticated && (
              <>
                <Link href="/analytics" className={`font-medium transition-colors ${
                  isActive('/analytics') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
                }`}>
                  Analytics
                </Link>
                <Link href="/dashboard" className={`font-medium transition-colors ${
                  isActive('/dashboard') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
                }`}>
                  Dashboard
                </Link>
              </>
            )}
          </nav>
          
          {/* Authentication */}
          <div className="flex items-center space-x-4">
            {isAuthenticated ? (
              <>
                {/* User Menu */}
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="outline" className="flex items-center space-x-2">
                      <User className="w-4 h-4" />
                      <span className="hidden md:inline">{user?.username || 'User'}</span>
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end">
                    <DropdownMenuItem onClick={handleLogout}>
                      <LogOut className="w-4 h-4 mr-2" />
                      Sign Out
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </>
            ) : (
              <>
                <Link href="/login">
                  <Button variant="outline">Sign In</Button>
                </Link>
                <Link href="/signup">
                  <Button className="bg-liquid-green text-white hover:bg-liquid-accent transition-colors">
                    Sign Up
                  </Button>
                </Link>
              </>
            )}

            {/* Mobile menu button */}
            <button
              className="md:hidden p-2 rounded-lg hover:bg-gray-100 transition-colors"
              onClick={() => setIsMenuOpen(!isMenuOpen)}
              aria-label={isMenuOpen ? "Close menu" : "Open menu"}
            >
              {isMenuOpen ? <X className="w-6 h-6" /> : <Menu className="w-6 h-6" />}
            </button>
          </div>
        </div>

        {/* Mobile Navigation */}
        {isMenuOpen && (
          <div className="md:hidden border-t border-gray-200 py-4">
            <nav className="flex flex-col space-y-2">
              <Link href="/templates" className={`block px-3 py-2 text-base font-medium transition-colors ${
                isActive('/templates') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
              }`}>
                Templates
              </Link>
              <Link href="/pricing" className={`block px-3 py-2 text-base font-medium transition-colors ${
                isActive('/pricing') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
              }`}>
                Pricing
              </Link>
              <Link href="/education" className={`block px-3 py-2 text-base font-medium transition-colors ${
                isActive('/education') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
              }`}>
                Education
              </Link>
              <Link href="/builder" className={`block px-3 py-2 text-base font-medium transition-colors ${
                isActive('/builder') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
              }`}>
                Builder
              </Link>
              <Link href="/example" className={`block px-3 py-2 text-base font-medium transition-colors ${
                isActive('/example') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
              }`}>
                Example
              </Link>
              <Link href="/enterprise" className={`block px-3 py-2 text-base font-medium transition-colors ${
                isActive('/enterprise') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
              }`}>
                Enterprise
              </Link>
              {isAuthenticated && (
                <>
                  <Link href="/analytics" className={`block px-3 py-2 text-base font-medium transition-colors ${
                    isActive('/analytics') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
                  }`}>
                    Analytics
                  </Link>
                  <Link href="/dashboard" className={`block px-3 py-2 text-base font-medium transition-colors ${
                    isActive('/dashboard') ? 'text-liquid-green' : 'text-gray-600 hover:text-liquid-green'
                  }`}>
                    Dashboard
                  </Link>
                </>
              )}
            </nav>
            
            {walletState.isConnected && (
              <div className="mt-4 pt-4 border-t border-gray-200">
                <div className="flex items-center space-x-2 px-3 py-2 bg-gray-100 rounded-lg">
                  <Wallet className="w-4 h-4 text-gray-500" />
                  <span className="text-sm text-gray-600">
                    {formatAddress(walletState.address!)}
                  </span>
                  <span className="text-sm text-gray-500">
                    {walletState.balance} ETH
                  </span>
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    </header>
  );
}

```

---

## File: client/src/components/MoonPayButton.tsx

```tsx
import { useState, useEffect } from "react";
import { CreditCard } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { usePrivy } from "@privy-io/react-auth";

interface MoonPayButtonProps {
  platformId?: number;
  className?: string;
}

export function MoonPayButton({ platformId, className }: MoonPayButtonProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [moonpayConfig, setMoonpayConfig] = useState<{ apiKey: string } | null>(null);
  const { authenticated, user } = usePrivy();
  
  // Get wallet address from connected wallet
  const walletAddress = user?.wallet?.address || 
    (user?.linkedAccounts?.find(account => account.type === 'wallet')?.address) || 
    '';
  
  // Fetch MoonPay configuration from backend
  useEffect(() => {
    fetch('/api/moonpay/config')
      .then(res => res.json())
      .then(data => setMoonpayConfig(data))
      .catch(err => console.error('Failed to fetch MoonPay config:', err));
  }, []);
  
  // MoonPay widget URL with LiquidLab configuration
  // Note: In production, you'll need a real MoonPay API key
  const moonpayUrl = moonpayConfig?.apiKey ? 
    `https://widget.moonpay.com?apiKey=${moonpayConfig.apiKey}&currencyCode=usdc&walletAddress=${walletAddress}&colorCode=%237084FF&showWalletAddressForm=true&theme=dark&language=en` : 
    null;
  
  const handleBuyClick = () => {
    if (!moonpayConfig?.apiKey) {
      console.error('MoonPay not configured');
      return;
    }
    
    setIsOpen(true);
    
    // Track the MoonPay widget opening
    if (platformId) {
      console.log('MoonPay widget opened for platform:', platformId);
    }
  };

  // Message handler for MoonPay events
  useEffect(() => {
    const handleMessage = async (event: MessageEvent) => {
      // Verify origin is from MoonPay
      if (event.origin !== 'https://widget.moonpay.com') return;
      
      // Handle transaction completion
      if (event.data?.type === 'transaction-completed' && platformId) {
        const { transactionId, cryptoAmount, fiatAmount, currency } = event.data.payload;
        
        // Record the transaction for revenue sharing
        try {
          await fetch('/api/moonpay/record', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              platformId,
              transactionId,
              purchaseAmount: fiatAmount,
              cryptoAmount,
              currency
            })
          });
        } catch (error) {
          console.error('Failed to record MoonPay transaction:', error);
        }
      }
    };
    
    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  }, [platformId]);

  return (
    <>
      <button
        onClick={handleBuyClick}
        disabled={!moonpayConfig?.apiKey}
        className={`h-8 px-4 text-sm font-medium text-[#1dd1a1] bg-[#0a0a0a] border border-[#1dd1a1]/20 rounded hover:bg-[#1dd1a1]/10 hover:border-[#1dd1a1]/40 transition-all duration-200 disabled:opacity-50 ${className}`}
      >
        Buy Crypto
      </button>

      <Dialog open={isOpen} onOpenChange={setIsOpen}>
        <DialogContent className="sm:max-w-[600px] h-[700px] p-0">
          <DialogHeader className="p-4 pb-0">
            <DialogTitle>Buy Crypto with MoonPay</DialogTitle>
          </DialogHeader>
          <div className="flex-1 overflow-hidden rounded-b-lg">
            {moonpayConfig?.environment === 'test' ? (
              <div className="flex flex-col items-center justify-center h-full p-8 text-center">
                <CreditCard className="w-16 h-16 text-purple-500 mb-4" />
                <h3 className="text-xl font-semibold mb-2">MoonPay Integration Ready</h3>
                <p className="text-gray-400 mb-4">
                  To enable real crypto purchases, you'll need to configure a production MoonPay API key.
                </p>
                <p className="text-sm text-gray-500">
                  Contact LiquidLab support to get your MoonPay affiliate API key set up.
                </p>
              </div>
            ) : moonpayUrl ? (
              <iframe
                src={moonpayUrl}
                className="w-full h-full border-0"
                title="MoonPay Widget"
                allow="accelerometer; autoplay; camera; gyroscope; payment"
              />
            ) : (
              <div className="flex items-center justify-center h-full">
                <p className="text-gray-400">Loading MoonPay...</p>
              </div>
            )}
          </div>
        </DialogContent>
      </Dialog>
    </>
  );
}
```

---

## File: client/src/components/PlatformVerificationBadge.tsx

```tsx
import { Shield, CheckCircle, AlertCircle, Copy, Check } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Button } from "@/components/ui/button";
import { useState } from "react";

interface PlatformVerificationBadgeProps {
  platformId: number;
  platformName: string;
  isVerified?: boolean;
  compactMode?: boolean;
  verificationCode?: string;
  className?: string;
}

export function PlatformVerificationBadge({ 
  platformId, 
  platformName,
  isVerified = true,
  compactMode = false,
  verificationCode,
  className
}: PlatformVerificationBadgeProps) {
  console.log('PlatformVerificationBadge props:', { platformId, platformName, verificationCode });
  const [copied, setCopied] = useState(false);

  const handleCopyCode = async () => {
    if (verificationCode) {
      try {
        await navigator.clipboard.writeText(verificationCode);
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    }
  };

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button 
          variant="ghost" 
          size={compactMode ? "sm" : "default"}
          className={`${compactMode ? 'gap-1 h-7 px-2 text-xs' : 'gap-2'} hover:bg-teal-50 dark:hover:bg-teal-950/20`}
        >
          {isVerified ? (
            <>
              <Shield className={`${compactMode ? 'w-3 h-3' : 'w-4 h-4'} text-teal-600 dark:text-teal-400`} />
              {!compactMode && <span>LiquidLab Verified</span>}
              <CheckCircle className={`${compactMode ? 'w-2.5 h-2.5' : 'w-3 h-3'} text-teal-600 dark:text-teal-400`} />
            </>
          ) : (
            <>
              <AlertCircle className={`${compactMode ? 'w-3 h-3' : 'w-4 h-4'} text-yellow-600 dark:text-yellow-400`} />
              {!compactMode && <span>Verification Pending</span>}
            </>
          )}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-80">
        <div className="space-y-3">
          <div className="flex items-center gap-2">
            <Shield className="w-5 h-5 text-teal-600 dark:text-teal-400" />
            <h4 className="font-semibold">Platform Verification</h4>
          </div>
          
          <div className="space-y-2 text-sm">
            <div className="flex items-center justify-between">
              <span className="text-gray-600 dark:text-gray-400">Platform Name:</span>
              <span className="font-medium">{platformName}</span>
            </div>
            {verificationCode ? (
              <div className="flex items-center justify-between">
                <span className="text-gray-600 dark:text-gray-400">Verification Code:</span>
                <div className="flex items-center gap-1">
                  <Badge variant="outline" className="font-mono">{verificationCode}</Badge>
                  <Button
                    size="sm"
                    variant="ghost"
                    onClick={handleCopyCode}
                    className="h-6 w-6 p-0 hover:bg-gray-100 dark:hover:bg-gray-800"
                    title="Copy verification code"
                  >
                    {copied ? (
                      <Check className="h-3 w-3 text-teal-600" />
                    ) : (
                      <Copy className="h-3 w-3" />
                    )}
                  </Button>
                </div>
              </div>
            ) : (
              <div className="flex items-center justify-between">
                <span className="text-gray-600 dark:text-gray-400">Platform ID:</span>
                <Badge variant="outline">#{platformId}</Badge>
              </div>
            )}
            <div className="flex items-center justify-between">
              <span className="text-gray-600 dark:text-gray-400">Status:</span>
              <Badge variant={isVerified ? "default" : "secondary"}>
                {isVerified ? "Verified" : "Pending"}
              </Badge>
            </div>
          </div>
          
          <div className="pt-2 border-t space-y-1 text-xs text-gray-600 dark:text-gray-400">
            <p>✓ Built on LiquidLab infrastructure</p>
            <p>✓ Direct Hyperliquid integration</p>
            <p>✓ Non-custodial wallet connection</p>
            <p>✓ Transparent fee structure</p>
          </div>
          
          <a 
            href="https://liquidlab.trade/verify"
            target="_blank"
            rel="noopener noreferrer"
            className="text-xs text-blue-600 dark:text-blue-400 hover:underline"
          >
            Verify on LiquidLab.trade →
          </a>
        </div>
      </PopoverContent>
    </Popover>
  );
}
```

---

## File: client/src/components/PrivyProvider.tsx

```tsx
import { PrivyProvider as Privy } from '@privy-io/react-auth';
import { useEffect, useState } from 'react';

interface PrivyProviderProps {
  children: React.ReactNode;
}

export function PrivyProvider({ children }: PrivyProviderProps) {
  const [appId, setAppId] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Fetch Privy config from backend
    console.log('Fetching Privy config...');
    fetch('/api/privy/config')
      .then(res => res.json())
      .then(data => {
        console.log('Privy config received:', data);
        if (data.appId) {
          setAppId(data.appId);
        } else {
          console.error('Privy App ID not found in config');
        }
      })
      .catch(err => {
        console.error('Error fetching Privy config:', err);
      })
      .finally(() => {
        setLoading(false);
      });
  }, []);

  if (loading) {
    console.log('Privy loading...');
    return (
      <div className="min-h-screen bg-[#0a0a0a] flex items-center justify-center">
        <div className="text-gray-400">Initializing wallet connection...</div>
      </div>
    );
  }
  
  if (!appId) {
    console.error('Privy App ID not found');
    return (
      <div className="min-h-screen bg-[#0a0a0a] flex items-center justify-center">
        <div className="text-red-400">Error: Wallet configuration not found</div>
      </div>
    );
  }

  console.log('Initializing Privy with appId:', appId);
  
  return (
    <Privy
      appId={appId}
      config={{
        appearance: {
          theme: 'dark',
          accentColor: '#00d4ff',
          logo: '/liquidlab-logo.png',
        },
        loginMethods: ['wallet', 'email', 'sms'],
        embeddedWallets: {
          createOnLogin: 'all-users',
        },
        defaultChain: {
          id: 42161,
          name: 'Arbitrum One',
          network: 'arbitrum',
          nativeCurrency: {
            decimals: 18,
            name: 'Ether',
            symbol: 'ETH',
          },
          rpcUrls: {
            default: {
              http: ['https://arb1.arbitrum.io/rpc'],
            },
          },
        },
        supportedChains: [
          {
            id: 42161,
            name: 'Arbitrum One',
            network: 'arbitrum',
            nativeCurrency: {
              decimals: 18,
              name: 'Ether',
              symbol: 'ETH',
            },
            rpcUrls: {
              default: {
                http: ['https://arb1.arbitrum.io/rpc'],
              },
            },
          },
          {
            id: 137,
            name: 'Polygon',
            network: 'polygon',
            nativeCurrency: {
              decimals: 18,
              name: 'MATIC',
              symbol: 'MATIC',
            },
            rpcUrls: {
              default: {
                http: ['https://polygon-rpc.com'],
              },
            },
          },
        ],
      }}
    >
      {children}
    </Privy>
  );
}
```

---

## File: client/src/components/PWAInstaller.tsx

```tsx
import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Download, X } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';

interface BeforeInstallPromptEvent extends Event {
  prompt: () => Promise<void>;
  userChoice: Promise<{ outcome: 'accepted' | 'dismissed' }>;
}

interface PWAInstallerProps {
  platformName?: string;
}

export function PWAInstaller({ platformName = "LiquidLab" }: PWAInstallerProps) {
  const [deferredPrompt, setDeferredPrompt] = useState<BeforeInstallPromptEvent | null>(null);
  const [showInstallBanner, setShowInstallBanner] = useState(false);
  const [isInstalled, setIsInstalled] = useState(false);
  const { toast } = useToast();

  useEffect(() => {
    // Check if app is already installed
    if (window.matchMedia('(display-mode: standalone)').matches) {
      setIsInstalled(true);
      return;
    }

    // Register service worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/service-worker.js')
        .then((registration) => {
          console.log('Service Worker registered:', registration);
          
          // Check for updates periodically
          setInterval(() => {
            registration.update();
          }, 60 * 60 * 1000); // Check every hour
          
          // SECURITY: Implement cache expiration check
          setInterval(() => {
            if (navigator.serviceWorker.controller) {
              navigator.serviceWorker.controller.postMessage({
                type: 'CACHE_EXPIRATION_CHECK'
              });
            }
          }, 30 * 60 * 1000); // Check every 30 minutes
        })
        .catch((error) => {
          console.error('Service Worker registration failed:', error);
        });
    }
    
    // SECURITY: Clear service worker cache on logout
    const handleLogout = () => {
      if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({
          type: 'CLEAR_CACHE'
        });
      }
    };
    
    // Listen for logout events
    window.addEventListener('user-logout', handleLogout);

    // Listen for install prompt
    const handleBeforeInstallPrompt = (e: Event) => {
      e.preventDefault();
      setDeferredPrompt(e as BeforeInstallPromptEvent);
      
      // Show install banner after a delay
      setTimeout(() => {
        setShowInstallBanner(true);
      }, 30000); // Show after 30 seconds
    };

    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);

    // Listen for app installed
    window.addEventListener('appinstalled', () => {
      setIsInstalled(true);
      setShowInstallBanner(false);
      toast({
        title: "App Installed!",
        description: `${platformName} has been added to your home screen.`,
      });
    });

    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
      window.removeEventListener('user-logout', handleLogout);
    };
  }, [toast, platformName]);

  const handleInstallClick = async () => {
    if (!deferredPrompt) return;

    try {
      await deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      
      if (outcome === 'accepted') {
        console.log('User accepted the install prompt');
      } else {
        console.log('User dismissed the install prompt');
      }
      
      setDeferredPrompt(null);
      setShowInstallBanner(false);
    } catch (error) {
      console.error('Error showing install prompt:', error);
    }
  };

  const handleDismiss = () => {
    setShowInstallBanner(false);
    // Don't show again for 7 days
    setTimeout(() => {
      if (deferredPrompt) {
        setShowInstallBanner(true);
      }
    }, 7 * 24 * 60 * 60 * 1000);
  };

  if (!showInstallBanner || isInstalled) {
    return null;
  }

  return (
    <div className="fixed bottom-4 left-4 right-4 md:left-auto md:right-4 md:w-96 bg-[#0d0d0d] border border-gray-800 rounded-lg shadow-lg p-4 z-50">
      <div className="flex items-start justify-between">
        <div className="flex items-start space-x-3">
          <Download className="w-5 h-5 text-[#1dd1a1] mt-0.5" />
          <div>
            <h3 className="font-semibold text-white">Install {platformName}</h3>
            <p className="text-sm text-gray-400 mt-1">
              Add to your home screen for the best trading experience
            </p>
          </div>
        </div>
        <button
          onClick={handleDismiss}
          className="text-gray-500 hover:text-gray-300 transition-colors"
        >
          <X className="w-4 h-4" />
        </button>
      </div>
      <div className="mt-4 flex space-x-2">
        <Button
          onClick={handleInstallClick}
          className="flex-1 bg-[#1dd1a1] hover:bg-[#1ab894] text-black"
        >
          Install App
        </Button>
        <Button
          onClick={handleDismiss}
          variant="outline"
          className="flex-1 border-gray-700 hover:bg-gray-800 text-gray-900 dark:text-gray-200 hover:text-white"
        >
          Not Now
        </Button>
      </div>
    </div>
  );
}
```

---

## File: client/src/components/RevenueCalculator.tsx

```tsx
import { useState } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Calculator, DollarSign, TrendingUp } from "lucide-react";

export function RevenueCalculator() {
  const [spotVolume, setSpotVolume] = useState("");
  const [perpVolume, setPerpVolume] = useState("");
  const [moonpayVolume, setMoonpayVolume] = useState("");

  // Fee rates
  const SPOT_FEE_RATE = 0.002; // 0.2%
  const PERP_FEE_RATE = 0.001; // 0.1%
  const MOONPAY_AFFILIATE_RATE = 0.01; // 1%
  
  // Platform owner shares
  const TRADING_FEE_SHARE = 0.7; // 70% to platform owner
  const MOONPAY_SHARE = 0.5; // 50% to platform owner

  // Calculate revenues
  const spotRevenue = parseFloat(spotVolume || "0") * SPOT_FEE_RATE * TRADING_FEE_SHARE;
  const perpRevenue = parseFloat(perpVolume || "0") * PERP_FEE_RATE * TRADING_FEE_SHARE;
  const moonpayRevenue = parseFloat(moonpayVolume || "0") * MOONPAY_AFFILIATE_RATE * MOONPAY_SHARE;
  const totalRevenue = spotRevenue + perpRevenue + moonpayRevenue;

  // LiquidLab's share
  const liquidLabTrading = (spotRevenue + perpRevenue) * (0.3 / 0.7); // 30% share
  const liquidLabMoonpay = moonpayRevenue; // 50% share (same as platform owner)
  const liquidLabTotal = liquidLabTrading + liquidLabMoonpay;

  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(value);
  };

  return (
    <Card className="w-full max-w-lg mx-auto">
      <CardHeader className="pb-3">
        <CardTitle className="flex items-center gap-2 text-lg">
          <Calculator className="w-4 h-4" />
          Revenue Calculator
        </CardTitle>
        <CardDescription className="text-sm">
          Calculate your monthly earnings
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4 pb-4">
        {/* Input Section - Compact Grid */}
        <div className="grid grid-cols-1 gap-3">
          <div>
            <div className="flex items-center justify-between mb-1">
              <Label htmlFor="spot-volume" className="text-xs">Spot Volume</Label>
              <span className="text-[10px] text-gray-500">0.2% • 70% yours</span>
            </div>
            <div className="relative">
              <DollarSign className="absolute left-2 top-1/2 transform -translate-y-1/2 w-3 h-3 text-gray-500" />
              <Input
                id="spot-volume"
                type="number"
                placeholder="1,000,000"
                value={spotVolume}
                onChange={(e) => setSpotVolume(e.target.value)}
                className="pl-7 h-8 text-sm"
              />
            </div>
          </div>

          <div>
            <div className="flex items-center justify-between mb-1">
              <Label htmlFor="perp-volume" className="text-xs">Perp Volume</Label>
              <span className="text-[10px] text-gray-500">0.1% • 70% yours</span>
            </div>
            <div className="relative">
              <DollarSign className="absolute left-2 top-1/2 transform -translate-y-1/2 w-3 h-3 text-gray-500" />
              <Input
                id="perp-volume"
                type="number"
                placeholder="5,000,000"
                value={perpVolume}
                onChange={(e) => setPerpVolume(e.target.value)}
                className="pl-7 h-8 text-sm"
              />
            </div>
          </div>

          <div>
            <div className="flex items-center justify-between mb-1">
              <Label htmlFor="moonpay-volume" className="text-xs">MoonPay Purchases</Label>
              <span className="text-[10px] text-gray-500">1% • 50% yours</span>
            </div>
            <div className="relative">
              <DollarSign className="absolute left-2 top-1/2 transform -translate-y-1/2 w-3 h-3 text-gray-500" />
              <Input
                id="moonpay-volume"
                type="number"
                placeholder="100,000"
                value={moonpayVolume}
                onChange={(e) => setMoonpayVolume(e.target.value)}
                className="pl-7 h-8 text-sm"
              />
            </div>
          </div>
        </div>

        {/* Results Section - Compact */}
        <div className="border-t pt-3">
          <div className="grid grid-cols-2 gap-x-4 gap-y-2 text-xs">
            <div className="flex justify-between">
              <span className="text-gray-600">Spot</span>
              <span className="font-medium">{formatCurrency(spotRevenue)}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-gray-600">Perp</span>
              <span className="font-medium">{formatCurrency(perpRevenue)}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-gray-600">MoonPay</span>
              <span className="font-medium">{formatCurrency(moonpayRevenue)}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-gray-600">Annual</span>
              <span className="font-medium">{formatCurrency(totalRevenue * 12)}</span>
            </div>
          </div>
          
          <div className="mt-3 pt-3 border-t flex justify-between items-center">
            <span className="text-sm font-semibold">Monthly Total</span>
            <span className="text-xl font-bold text-[#1dd1a1]">{formatCurrency(totalRevenue)}</span>
          </div>
        </div>

        {/* Revenue Split Info - Tiny Text */}
        <div className="text-[10px] text-gray-500 pt-2 border-t">
          <p>LiquidLab share: {formatCurrency(liquidLabTotal)}/mo</p>
        </div>
      </CardContent>
    </Card>
  );
}
```

---

## File: client/src/components/SecurityFooter.tsx

```tsx
import { Shield, Lock, ExternalLink, FileCheck } from "lucide-react";

interface SecurityFooterProps {
  platformName: string;
  platformId: number;
  builderCode: string;
  verificationCode?: string;
}

export function SecurityFooter({ platformName, platformId, builderCode, verificationCode }: SecurityFooterProps) {
  return (
    <footer className="bg-[#0a0a0a] text-white py-8 mt-auto">
      <div className="container mx-auto px-4">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
          {/* Security Info */}
          <div>
            <h3 className="font-semibold mb-3 flex items-center gap-2">
              <Shield className="w-4 h-4" />
              Security
            </h3>
            <ul className="space-y-2 text-sm text-gray-400">
              <li className="flex items-center gap-2">
                <Lock className="w-3 h-3" />
                Non-custodial trading
              </li>
              <li className="flex items-center gap-2">
                <FileCheck className="w-3 h-3" />
                Audited smart contracts
              </li>
              <li className="flex items-center gap-2">
                <Shield className="w-3 h-3" />
                SSL encrypted
              </li>
            </ul>
          </div>

          {/* Platform Info */}
          <div>
            <h3 className="font-semibold mb-3">Platform Details</h3>
            <ul className="space-y-2 text-sm text-gray-400">
              <li>Platform: {platformName}</li>
              {verificationCode && <li>Verification Code: {verificationCode}</li>}
              <li>Builder Code: {builderCode}</li>
              <li>
                <a 
                  href="https://liquidlab.trade/verify"
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 flex items-center gap-1"
                >
                  Verify Platform
                  <ExternalLink className="w-3 h-3" />
                </a>
              </li>
            </ul>
          </div>

          {/* Trust & Compliance */}
          <div>
            <h3 className="font-semibold mb-3">Trust & Compliance</h3>
            <ul className="space-y-2 text-sm text-gray-400">
              <li>✓ LiquidLab Verified</li>
              <li>✓ Privy Wallet Security</li>
              <li>✓ Hyperliquid Official API</li>
              <li>✓ Transparent Fee Structure</li>
            </ul>
          </div>

          {/* Support */}
          <div>
            <h3 className="font-semibold mb-3">Need Help?</h3>
            <ul className="space-y-2 text-sm text-gray-400">
              <li>
                <a 
                  href="https://docs.liquidlab.trade/security"
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300"
                >
                  Security Documentation
                </a>
              </li>
              <li>
                <a 
                  href="https://liquidlab.trade/report"
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300"
                >
                  Report Suspicious Activity
                </a>
              </li>
              <li>
                <a 
                  href="https://status.liquidlab.trade"
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300"
                >
                  System Status
                </a>
              </li>
            </ul>
          </div>
        </div>

        <div className="mt-8 pt-8 border-t border-gray-800 text-center text-sm text-gray-500">
          <p>
            Powered by{" "}
            <a 
              href="https://liquidlab.trade" 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-blue-400 hover:text-blue-300"
            >
              LiquidLab
            </a>
            {" "}• Trading on{" "}
            <a 
              href="https://hyperliquid.xyz" 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-blue-400 hover:text-blue-300"
            >
              Hyperliquid DEX
            </a>
            {" "}• Secured by{" "}
            <a 
              href="https://privy.io" 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-blue-400 hover:text-blue-300"
            >
              Privy
            </a>
          </p>
          
          {/* Powered by Hyperliquid logo */}
          <div className="mt-4">
            <img 
              src="/powered-by-hyperliquid.png" 
              alt="Powered by Hyperliquid" 
              className="h-8 mx-auto opacity-60 hover:opacity-100 transition-opacity"
            />
          </div>
        </div>
      </div>
    </footer>
  );
}
```

---

## File: client/src/components/templates/template-card.tsx

```tsx
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Link } from "wouter";
import { Template } from "@/types";
import { BarChart3, Smartphone, Minimize2, TrendingUp, Star } from "lucide-react";

interface TemplateCardProps {
  template: Template;
}

export default function TemplateCard({ template }: TemplateCardProps) {
  const getCategoryIcon = (category: string) => {
    switch (category) {
      case 'Professional':
        return <BarChart3 className="w-5 h-5" />;
      case 'Mobile First':
        return <Smartphone className="w-5 h-5" />;
      case 'Minimal':
        return <Minimize2 className="w-5 h-5" />;
      case 'Analytics':
        return <TrendingUp className="w-5 h-5" />;
      default:
        return <BarChart3 className="w-5 h-5" />;
    }
  };

  const getTemplatePreview = () => {
    const colors = {
      'Professional': 'bg-gray-900 text-white',
      'Mobile First': 'bg-indigo-900 text-white',
      'Minimal': 'bg-gray-100 text-gray-900 border-2 border-gray-200',
      'Analytics': 'bg-blue-900 text-white',
      'DeFi': 'bg-green-900 text-white'
    };

    return (
      <div className={`${colors[template.category as keyof typeof colors]} p-6 h-48 relative`}>
        <div className="absolute top-4 right-4 bg-liquid-green text-white px-2 py-1 rounded text-xs font-semibold">
          {template.category}
        </div>
        <div className="flex items-center justify-between mb-4">
          <h3 className="font-semibold">{template.name}</h3>
          <div className="text-green-400 font-mono text-sm">$67,845</div>
        </div>
        <div className="grid grid-cols-3 gap-2 mb-4">
          <div className="bg-gray-800 h-8 rounded opacity-50"></div>
          <div className="bg-gray-800 h-8 rounded opacity-50"></div>
          <div className="bg-gray-800 h-8 rounded opacity-50"></div>
        </div>
        <div className="h-16 bg-gradient-to-r from-green-400 to-blue-400 rounded opacity-30"></div>
      </div>
    );
  };

  return (
    <Card className="overflow-hidden card-hover">
      {getTemplatePreview()}
      <CardContent className="p-6">
        <div className="flex items-center justify-between mb-2">
          <h3 className="font-semibold text-lg">{template.name}</h3>
          <div className="flex items-center text-liquid-green">
            {getCategoryIcon(template.category)}
          </div>
        </div>
        <p className="text-gray-600 mb-4">{template.description}</p>
        
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-2">
            <span className="text-liquid-green font-semibold">Free</span>
            <Badge variant="outline">{template.category}</Badge>
          </div>
          <Link href={`/builder/${template.id}`}>
            <Button className="bg-liquid-green text-white hover:bg-liquid-accent">
              Use Template
            </Button>
          </Link>
        </div>
      </CardContent>
    </Card>
  );
}

```

---

## File: client/src/components/templates/template-preview.tsx

```tsx
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Eye, BarChart3, Smartphone, Minimize2, TrendingUp, X } from "lucide-react";
import { Link } from "wouter";

interface TemplatePreviewProps {
  template: any;
  children: React.ReactNode;
}

export default function TemplatePreview({ template, children }: TemplatePreviewProps) {
  const getFullPreview = () => {
    const colors = {
      'Professional': 'bg-gray-900 text-white',
      'Mobile First': 'bg-indigo-900 text-white',
      'Minimal': 'bg-gray-100 text-gray-900',
      'Analytics': 'bg-blue-900 text-white',
      'DeFi': 'bg-green-900 text-white'
    };

    return (
      <div className={`${colors[template.category as keyof typeof colors]} p-8 rounded-lg min-h-[400px] relative`}>
        {/* Header */}
        <div className="flex items-center justify-between mb-6">
          <div className="flex items-center space-x-4">
            <h2 className="text-xl font-bold">{template.name}</h2>
            <Badge className="bg-liquid-green text-white">{template.category}</Badge>
          </div>
          <div className="text-green-400 font-mono text-lg">$67,845.32</div>
        </div>

        {/* Mock Trading Interface */}
        <div className="grid grid-cols-12 gap-4 h-80">
          {/* Left Panel - Market Data */}
          <div className="col-span-3 space-y-4">
            <div className="bg-black/20 p-4 rounded">
              <h3 className="text-sm font-semibold mb-2">Market Data</h3>
              <div className="space-y-2">
                <div className="flex justify-between text-xs">
                  <span>ETH/USD</span>
                  <span className="text-green-400">+2.34%</span>
                </div>
                <div className="flex justify-between text-xs">
                  <span>BTC/USD</span>
                  <span className="text-red-400">-1.23%</span>
                </div>
                <div className="flex justify-between text-xs">
                  <span>SOL/USD</span>
                  <span className="text-green-400">+5.67%</span>
                </div>
              </div>
            </div>
            
            <div className="bg-black/20 p-4 rounded">
              <h3 className="text-sm font-semibold mb-2">Order Book</h3>
              <div className="space-y-1">
                <div className="flex justify-between text-xs">
                  <span className="text-red-400">67,845</span>
                  <span>0.234</span>
                </div>
                <div className="flex justify-between text-xs">
                  <span className="text-red-400">67,840</span>
                  <span>0.156</span>
                </div>
                <div className="flex justify-between text-xs">
                  <span className="text-green-400">67,850</span>
                  <span>0.891</span>
                </div>
              </div>
            </div>
          </div>

          {/* Center - Chart */}
          <div className="col-span-6 bg-black/20 p-4 rounded">
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-sm font-semibold">ETH/USD Chart</h3>
              <div className="flex space-x-2">
                <span className="text-xs bg-liquid-green px-2 py-1 rounded">1H</span>
                <span className="text-xs bg-gray-600 px-2 py-1 rounded">4H</span>
                <span className="text-xs bg-gray-600 px-2 py-1 rounded">1D</span>
              </div>
            </div>
            <div className="h-48 bg-gradient-to-br from-green-500/20 to-blue-500/20 rounded flex items-center justify-center">
              <div className="text-center">
                <BarChart3 className="w-12 h-12 mx-auto mb-2 opacity-50" />
                <p className="text-xs opacity-70">TradingView Chart</p>
              </div>
            </div>
          </div>

          {/* Right Panel - Trading */}
          <div className="col-span-3 space-y-4">
            <div className="bg-black/20 p-4 rounded">
              <h3 className="text-sm font-semibold mb-2">Trade</h3>
              <div className="space-y-2">
                <div className="flex space-x-2">
                  <button className="flex-1 bg-green-600 text-white py-1 px-2 rounded text-xs">Buy</button>
                  <button className="flex-1 bg-red-600 text-white py-1 px-2 rounded text-xs">Sell</button>
                </div>
                <div className="text-xs">
                  <div className="flex justify-between mb-1">
                    <span>Amount:</span>
                    <span>0.5 ETH</span>
                  </div>
                  <div className="flex justify-between mb-1">
                    <span>Price:</span>
                    <span>$67,845</span>
                  </div>
                  <div className="flex justify-between">
                    <span>Total:</span>
                    <span>$33,922.50</span>
                  </div>
                </div>
              </div>
            </div>

            <div className="bg-black/20 p-4 rounded">
              <h3 className="text-sm font-semibold mb-2">Portfolio</h3>
              <div className="space-y-1 text-xs">
                <div className="flex justify-between">
                  <span>ETH</span>
                  <span>2.34</span>
                </div>
                <div className="flex justify-between">
                  <span>BTC</span>
                  <span>0.045</span>
                </div>
                <div className="flex justify-between">
                  <span>USDC</span>
                  <span>1,247.89</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Footer Stats */}
        <div className="mt-6 pt-4 border-t border-white/20">
          <div className="grid grid-cols-4 gap-4 text-center">
            <div>
              <div className="text-lg font-bold text-green-400">+12.34%</div>
              <div className="text-xs opacity-70">24h Change</div>
            </div>
            <div>
              <div className="text-lg font-bold">$2.4M</div>
              <div className="text-xs opacity-70">Volume</div>
            </div>
            <div>
              <div className="text-lg font-bold">1,247</div>
              <div className="text-xs opacity-70">Active Users</div>
            </div>
            <div>
              <div className="text-lg font-bold">$156.78</div>
              <div className="text-xs opacity-70">Avg Trade</div>
            </div>
          </div>
        </div>
      </div>
    );
  };

  return (
    <Dialog>
      <DialogTrigger asChild>
        {children}
      </DialogTrigger>
      <DialogContent className="max-w-6xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center justify-between">
            <span>{template.name} - Preview</span>
            <div className="flex items-center space-x-2">
              <Link href={`/builder/${template.id}`}>
                <Button className="bg-liquid-green text-white hover:bg-liquid-accent">
                  Use This Template
                </Button>
              </Link>
            </div>
          </DialogTitle>
        </DialogHeader>
        
        <div className="space-y-4">
          <div className="flex flex-wrap gap-2">
            {template.features.map((feature: string, index: number) => (
              <Badge key={index} variant="secondary">
                {feature}
              </Badge>
            ))}
          </div>
          
          <p className="text-gray-600">{template.description}</p>
          
          {getFullPreview()}
          
          <div className="text-sm text-gray-500 text-center">
            This is a preview of the template. The actual trading platform will have live data and full functionality.
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

---

## File: client/src/components/TestWalletInput.tsx

```tsx
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';

export function TestWalletInput() {
  const [walletAddress, setWalletAddress] = useState('');
  const [email, setEmail] = useState('');
  const [loading, setLoading] = useState(false);
  const { toast } = useToast();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!walletAddress || !email) {
      toast({
        title: "Error",
        description: "Please enter both wallet address and email",
        variant: "destructive"
      });
      return;
    }

    setLoading(true);
    try {
      await apiRequest('/api/privy/wallet', {
        method: 'POST',
        body: JSON.stringify({
          walletAddress,
          email
        })
      });
      
      toast({
        title: "Success",
        description: "Wallet address saved! You can now place trades with builder fee tracking.",
      });
      
      setWalletAddress('');
      setEmail('');
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to save wallet address",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader>
        <CardTitle>Test Wallet Connection</CardTitle>
        <CardDescription>
          Manually enter your wallet address for testing. Use this if Privy is not working due to domain restrictions.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="text-sm font-medium">Wallet Address</label>
            <Input
              type="text"
              placeholder="0x..."
              value={walletAddress}
              onChange={(e) => setWalletAddress(e.target.value)}
              className="mt-1"
            />
          </div>
          <div>
            <label className="text-sm font-medium">Email</label>
            <Input
              type="email"
              placeholder="your@email.com"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="mt-1"
            />
          </div>
          <Button type="submit" className="w-full" disabled={loading}>
            {loading ? "Saving..." : "Save Wallet Address"}
          </Button>
        </form>
        <div className="mt-4 text-xs text-muted-foreground">
          <p className="font-semibold mb-1">How to test:</p>
          <ol className="list-decimal list-inside space-y-1">
            <li>Enter your Hyperliquid wallet address above</li>
            <li>Go to Hyperliquid and place a trade</li>
            <li>Trades will automatically include builder fee tracking</li>
            <li>Wait up to 10 minutes for processing</li>
            <li>Check your dashboard for earnings</li>
          </ol>
        </div>
      </CardContent>
    </Card>
  );
}
```

---

## File: client/src/components/TraderAnalytics.tsx

```tsx
import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { Card, CardHeader, CardTitle, CardContent, CardDescription } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useToast } from "@/hooks/use-toast";
import { TrendingUp, Users, Trophy, DollarSign, Activity, Trash2, Edit } from "lucide-react";

interface TraderActivity {
  id: number;
  platformId: number;
  walletAddress: string;
  totalVolume: string;
  totalFees: string;
  tradeCount: number;
  averageTradeSize: string;
  firstTradeAt: string;
  lastTradeAt: string;
  currentTier?: IncentiveTier;
}

interface IncentiveTier {
  id: number;
  platformId: number;
  name: string;
  minVolume: string;
  rewardType: string;
  rewardValue: string;
  description: string;
  isActive: boolean;
}

interface TraderAnalyticsProps {
  platformId: number;
}

export function TraderAnalytics({ platformId }: TraderAnalyticsProps) {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [sortBy, setSortBy] = useState<'volume' | 'fees' | 'trades'>('volume');
  const [showTierDialog, setShowTierDialog] = useState(false);
  const [editingTier, setEditingTier] = useState<IncentiveTier | null>(null);
  const [tierForm, setTierForm] = useState({
    name: "",
    minVolume: "",
    rewardType: "fee_discount",
    rewardValue: "",
    description: ""
  });

  // Fetch top traders
  const { data: topTraders, isLoading: loadingTraders } = useQuery({
    queryKey: [`/api/platforms/${platformId}/traders/top`],
    enabled: !!platformId
  });

  // Fetch all traders with sorting
  const { data: allTraders } = useQuery({
    queryKey: [`/api/platforms/${platformId}/traders`, sortBy],
    queryFn: async () => {
      const response = await fetch(`/api/platforms/${platformId}/traders?sortBy=${sortBy}`);
      if (!response.ok) throw new Error('Failed to fetch traders');
      return response.json();
    },
    enabled: !!platformId
  });

  // Fetch incentive tiers
  const { data: incentiveTiers, isLoading: loadingTiers } = useQuery({
    queryKey: [`/api/platforms/${platformId}/incentive-tiers`],
    enabled: !!platformId
  });

  // Create incentive tier mutation
  const createTierMutation = useMutation({
    mutationFn: async (data: typeof tierForm) => {
      return apiRequest(`/api/platforms/${platformId}/incentive-tiers`, {
        method: 'POST',
        body: JSON.stringify(data)
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/platforms/${platformId}/incentive-tiers`] });
      toast({
        title: "Success",
        description: "Incentive tier created successfully"
      });
      setShowTierDialog(false);
      resetTierForm();
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive"
      });
    }
  });

  // Update incentive tier mutation
  const updateTierMutation = useMutation({
    mutationFn: async ({ tierId, data }: { tierId: number; data: Partial<IncentiveTier> }) => {
      return apiRequest(`/api/platforms/${platformId}/incentive-tiers/${tierId}`, {
        method: 'PUT',
        body: JSON.stringify(data)
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/platforms/${platformId}/incentive-tiers`] });
      toast({
        title: "Success",
        description: "Incentive tier updated successfully"
      });
      setShowTierDialog(false);
      setEditingTier(null);
      resetTierForm();
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive"
      });
    }
  });

  // Delete incentive tier mutation
  const deleteTierMutation = useMutation({
    mutationFn: async (tierId: number) => {
      return apiRequest(`/api/platforms/${platformId}/incentive-tiers/${tierId}`, {
        method: 'DELETE'
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: [`/api/platforms/${platformId}/incentive-tiers`] });
      toast({
        title: "Success",
        description: "Incentive tier deleted successfully"
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive"
      });
    }
  });

  const resetTierForm = () => {
    setTierForm({
      name: "",
      minVolume: "",
      rewardType: "fee_discount",
      rewardValue: "",
      description: ""
    });
  };

  const handleEditTier = (tier: IncentiveTier) => {
    setEditingTier(tier);
    setTierForm({
      name: tier.name,
      minVolume: tier.minVolume,
      rewardType: tier.rewardType,
      rewardValue: tier.rewardValue,
      description: tier.description || ""
    });
    setShowTierDialog(true);
  };

  const handleSaveTier = () => {
    if (editingTier) {
      updateTierMutation.mutate({
        tierId: editingTier.id,
        data: tierForm
      });
    } else {
      createTierMutation.mutate(tierForm);
    }
  };

  const formatVolume = (volume: string) => {
    const num = parseFloat(volume);
    if (num >= 1000000) return `$${(num / 1000000).toFixed(2)}M`;
    if (num >= 1000) return `$${(num / 1000).toFixed(2)}K`;
    return `$${num.toFixed(2)}`;
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });
  };

  if (loadingTraders || loadingTiers) {
    return <div className="flex items-center justify-center h-64">Loading trader analytics...</div>;
  }

  return (
    <div className="space-y-6">
      {/* Summary Cards */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium">Total Traders</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex items-center gap-2">
              <Users className="h-5 w-5 text-muted-foreground" />
              <p className="text-2xl font-bold">{allTraders?.length || 0}</p>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium">Total Volume</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex items-center gap-2">
              <TrendingUp className="h-5 w-5 text-muted-foreground" />
              <p className="text-2xl font-bold">
                {formatVolume(
                  allTraders?.reduce((sum: number, t: TraderActivity) => 
                    sum + parseFloat(t.totalVolume), 0
                  ).toString() || "0"
                )}
              </p>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium">Total Fees Generated</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex items-center gap-2">
              <DollarSign className="h-5 w-5 text-muted-foreground" />
              <p className="text-2xl font-bold">
                {formatVolume(
                  allTraders?.reduce((sum: number, t: TraderActivity) => 
                    sum + parseFloat(t.totalFees), 0
                  ).toString() || "0"
                )}
              </p>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium">Avg Trade Size</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex items-center gap-2">
              <Activity className="h-5 w-5 text-muted-foreground" />
              <p className="text-2xl font-bold">
                {formatVolume(
                  allTraders?.length > 0 
                    ? (allTraders.reduce((sum: number, t: TraderActivity) => 
                        sum + parseFloat(t.averageTradeSize), 0
                      ) / allTraders.length).toString()
                    : "0"
                )}
              </p>
            </div>
          </CardContent>
        </Card>
      </div>

      <Tabs defaultValue="traders" className="space-y-4">
        <TabsList>
          <TabsTrigger value="traders">Top Traders</TabsTrigger>
          <TabsTrigger value="incentives">Incentive Tiers</TabsTrigger>
        </TabsList>

        <TabsContent value="traders" className="space-y-4">
          <Card>
            <CardHeader>
              <div className="flex justify-between items-center">
                <div>
                  <CardTitle>Top Traders</CardTitle>
                  <CardDescription>Your platform's most active traders</CardDescription>
                </div>
                <Select value={sortBy} onValueChange={(value: any) => setSortBy(value)}>
                  <SelectTrigger className="w-40">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="volume">By Volume</SelectItem>
                    <SelectItem value="fees">By Fees</SelectItem>
                    <SelectItem value="trades">By Trades</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                {topTraders?.map((trader: TraderActivity, index: number) => (
                  <div key={trader.walletAddress} className="flex items-center justify-between p-3 border rounded-lg">
                    <div className="flex items-center gap-3">
                      <div className="flex items-center justify-center w-8 h-8 rounded-full bg-primary/10 text-primary font-bold">
                        {index + 1}
                      </div>
                      <div>
                        <p className="font-mono text-sm">{trader.walletAddress}</p>
                        <p className="text-xs text-muted-foreground">
                          {trader.tradeCount} trades • First: {formatDate(trader.firstTradeAt)}
                        </p>
                      </div>
                    </div>
                    <div className="text-right">
                      <p className="font-semibold">{formatVolume(trader.totalVolume)}</p>
                      <p className="text-xs text-muted-foreground">
                        Fees: {formatVolume(trader.totalFees)}
                      </p>
                      {trader.currentTier && (
                        <p className="text-xs text-primary font-medium">
                          {trader.currentTier.name}
                        </p>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="incentives" className="space-y-4">
          <Card>
            <CardHeader>
              <div className="flex justify-between items-center">
                <div>
                  <CardTitle>Incentive Tiers</CardTitle>
                  <CardDescription>Reward your traders based on their volume</CardDescription>
                </div>
                <Button onClick={() => {
                  setEditingTier(null);
                  resetTierForm();
                  setShowTierDialog(true);
                }}>
                  Create Tier
                </Button>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                {incentiveTiers?.length === 0 && (
                  <p className="text-center text-muted-foreground py-8">
                    No incentive tiers created yet. Create your first tier to reward loyal traders.
                  </p>
                )}
                {incentiveTiers?.map((tier: IncentiveTier) => (
                  <div key={tier.id} className="flex items-center justify-between p-4 border rounded-lg">
                    <div>
                      <h4 className="font-semibold flex items-center gap-2">
                        <Trophy className="h-4 w-4 text-primary" />
                        {tier.name}
                      </h4>
                      <p className="text-sm text-muted-foreground">
                        Min Volume: {formatVolume(tier.minVolume)} • 
                        {tier.rewardType === 'fee_discount' && ` ${tier.rewardValue}% fee discount`}
                        {tier.rewardType === 'rebate' && ` ${tier.rewardValue}% rebate`}
                        {tier.rewardType === 'custom' && ` ${tier.rewardValue}`}
                      </p>
                      {tier.description && (
                        <p className="text-sm text-muted-foreground mt-1">{tier.description}</p>
                      )}
                    </div>
                    <div className="flex gap-2">
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => handleEditTier(tier)}
                      >
                        <Edit className="h-4 w-4" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => deleteTierMutation.mutate(tier.id)}
                      >
                        <Trash2 className="h-4 w-4 text-destructive" />
                      </Button>
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>

      {/* Create/Edit Tier Dialog */}
      <Dialog open={showTierDialog} onOpenChange={setShowTierDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>
              {editingTier ? 'Edit Incentive Tier' : 'Create Incentive Tier'}
            </DialogTitle>
          </DialogHeader>
          <div className="space-y-4">
            <div>
              <Label htmlFor="name">Tier Name</Label>
              <Input
                id="name"
                value={tierForm.name}
                onChange={(e) => setTierForm({ ...tierForm, name: e.target.value })}
                placeholder="e.g., Bronze Trader"
              />
            </div>
            <div>
              <Label htmlFor="minVolume">Minimum Volume (USD)</Label>
              <Input
                id="minVolume"
                type="number"
                value={tierForm.minVolume}
                onChange={(e) => setTierForm({ ...tierForm, minVolume: e.target.value })}
                placeholder="e.g., 10000"
              />
            </div>
            <div>
              <Label htmlFor="rewardType">Reward Type</Label>
              <Select 
                value={tierForm.rewardType} 
                onValueChange={(value) => setTierForm({ ...tierForm, rewardType: value })}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="fee_discount">Fee Discount</SelectItem>
                  <SelectItem value="rebate">Volume Rebate</SelectItem>
                  <SelectItem value="custom">Custom Reward</SelectItem>
                </SelectContent>
              </Select>
            </div>
            <div>
              <Label htmlFor="rewardValue">
                {tierForm.rewardType === 'fee_discount' && 'Discount Percentage'}
                {tierForm.rewardType === 'rebate' && 'Rebate Percentage'}
                {tierForm.rewardType === 'custom' && 'Reward Details'}
              </Label>
              <Input
                id="rewardValue"
                value={tierForm.rewardValue}
                onChange={(e) => setTierForm({ ...tierForm, rewardValue: e.target.value })}
                placeholder={tierForm.rewardType === 'custom' ? 'e.g., Priority support' : 'e.g., 10'}
              />
            </div>
            <div>
              <Label htmlFor="description">Description (Optional)</Label>
              <Input
                id="description"
                value={tierForm.description}
                onChange={(e) => setTierForm({ ...tierForm, description: e.target.value })}
                placeholder="Additional benefits or details"
              />
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowTierDialog(false)}>
              Cancel
            </Button>
            <Button onClick={handleSaveTier}>
              {editingTier ? 'Update' : 'Create'}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}
```

---

## File: client/src/components/trading/AIMarketAssistant.tsx

```tsx
import { useState, useRef, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card } from '@/components/ui/card';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Send, Bot, User } from 'lucide-react';

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

interface AIMarketAssistantProps {
  selectedMarket?: string;
  currentPrice?: number;
}

export function AIMarketAssistant({ selectedMarket = 'BTC', currentPrice }: AIMarketAssistantProps) {
  const [messages, setMessages] = useState<Message[]>([
    {
      id: '1',
      role: 'assistant',
      content: 'Ask me about market analysis or strategies',
      timestamp: new Date()
    }
  ]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const scrollAreaRef = useRef<HTMLDivElement>(null);

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    if (scrollAreaRef.current) {
      scrollAreaRef.current.scrollTop = scrollAreaRef.current.scrollHeight;
    }
  }, [messages]);

  const handleSubmit = async () => {
    if (!input.trim() || isLoading) return;

    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content: input,
      timestamp: new Date()
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      const response = await fetch('/api/ai/market-chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: input,
          context: {
            market: selectedMarket,
            currentPrice: currentPrice,
          }
        })
      });

      const data = await response.json();
      
      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: data.response || 'Sorry, I encountered an error. Please try again.',
        timestamp: new Date()
      };

      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: 'Sorry, I\'m having trouble connecting. Please try again later.',
        timestamp: new Date()
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit();
    }
  };

  return (
    <Card className="bg-gray-900 border-gray-800 h-full flex flex-col">
      <div className="p-2 border-b border-gray-800 text-[#00030a]">
        <h3 className="text-xs font-semibold flex items-center gap-1.5 text-[#ffffff]">
          <Bot className="h-3.5 w-3.5 text-blue-400" />
          AI Assistant
        </h3>
      </div>
      <ScrollArea className="flex-1 p-2" ref={scrollAreaRef}>
        <div className="space-y-2">
          {messages.map((message) => (
            <div
              key={message.id}
              className={`flex gap-2 ${
                message.role === 'user' ? 'justify-end' : 'justify-start'
              }`}
            >
              {message.role === 'assistant' && (
                <div className="flex-shrink-0 w-6 h-6 rounded-full bg-blue-500/20 flex items-center justify-center">
                  <Bot className="h-3 w-3 text-blue-400" />
                </div>
              )}
              <div
                className={`max-w-[80%] rounded-lg p-2 text-xs ${
                  message.role === 'user'
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-800 text-gray-200'
                }`}
              >
                <p className="whitespace-pre-wrap">{message.content}</p>
                <p className="text-[10px] opacity-60 mt-1">
                  {message.timestamp.toLocaleTimeString([], { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                  })}
                </p>
              </div>
              {message.role === 'user' && (
                <div className="flex-shrink-0 w-6 h-6 rounded-full bg-gray-600 flex items-center justify-center">
                  <User className="h-3 w-3 text-white" />
                </div>
              )}
            </div>
          ))}
          {isLoading && (
            <div className="flex gap-2 justify-start">
              <div className="flex-shrink-0 w-6 h-6 rounded-full bg-blue-500/20 flex items-center justify-center">
                <Bot className="h-3 w-3 text-blue-400" />
              </div>
              <div className="bg-gray-800 rounded-lg p-2 text-xs text-gray-400">
                <div className="flex space-x-1">
                  <div className="w-1.5 h-1.5 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></div>
                  <div className="w-1.5 h-1.5 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></div>
                  <div className="w-1.5 h-1.5 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></div>
                </div>
              </div>
            </div>
          )}
        </div>
      </ScrollArea>
      <div className="p-2 border-t border-gray-800">
        <div className="flex gap-2">
          <Input
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder="Ask about market trends, analysis..."
            className="flex-1 bg-gray-800 border-gray-700 text-xs h-8"
            disabled={isLoading}
          />
          <Button
            onClick={handleSubmit}
            disabled={!input.trim() || isLoading}
            size="sm"
            className="bg-blue-600 hover:bg-blue-700 h-8 px-3"
          >
            <Send className="h-3 w-3" />
          </Button>
        </div>
      </div>
    </Card>
  );
}
```

---

## File: client/src/components/trading/HyperliquidDeposit.tsx

```tsx
import React, { useState, useEffect } from 'react';
import { usePrivy } from '@privy-io/react-auth';
import { useQuery, useMutation } from '@tanstack/react-query';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Loader2, AlertCircle, CheckCircle2, Wallet } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { queryClient } from '@/lib/queryClient';

const ARBITRUM_CHAIN_ID = 42161;

export function HyperliquidDeposit() {
  const { authenticated, ready, getEthersProvider, user } = usePrivy();
  const { toast } = useToast();
  const [depositAmount, setDepositAmount] = useState('');
  const [withdrawAmount, setWithdrawAmount] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);

  // Get validated contract addresses from backend
  const { data: depositConfig, isLoading: configLoading } = useQuery({
    queryKey: ['/api/deposit/config'],
    enabled: authenticated,
  });

  // Get user balances
  const { data: balances, isLoading: balancesLoading } = useQuery({
    queryKey: [`/api/hyperliquid/balances/${user?.wallet?.address}`],
    enabled: !!user?.wallet?.address && authenticated,
    refetchInterval: 5000, // Refresh every 5 seconds
  });

  // Get Arbitrum USDC balance
  const { data: arbitrumBalance, isLoading: arbitrumLoading } = useQuery({
    queryKey: ['arbitrum-usdc-balance', user?.wallet?.address],
    queryFn: async () => {
      if (!user?.wallet?.address) return '0';
      
      const provider = await getEthersProvider();
      if (!provider) return '0';
      
      const signer = provider.getSigner();
      const { ethers } = await import('ethers');
      
      // USDC contract ABI (minimal for balanceOf)
      const usdcAbi = [
        'function balanceOf(address account) view returns (uint256)',
        'function decimals() view returns (uint8)'
      ];
      
      if (!depositConfig?.arbitrumUSDC) return '0';
      const usdcContract = new ethers.Contract(depositConfig.arbitrumUSDC, usdcAbi, signer);
      const balance = await usdcContract.balanceOf(user.wallet.address);
      const decimals = await usdcContract.decimals();
      
      return ethers.utils.formatUnits(balance, decimals);
    },
    enabled: !!user?.wallet?.address && authenticated,
    refetchInterval: 5000,
  });

  // Deposit mutation
  const depositMutation = useMutation({
    mutationFn: async (amount: string) => {
      const provider = await getEthersProvider();
      if (!provider) throw new Error('No wallet provider');
      
      const signer = provider.getSigner();
      const { ethers } = await import('ethers');
      
      // Check network
      const network = await provider.getNetwork();
      if (network.chainId !== ARBITRUM_CHAIN_ID) {
        throw new Error('Please switch to Arbitrum network');
      }
      
      // USDC contract ABI
      const usdcAbi = [
        'function transfer(address to, uint256 amount) returns (bool)',
        'function decimals() view returns (uint8)'
      ];
      
      if (!depositConfig?.arbitrumUSDC || !depositConfig?.hyperliquidBridge) {
        throw new Error('Contract addresses not loaded');
      }
      
      const usdcContract = new ethers.Contract(depositConfig.arbitrumUSDC, usdcAbi, signer);
      const decimals = await usdcContract.decimals();
      const amountWei = ethers.utils.parseUnits(amount, decimals);
      
      // Send USDC to bridge
      const tx = await usdcContract.transfer(depositConfig.hyperliquidBridge, amountWei);
      
      // Wait for confirmation
      const receipt = await tx.wait();
      
      return {
        txHash: receipt.transactionHash,
        amount: amount
      };
    },
    onSuccess: (data) => {
      toast({
        title: "Deposit Initiated",
        description: `Deposited ${data.amount} USDC. It will appear in your Hyperliquid account in ~1 minute.`,
      });
      setDepositAmount('');
      
      // Refresh balances after a delay
      setTimeout(() => {
        queryClient.invalidateQueries({ queryKey: ['arbitrum-usdc-balance'] });
        queryClient.invalidateQueries({ queryKey: ['/api/hyperliquid/balances'] });
      }, 3000);
    },
    onError: (error: Error) => {
      toast({
        title: "Deposit Failed",
        description: error.message,
        variant: "destructive",
      });
    }
  });

  // Withdraw mutation
  const withdrawMutation = useMutation({
    mutationFn: async (amount: string) => {
      const response = await fetch('/api/hyperliquid/withdraw', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          amount: amount,
          destination: user?.wallet?.address
        }),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Withdrawal failed');
      }
      
      return response.json();
    },
    onSuccess: (data) => {
      toast({
        title: "Withdrawal Initiated",
        description: `Withdrawing ${withdrawAmount} USDC. It will arrive in 3-4 minutes.`,
      });
      setWithdrawAmount('');
      
      // Refresh balances
      queryClient.invalidateQueries({ queryKey: ['/api/hyperliquid/balances'] });
    },
    onError: (error: Error) => {
      toast({
        title: "Withdrawal Failed",
        description: error.message,
        variant: "destructive",
      });
    }
  });

  const handleDeposit = async () => {
    const amount = parseFloat(depositAmount);
    
    if (!amount || amount < 5) {
      toast({
        title: "Invalid Amount",
        description: "Minimum deposit is 5 USDC",
        variant: "destructive",
      });
      return;
    }
    
    if (parseFloat(arbitrumBalance || '0') < amount) {
      toast({
        title: "Insufficient Balance",
        description: "Not enough USDC in your Arbitrum wallet",
        variant: "destructive",
      });
      return;
    }
    
    setIsProcessing(true);
    try {
      await depositMutation.mutateAsync(depositAmount);
    } finally {
      setIsProcessing(false);
    }
  };

  const handleWithdraw = async () => {
    const amount = parseFloat(withdrawAmount);
    
    if (!amount || amount < 2) {
      toast({
        title: "Invalid Amount",
        description: "Minimum withdrawal is 2 USDC (1 USDC fee)",
        variant: "destructive",
      });
      return;
    }
    
    const availableBalance = parseFloat(balances?.withdrawable || '0');
    if (availableBalance < amount) {
      toast({
        title: "Insufficient Balance",
        description: "Not enough withdrawable USDC in your Hyperliquid account",
        variant: "destructive",
      });
      return;
    }
    
    setIsProcessing(true);
    try {
      await withdrawMutation.mutateAsync(withdrawAmount);
    } finally {
      setIsProcessing(false);
    }
  };

  if (!authenticated) {
    return (
      <Card className="bg-[#0d0d0d] border-gray-800">
        <CardContent className="pt-6">
          <Alert>
            <Wallet className="h-4 w-4" />
            <AlertDescription>
              Connect your wallet to deposit or withdraw funds
            </AlertDescription>
          </Alert>
        </CardContent>
      </Card>
    );
  }

  const hyperliquidBalance = balances?.withdrawable || '0';
  const totalAccountValue = balances?.accountValue || '0';

  return (
    <Card className="bg-[#0d0d0d] border-gray-800">
      <CardHeader>
        <CardTitle className="text-white">Manage Funds</CardTitle>
        <CardDescription className="text-gray-400">
          Deposit USDC to start trading or withdraw your profits
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Balance Display */}
        <div className="grid grid-cols-2 gap-4 mb-6">
          <div className="bg-[#1a1a1a] p-4 rounded">
            <p className="text-xs text-gray-400 mb-1">Arbitrum USDC</p>
            <p className="text-lg font-semibold text-white">
              {arbitrumLoading ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                `$${parseFloat(arbitrumBalance || '0').toFixed(2)}`
              )}
            </p>
          </div>
          <div className="bg-[#1a1a1a] p-4 rounded">
            <p className="text-xs text-gray-400 mb-1">Hyperliquid Balance</p>
            <p className="text-lg font-semibold text-white">
              {balancesLoading ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                `$${parseFloat(hyperliquidBalance).toFixed(2)}`
              )}
            </p>
            <p className="text-xs text-gray-500 mt-1">
              Total: ${parseFloat(totalAccountValue).toFixed(2)}
            </p>
          </div>
        </div>

        {/* Security Notice */}
        <Alert className="mb-4 bg-blue-950/20 border-blue-800/50">
          <AlertCircle className="h-4 w-4 text-blue-400" />
          <AlertDescription className="text-sm text-blue-200">
            <strong className="text-white">Important:</strong> Your funds are deposited directly to Hyperliquid DEX, not to this trading platform. 
            You maintain full control and can always access your funds at{' '}
            <a href="https://app.hyperliquid.xyz" target="_blank" rel="noopener noreferrer" className="underline">
              hyperliquid.xyz
            </a>
            . This platform only facilitates the deposit process.
          </AlertDescription>
        </Alert>

        <Tabs defaultValue="deposit" className="w-full">
          <TabsList className="grid w-full grid-cols-2 bg-[#1a1a1a]">
            <TabsTrigger value="deposit" className="data-[state=active]:bg-[#0d0d0d]">
              Deposit
            </TabsTrigger>
            <TabsTrigger value="withdraw" className="data-[state=active]:bg-[#0d0d0d]">
              Withdraw
            </TabsTrigger>
          </TabsList>
          
          <TabsContent value="deposit" className="space-y-4">
            <Alert>
              <CheckCircle2 className="h-4 w-4 text-green-400" />
              <AlertDescription>
                <strong>Non-Custodial:</strong> Funds go directly to your Hyperliquid account via official bridge contract.
                Processing time: ~1 minute. Minimum: 5 USDC.
              </AlertDescription>
            </Alert>
            
            <div>
              <Label htmlFor="deposit-amount" className="text-white">Amount (USDC)</Label>
              <Input
                id="deposit-amount"
                type="number"
                step="0.01"
                min="5"
                placeholder="Enter amount"
                value={depositAmount}
                onChange={(e) => setDepositAmount(e.target.value)}
                className="bg-[#1a1a1a] border-gray-800 text-white"
              />
            </div>
            
            <Button
              onClick={handleDeposit}
              disabled={isProcessing || depositMutation.isPending}
              className="w-full bg-[#1dd1a1] hover:bg-[#17a882] text-black"
            >
              {isProcessing || depositMutation.isPending ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Processing...
                </>
              ) : (
                <>
                  <CheckCircle2 className="mr-2 h-4 w-4" />
                  Deposit to Hyperliquid
                </>
              )}
            </Button>
          </TabsContent>
          
          <TabsContent value="withdraw" className="space-y-4">
            <Alert className="bg-yellow-950/20 border-yellow-800/50">
              <AlertCircle className="h-4 w-4 text-yellow-400" />
              <AlertDescription className="text-yellow-200">
                <strong className="text-white">Withdrawals:</strong> To withdraw your funds, please visit{' '}
                <a href="https://app.hyperliquid.xyz" target="_blank" rel="noopener noreferrer" className="underline">
                  hyperliquid.xyz
                </a>
                {' '}directly. Your funds are always under your control on the Hyperliquid DEX.
              </AlertDescription>
            </Alert>
            
            <div className="bg-[#1a1a1a] p-6 rounded-lg text-center">
              <Wallet className="h-12 w-12 mx-auto mb-4 text-gray-400" />
              <h4 className="text-lg font-semibold text-white mb-2">Direct Control</h4>
              <p className="text-sm text-gray-400 mb-4">
                Since your funds are on Hyperliquid DEX, you can withdraw them directly from their platform.
                This ensures you always have full control over your assets.
              </p>
              <Button 
                onClick={() => window.open('https://app.hyperliquid.xyz', '_blank')}
                className="bg-[#1dd1a1] hover:bg-[#17a882] text-black"
              >
                Go to Hyperliquid
              </Button>
            </div>
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  );
}
```

---

## File: client/src/components/trading/HyperliquidLightweightChart.tsx

```tsx
import React, { useEffect, useRef } from 'react';
import { createChart, ColorType, IChartApi, ISeriesApi } from 'lightweight-charts';
import { useQuery } from '@tanstack/react-query';

interface HyperliquidLightweightChartProps {
  symbol: string;
  interval?: string;
}

interface CandleData {
  time: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume?: number;
}

export const HyperliquidLightweightChart: React.FC<HyperliquidLightweightChartProps> = ({ 
  symbol, 
  interval = '15m' 
}) => {
  const chartContainerRef = useRef<HTMLDivElement>(null);
  const chartRef = useRef<IChartApi | null>(null);
  const candlestickSeriesRef = useRef<ISeriesApi<"Candlestick"> | null>(null);

  // Fetch historical candles from Hyperliquid
  const { data: candleResponse } = useQuery({
    queryKey: [`/api/hyperliquid/candles/${symbol}?interval=${interval}`],
    refetchInterval: 5000, // Update every 5 seconds
  });

  // Initialize chart
  useEffect(() => {
    if (!chartContainerRef.current) return;

    try {
      const chartOptions = {
        width: chartContainerRef.current.clientWidth,
        height: chartContainerRef.current.clientHeight,
        layout: {
          background: { type: ColorType.Solid, color: '#0a0a0a' },
          textColor: '#d1d4dc',
        },
        grid: {
          vertLines: { color: '#1a1a1a' },
          horzLines: { color: '#1a1a1a' },
        },
        crosshair: {
          mode: 1,
        },
        rightPriceScale: {
          borderColor: '#2a2a2a',
        },
        timeScale: {
          borderColor: '#2a2a2a',
          timeVisible: true,
          secondsVisible: false,
        },
      };

      const chart = createChart(chartContainerRef.current, chartOptions);
      
      const candlestickSeries = chart.addCandlestickSeries({
        upColor: '#26a69a',
        downColor: '#ef5350',
        borderVisible: false,
        wickUpColor: '#26a69a',
        wickDownColor: '#ef5350',
      });

      chartRef.current = chart;
      candlestickSeriesRef.current = candlestickSeries;

      // Handle resize
      const handleResize = () => {
        if (chartContainerRef.current && chart) {
          chart.applyOptions({ 
            width: chartContainerRef.current.clientWidth,
            height: chartContainerRef.current.clientHeight 
          });
        }
      };

      window.addEventListener('resize', handleResize);

      return () => {
        window.removeEventListener('resize', handleResize);
        if (chart) {
          chart.remove();
        }
      };
    } catch (error) {
      console.error('Error initializing chart:', error);
    }
  }, []);

  // Update chart data
  useEffect(() => {
    if (!candlestickSeriesRef.current || !candleResponse || !candleResponse.candles) return;

    try {
      // Convert data to lightweight-charts format
      const formattedData = candleResponse.candles.map((candle: any) => ({
        time: Math.floor(candle.time / 1000),
        open: parseFloat(candle.open),
        high: parseFloat(candle.high),
        low: parseFloat(candle.low),
        close: parseFloat(candle.close),
      })).sort((a: any, b: any) => a.time - b.time);

      if (formattedData.length > 0) {
        candlestickSeriesRef.current.setData(formattedData);
        chartRef.current?.timeScale().fitContent();
      }
    } catch (error) {
      console.error('Error formatting candle data:', error);
    }
  }, [candleResponse]);

  return (
    <div className="relative h-full w-full bg-[#0a0a0a]">
      <div className="absolute top-2 left-2 z-10 bg-gray-900/80 backdrop-blur-sm rounded px-3 py-1.5">
        <div className="flex items-center gap-2 text-xs">
          <span className="text-gray-400">Chart Source:</span>
          <span className="text-blue-400 font-medium">Hyperliquid DEX</span>
        </div>
      </div>
      <div ref={chartContainerRef} className="h-full w-full min-h-[400px]" />
    </div>
  );
};
```

---

## File: client/src/components/trading/HyperliquidMarkets.tsx

```tsx
import { useEffect, useState } from "react";
import { Card } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { Input } from "@/components/ui/input";
import { Search } from "lucide-react";

interface HyperliquidMarket {
  name: string;
  szDecimals: number;
  maxLeverage: number;
  onlyIsolated: boolean;
}

interface MarketPrice {
  price: string;
  change24h: number;
  volume24h: string;
}

interface MarketSelection {
  name: string;
  displayName: string;
  index: number;
  markPx: string;
  dayNtlVlm: string;
  prevDayPx: string;
  maxLeverage: number;
}

export function HyperliquidMarkets({ onSelectMarket, autoSelectBTC = true }: { onSelectMarket: (market: MarketSelection) => void, autoSelectBTC?: boolean }) {
  const [markets, setMarkets] = useState<HyperliquidMarket[]>([]);
  const [marketContexts, setMarketContexts] = useState<any[]>([]);
  const [prices, setPrices] = useState<{[key: string]: MarketPrice}>({});
  const [loading, setLoading] = useState(true);
  const [selectedMarket, setSelectedMarket] = useState("BTC");
  const [searchQuery, setSearchQuery] = useState("");

  useEffect(() => {
    fetchMarkets();
    fetchPrices();
    const interval = setInterval(fetchPrices, 5000);
    return () => clearInterval(interval);
  }, []);

  const fetchMarkets = async () => {
    try {
      const response = await fetch('/api/hyperliquid/meta');
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      if (data && data[0] && data[0].universe) {
        setMarkets(data[0].universe);
        if (data[1]) {
          setMarketContexts(data[1]);
        }
        
        // Auto-select BTC on first load only if autoSelectBTC is true
        if (autoSelectBTC) {
          const btcMarket = data[0].universe.find((m: HyperliquidMarket) => m.name === 'BTC');
          if (btcMarket && data[1]) {
            const btcIndex = data[0].universe.findIndex((m: HyperliquidMarket) => m.name === 'BTC');
            const btcCtx = data[1][btcIndex];
            if (btcCtx) {
              const marketObj: MarketSelection = {
                name: 'BTC',
                displayName: 'BTC',
                index: btcIndex,
                markPx: btcCtx.markPx || '0',
                dayNtlVlm: btcCtx.dayNtlVlm || '0',
                prevDayPx: btcCtx.prevDayPx || '0',
                maxLeverage: btcMarket.maxLeverage
              };
              onSelectMarket(marketObj);
            }
          }
        }
      }
      setLoading(false);
    } catch (error) {
      console.error('Error fetching Hyperliquid markets:', error);
      setLoading(false);
    }
  };

  const fetchPrices = async () => {
    try {
      const response = await fetch('/api/hyperliquid/market-prices');
      const data = await response.json();
      
      // Transform the data into a more usable format
      const priceMap: {[key: string]: MarketPrice} = {};
      Object.entries(data).forEach(([symbol, priceData]: [string, any]) => {
        // Handle both number and object formats
        if (typeof priceData === 'number') {
          priceMap[symbol] = {
            price: priceData.toString(),
            change24h: 0,
            volume24h: "0"
          };
        } else if (priceData && typeof priceData === 'object') {
          priceMap[symbol] = {
            price: priceData.price?.toString() || "0",
            change24h: priceData.change24h || 0,
            volume24h: priceData.volume24h || "0"
          };
        }
      });
      setPrices(priceMap);
    } catch (error) {
      console.error('Error fetching market prices:', error);
    }
  };

  const handleMarketClick = (market: HyperliquidMarket, index: number) => {
    setSelectedMarket(market.name);
    const ctx = marketContexts[index];
    if (ctx) {
      const marketObj: MarketSelection = {
        name: market.name,
        displayName: market.name,
        index: index,
        markPx: ctx.markPx || '0',
        dayNtlVlm: ctx.dayNtlVlm || '0',
        prevDayPx: ctx.prevDayPx || '0',
        maxLeverage: market.maxLeverage
      };
      onSelectMarket(marketObj);
    }
  };

  if (loading) {
    return (
      <div className="space-y-2 p-4">
        {[1, 2, 3, 4, 5].map((i) => (
          <Skeleton key={i} className="h-12 w-full" />
        ))}
      </div>
    );
  }

  // Filter markets based on search query
  const filteredMarkets = markets.filter(market => 
    market.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  // Sort by volume from highest to lowest
  const sortedMarkets = filteredMarkets.sort((a, b) => {
    const aVolume = prices[a.name]?.volume24h ? parseFloat(prices[a.name].volume24h) : 0;
    const bVolume = prices[b.name]?.volume24h ? parseFloat(prices[b.name].volume24h) : 0;
    return bVolume - aVolume;
  });

  return (
    <div className="h-full overflow-y-auto custom-scrollbar">
      <div className="p-2 border-b border-gray-800">
        <h3 className="text-xs font-semibold text-gray-400">PERPETUAL MARKETS</h3>
      </div>
      <div className="p-2 border-b border-gray-800">
        <div className="relative">
          <Search className="absolute left-2 top-1/2 transform -translate-y-1/2 h-3 w-3 text-gray-400" />
          <Input
            type="text"
            placeholder="Search"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-6 h-7 text-xs bg-gray-900 border-gray-700 text-white placeholder-gray-500"
          />
        </div>
      </div>
      <div className="space-y-0.5 p-1">
        {sortedMarkets.map((market) => {
          const price = prices[market.name];
          const isSelected = selectedMarket === market.name;
          const originalIndex = markets.findIndex(m => m.name === market.name);
          
          return (
            <Card
              key={market.name}
              className={`p-2 cursor-pointer transition-all group ${
                isSelected ? 'bg-blue-600 border-blue-500' : 'bg-black hover:bg-gray-900 border-transparent'
              }`}
              onClick={() => handleMarketClick(market, originalIndex)}
            >
              <div className="flex justify-between items-center">
                <div>
                  <div className="font-semibold text-xs text-white">{market.name}-USD</div>
                  <div className="text-[10px] text-gray-300">
                    {market.maxLeverage}x
                  </div>
                </div>
                <div className="text-right">
                  <div className="text-xs text-white">
                    ${price?.price && parseFloat(price.price) > 0 ? parseFloat(price.price).toFixed(2) : '0.00'}
                  </div>
                  <div className="text-[10px] text-gray-300">
                    Vol: ${price?.volume24h ? (parseFloat(price.volume24h) / 1e6).toFixed(0) : '0'}M
                  </div>
                </div>
              </div>
            </Card>
          );
        })}
      </div>
    </div>
  );
}
```

---

## File: client/src/components/trading/HyperliquidPositions.tsx

```tsx
import { Button } from "@/components/ui/button";
import { useHyperliquidTrading } from "@/hooks/useHyperliquidTrading";
import { Loader2 } from "lucide-react";

export function HyperliquidPositions() {
  const { 
    authenticated,
    positions, 
    accountSummary, 
    positionsLoading,
    userAddress 
  } = useHyperliquidTrading();

  if (!authenticated) {
    return (
      <div className="bg-[#0a0a0a] border-t border-gray-900 p-8 text-center">
        <p className="text-gray-400">Connect your wallet to view positions</p>
      </div>
    );
  }

  if (positionsLoading) {
    return (
      <div className="bg-[#0a0a0a] border-t border-gray-900 p-8 flex items-center justify-center">
        <Loader2 className="h-6 w-6 animate-spin text-gray-400" />
      </div>
    );
  }

  return (
    <div className="bg-[#0a0a0a] border-t border-gray-900">
      {/* Account Summary Bar */}
      <div className="bg-[#0f0f0f] border-b border-gray-900 px-4 py-3">
        <div className="flex flex-wrap items-center justify-between gap-4 text-xs">
          <div className="flex flex-wrap items-center gap-x-6 gap-y-2">
            <div className="flex items-center space-x-2">
              <span className="text-gray-500">Account Value:</span>
              <span className="font-mono text-white">
                ${accountSummary ? parseFloat(accountSummary.accountValue).toFixed(2) : '0.00'}
              </span>
            </div>
            <div className="flex items-center space-x-2">
              <span className="text-gray-500">Margin Used:</span>
              <span className="font-mono text-white">
                ${accountSummary ? parseFloat(accountSummary.totalMarginUsed).toFixed(2) : '0.00'}
              </span>
              {accountSummary && parseFloat(accountSummary.accountValue) > 0 && (
                <span className="text-gray-400">
                  ({((parseFloat(accountSummary.totalMarginUsed) / parseFloat(accountSummary.accountValue)) * 100).toFixed(1)}%)
                </span>
              )}
            </div>
            <div className="flex items-center space-x-2">
              <span className="text-gray-500">Free Collateral:</span>
              <span className="font-mono text-white">
                ${accountSummary ? parseFloat(accountSummary.withdrawable).toFixed(2) : '0.00'}
              </span>
            </div>
            <div className="flex items-center space-x-2">
              <span className="text-gray-500">Total PnL:</span>
              {positions.length > 0 ? (
                <span className={`font-mono ${
                  positions.reduce((sum, pos) => sum + pos.unrealizedPnl, 0) >= 0 
                    ? 'text-green-400' 
                    : 'text-red-400'
                }`}>
                  {positions.reduce((sum, pos) => sum + pos.unrealizedPnl, 0) >= 0 ? '+' : ''}
                  ${positions.reduce((sum, pos) => sum + pos.unrealizedPnl, 0).toFixed(2)}
                </span>
              ) : (
                <span className="font-mono text-gray-400">$0.00</span>
              )}
            </div>
          </div>
          <div className="flex items-center space-x-4">
            <Button size="sm" variant="ghost" className="h-6 px-2 text-xs text-gray-400 hover:text-white">
              Deposit
            </Button>
            <Button size="sm" variant="ghost" className="h-6 px-2 text-xs text-gray-400 hover:text-white">
              Withdraw
            </Button>
          </div>
        </div>
      </div>

      {/* Positions Table */}
      <div className="overflow-x-auto">
        <table className="w-full text-xs">
          <thead className="bg-[#0f0f0f] border-b border-gray-900">
            <tr className="text-gray-500">
              <th className="text-left py-3 px-4 font-normal whitespace-nowrap">Market</th>
              <th className="text-center py-3 px-3 font-normal whitespace-nowrap">Side</th>
              <th className="text-right py-3 px-3 font-normal whitespace-nowrap">Size</th>
              <th className="text-right py-3 px-3 font-normal whitespace-nowrap">Value</th>
              <th className="text-right py-3 px-3 font-normal whitespace-nowrap">Entry</th>
              <th className="text-right py-3 px-3 font-normal whitespace-nowrap">Mark</th>
              <th className="text-right py-3 px-3 font-normal whitespace-nowrap">Liq</th>
              <th className="text-right py-3 px-3 font-normal whitespace-nowrap">PnL</th>
              <th className="text-right py-3 px-3 font-normal whitespace-nowrap">PnL %</th>
              <th className="text-right py-3 px-3 font-normal whitespace-nowrap">Margin</th>
              <th className="text-center py-3 px-3 font-normal whitespace-nowrap">TP/SL</th>
              <th className="text-center py-3 px-4 font-normal whitespace-nowrap">Close</th>
            </tr>
          </thead>
          <tbody>
            {positions.length === 0 ? (
              <tr>
                <td colSpan={12} className="py-8 text-center text-gray-400">
                  No open positions
                </td>
              </tr>
            ) : (
              positions.map((position, index) => (
                <tr key={`${position.coin}-${index}`} className="border-b border-gray-900 hover:bg-[#0f0f0f] transition-colors">
                  <td className="py-2 px-4 font-mono">{position.coin}-USD</td>
                  <td className="py-2 px-2 text-center">
                    <span className={`font-semibold ${
                      position.side === 'LONG' ? 'text-green-400' : 'text-red-400'
                    }`}>
                      {position.side}
                    </span>
                  </td>
                  <td className="py-2 px-2 text-right font-mono">{position.size.toFixed(4)}</td>
                  <td className="py-2 px-2 text-right font-mono text-gray-300">
                    ${position.positionValue.toFixed(2)}
                  </td>
                  <td className="py-2 px-2 text-right font-mono">
                    {position.entryPrice.toFixed(2)}
                  </td>
                  <td className="py-2 px-2 text-right font-mono">
                    {position.markPrice.toFixed(2)}
                  </td>
                  <td className="py-2 px-2 text-right font-mono text-orange-400">
                    {position.liquidationPrice > 0 ? position.liquidationPrice.toFixed(2) : 'N/A'}
                  </td>
                  <td className={`py-2 px-2 text-right font-mono ${
                    position.unrealizedPnl >= 0 ? 'text-green-400' : 'text-red-400'
                  }`}>
                    {position.unrealizedPnl >= 0 ? '+' : ''}${Math.abs(position.unrealizedPnl).toFixed(2)}
                  </td>
                  <td className={`py-2 px-2 text-right ${
                    position.pnlPercentage >= 0 ? 'text-green-400' : 'text-red-400'
                  }`}>
                    {position.pnlPercentage >= 0 ? '+' : ''}{position.pnlPercentage.toFixed(2)}%
                  </td>
                  <td className="py-2 px-2 text-right font-mono">
                    ${position.marginUsed.toFixed(2)}
                  </td>
                  <td className="py-2 px-2 text-center">
                    <Button size="sm" variant="ghost" className="h-5 px-1 text-[10px] text-gray-400 hover:text-white">
                      Set
                    </Button>
                  </td>
                  <td className="py-2 px-4 text-center">
                    <Button size="sm" variant="ghost" className="h-5 px-2 text-[10px] text-gray-400 hover:text-white hover:bg-red-900/20">
                      Close
                    </Button>
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}
```

---

## File: client/src/components/trading/HyperliquidTradeForm.tsx

```tsx
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Slider } from "@/components/ui/slider";
import { useHyperliquidTrading } from "@/hooks/useHyperliquidTrading";
import { Loader2 } from "lucide-react";
import { TradeConfirmationDialog } from "./TradeConfirmationDialog";
import { Checkbox } from "@/components/ui/checkbox";
import { useToast } from "@/hooks/use-toast";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { usePrivy } from "@privy-io/react-auth";

interface HyperliquidTradeFormProps {
  selectedMarket: string;
  currentPrice: number;
  maxLeverage?: number;
}

export function HyperliquidTradeForm({ selectedMarket, currentPrice, maxLeverage = 100 }: HyperliquidTradeFormProps) {
  const [side, setSide] = useState<"buy" | "sell">("buy");
  const [orderType, setOrderType] = useState<"limit" | "market">("limit");
  const [price, setPrice] = useState("");
  const [size, setSize] = useState("");
  const [sizeMode, setSizeMode] = useState<"asset" | "usd">("usd");
  const [collateralPercentage, setCollateralPercentage] = useState(0);
  const [leverage, setLeverage] = useState(Math.min(5, maxLeverage));
  const [showLeverageModal, setShowLeverageModal] = useState(false);
  const [reduceOnly, setReduceOnly] = useState(false);
  const [postOnly, setPostOnly] = useState(false);
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  
  // TP/SL states
  const [enableTP, setEnableTP] = useState(false);
  const [enableSL, setEnableSL] = useState(false);
  const [tpPrice, setTpPrice] = useState("");
  const [slPrice, setSlPrice] = useState("");
  const [tpMode, setTpMode] = useState<"price" | "percentage">("price");
  const [slMode, setSlMode] = useState<"price" | "percentage">("price");
  const [tpPercentage, setTpPercentage] = useState("");
  const [slPercentage, setSlPercentage] = useState("");

  const { 
    authenticated, 
    placeOrder, 
    isPlacingOrder,
    accountSummary 
  } = useHyperliquidTrading();
  
  const { login, ready } = usePrivy();
  
  const { toast } = useToast();

  // Update price when market changes or when switching to limit order
  useEffect(() => {
    if (orderType === "limit" && currentPrice > 0) {
      setPrice(currentPrice.toFixed(2));
    }
  }, [currentPrice, orderType]);

  // Calculate available collateral from account summary
  const availableCollateral = accountSummary?.freeCollateral || 0;
  
  // Update size based on collateral percentage
  useEffect(() => {
    if (collateralPercentage > 0 && availableCollateral > 0) {
      const collateralToUse = (availableCollateral * collateralPercentage) / 100;
      const notionalSize = collateralToUse * leverage;
      setSize(notionalSize.toFixed(2));
      setSizeMode("usd");
    } else if (collateralPercentage === 0) {
      setSize("");
    }
  }, [collateralPercentage, availableCollateral, leverage]);

  // Calculate TP/SL prices based on percentage
  useEffect(() => {
    const entryPrice = orderType === "limit" && price ? parseFloat(price) : currentPrice;
    if (entryPrice > 0) {
      // Update TP price if in percentage mode
      if (tpMode === "percentage" && tpPercentage) {
        const tpPercent = parseFloat(tpPercentage);
        const calculatedTpPrice = side === "buy" 
          ? entryPrice * (1 + tpPercent / 100)
          : entryPrice * (1 - tpPercent / 100);
        setTpPrice(calculatedTpPrice.toFixed(2));
      }
      
      // Update SL price if in percentage mode
      if (slMode === "percentage" && slPercentage) {
        const slPercent = parseFloat(slPercentage);
        const calculatedSlPrice = side === "buy"
          ? entryPrice * (1 - slPercent / 100)
          : entryPrice * (1 + slPercent / 100);
        setSlPrice(calculatedSlPrice.toFixed(2));
      }
    }
  }, [tpMode, slMode, tpPercentage, slPercentage, price, currentPrice, orderType, side]);

  const handleSubmit = async () => {
    if (!size || parseFloat(size) <= 0) {
      toast({
        title: "Invalid size",
        description: "Please enter a valid order size",
        variant: "destructive",
      });
      return;
    }

    if (orderType === "limit" && (!price || parseFloat(price) <= 0)) {
      toast({
        title: "Invalid price",
        description: "Please enter a valid limit price",
        variant: "destructive",
      });
      return;
    }

    // Show confirmation dialog
    setShowConfirmDialog(true);
  };

  const handleConfirmOrder = async () => {
    // Calculate actual size based on mode
    let actualSize = parseFloat(size);
    if (sizeMode === "usd") {
      const orderPrice = orderType === "limit" && price ? parseFloat(price) : currentPrice;
      if (orderPrice > 0) {
        actualSize = parseFloat(size) / orderPrice;
      }
    }

    try {
      await placeOrder({
        symbol: selectedMarket,
        side,
        price: orderType === "limit" ? parseFloat(price) : 0,
        size: actualSize,
        orderType,
        reduceOnly,
        postOnly: orderType === "limit" && postOnly,
        ioc: orderType === "market",
        tpPrice: enableTP && tpPrice ? parseFloat(tpPrice) : undefined,
        slPrice: enableSL && slPrice ? parseFloat(slPrice) : undefined,
      });

      // Reset form after successful order
      setSize("");
      setShowConfirmDialog(false);
    } catch (error) {
      // Error handling is done in the hook
      setShowConfirmDialog(false);
    }
  };

  const calculateOrderValue = () => {
    if (!size) return "0.00";
    
    if (sizeMode === "usd") {
      // If user entered USD, the order value is what they entered
      return parseFloat(size).toFixed(2);
    } else {
      // If user entered asset amount, calculate USD value
      const orderPrice = orderType === "limit" && price ? parseFloat(price) : currentPrice;
      return (parseFloat(size) * orderPrice).toFixed(2);
    }
  };

  const calculateMarginRequired = () => {
    const orderValue = parseFloat(calculateOrderValue());
    return leverage > 0 ? (orderValue / leverage).toFixed(2) : "0.00";
  };

  const calculateLiquidationPrice = () => {
    if (!size || parseFloat(size) <= 0) return undefined;
    
    const orderPrice = orderType === "limit" && price ? parseFloat(price) : currentPrice;
    const orderSize = sizeMode === "usd" ? parseFloat(size) / orderPrice : parseFloat(size);
    
    // Liquidation price calculation
    // For longs: Entry Price * (1 - 1/leverage + maintenance margin)
    // For shorts: Entry Price * (1 + 1/leverage - maintenance margin)
    const maintenanceMargin = 0.005; // 0.5% maintenance margin
    
    if (side === "buy") {
      return orderPrice * (1 - 1/leverage + maintenanceMargin);
    } else {
      return orderPrice * (1 + 1/leverage - maintenanceMargin);
    }
  };

  const calculateFee = () => {
    const orderValue = parseFloat(calculateOrderValue());
    return orderValue * 0.001; // 0.1% taker fee
  };

  const getTradeDetails = () => {
    const orderPrice = orderType === "limit" && price ? parseFloat(price) : currentPrice;
    const orderSize = sizeMode === "usd" ? parseFloat(size) / orderPrice : parseFloat(size);
    const notionalValue = parseFloat(calculateOrderValue());
    const requiredMargin = parseFloat(calculateMarginRequired());
    const fee = calculateFee();
    const liquidationPrice = calculateLiquidationPrice();

    return {
      orderPrice,
      orderSize,
      notionalValue,
      requiredMargin,
      fee,
      liquidationPrice
    };
  };

  return (
    <div className="p-4 space-y-3">
      {/* Leverage Header */}
      <button
        onClick={() => setShowLeverageModal(true)}
        className="w-full flex items-center justify-center bg-gray-900 rounded px-3 py-2 hover:bg-gray-800 transition-colors"
      >
        <span className="text-xs font-medium text-white">{leverage}x</span>
      </button>
      
      {/* Order Type */}
      <Tabs value={orderType} onValueChange={(v) => setOrderType(v as "limit" | "market")}>
        <TabsList className="grid w-full grid-cols-2 h-8 bg-gray-900 p-0.5">
          <TabsTrigger value="market" className="text-xs data-[state=active]:bg-gray-800 data-[state=active]:text-white">
            Market
          </TabsTrigger>
          <TabsTrigger value="limit" className="text-xs data-[state=active]:bg-gray-800 data-[state=active]:text-white">
            Limit
          </TabsTrigger>
        </TabsList>
      </Tabs>

      {/* Buy/Sell Toggle */}
      <Tabs value={side} onValueChange={(v) => setSide(v as "buy" | "sell")}>
        <TabsList className="grid w-full grid-cols-2 h-8 bg-gray-900 p-0.5">
          <TabsTrigger value="buy" className="text-xs data-[state=active]:bg-[#1dd1a1] data-[state=active]:text-black data-[state=inactive]:bg-gray-800 data-[state=inactive]:text-gray-400">
            Buy / Long
          </TabsTrigger>
          <TabsTrigger value="sell" className="text-xs data-[state=active]:bg-[#f56565] data-[state=active]:text-white data-[state=inactive]:bg-gray-800 data-[state=inactive]:text-gray-400">
            Sell / Short
          </TabsTrigger>
        </TabsList>
      </Tabs>

      {/* Available to Trade & Current Position */}
      <div className="space-y-2 bg-gray-900/50 p-2 rounded">
        <div className="flex justify-between text-xs">
          <span className="text-gray-400">Available to Trade</span>
          <span className="text-white">${availableCollateral.toFixed(2)}</span>
        </div>
        {accountSummary?.positions && accountSummary.positions.length > 0 && (
          <div className="flex justify-between text-xs">
            <span className="text-gray-400">Current Position</span>
            <span className="text-white">
              {accountSummary.positions.find(p => p.coin === selectedMarket)?.szi || "0"} {selectedMarket}
            </span>
          </div>
        )}
      </div>

      {/* Price Input (for limit orders) */}
      {orderType === "limit" && (
        <div>
          <Label className="text-xs text-gray-400">Price</Label>
          <Input
            type="number"
            value={price}
            onChange={(e) => setPrice(e.target.value)}
            placeholder="0.00"
            className="bg-gray-900 border-gray-700 h-8 text-sm"
          />
        </div>
      )}

      {/* Size Input and Percentage Slider */}
      <div>
        <div className="flex items-center justify-between mb-2">
          <Label className="text-xs text-gray-400">Size</Label>
          <button
            type="button"
            onClick={() => setSizeMode(sizeMode === "usd" ? "asset" : "usd")}
            className="text-xs font-medium text-[#1dd1a1] hover:text-[#1ab894]"
          >
            USD
          </button>
        </div>
        <Input
          type="number"
          value={size}
          onChange={(e) => {
            setSize(e.target.value);
            // Update percentage based on manual size input
            if (availableCollateral > 0 && e.target.value) {
              const orderValue = parseFloat(e.target.value);
              const requiredCollateral = orderValue / leverage;
              const percentage = (requiredCollateral / availableCollateral) * 100;
              setCollateralPercentage(Math.min(100, Math.max(0, percentage)));
            }
          }}
          placeholder={sizeMode === "usd" ? "$0.00" : "0.00"}
          className="bg-gray-900 border-gray-700 h-8 text-sm mb-2"
        />
        <Slider
          value={[collateralPercentage]}
          onValueChange={(value) => setCollateralPercentage(value[0])}
          max={100}
          min={0}
          step={1}
          className="w-full force-small-slider"
        />
        <div className="flex justify-between items-center mt-1">
          <div className="flex justify-between w-full text-[10px] text-gray-500">
            <span>0</span>
            <span>25</span>
            <span>50</span>
            <span>75</span>
            <span>100 %</span>
          </div>
        </div>
      </div>
      
      {/* Reduce Only and TP/SL */}
      <div className="space-y-2">
        <label className="flex items-center space-x-2 text-xs">
          <input
            type="checkbox"
            checked={reduceOnly}
            onChange={(e) => setReduceOnly(e.target.checked)}
            className="w-3 h-3"
          />
          <span>Reduce Only</span>
        </label>
        <label className="flex items-center space-x-2 text-xs">
          <input
            type="checkbox"
            checked={enableTP || enableSL}
            onChange={(e) => {
              setEnableTP(e.target.checked);
              setEnableSL(e.target.checked);
            }}
            className="w-3 h-3"
          />
          <span>Take Profit / Stop Loss</span>
        </label>
      </div>
      

      
      {/* Order Summary */}
      <div className="space-y-2 text-xs">
        <div className="flex justify-between">
          <span className="text-gray-400">Total:</span>
          <span className="font-mono">${calculateOrderValue()}</span>
        </div>
      </div>
      {/* Submit Button */}
      <Button
        size="sm"
        disabled={isPlacingOrder || (!authenticated ? false : !size)}
        onClick={!authenticated ? async () => {
          console.log('Connect wallet clicked, Privy ready:', ready);
          try {
            if (ready) {
              console.log('Calling login...');
              await login();
              console.log('Login called successfully');
            } else {
              console.error('Privy not ready yet');
              toast({
                title: "Error",
                description: "Wallet connection is not ready. Please refresh and try again.",
                variant: "destructive"
              });
            }
          } catch (error) {
            console.error('Login error:', error);
            toast({
              title: "Connection Error",
              description: "Failed to open wallet connection. Please try again.",
              variant: "destructive"
            });
          }
        } : handleSubmit}
        className={`w-full h-9 text-sm font-medium rounded transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2 ${
          side === "buy" 
            ? "text-black bg-[#1dd1a1] hover:bg-[#19b894]" 
            : "text-white bg-[#f56565] hover:bg-[#e53e3e]"
        }`}
      >
        {isPlacingOrder ? (
          <>
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            Placing Order...
          </>
        ) : !authenticated ? (
          "Connect Wallet"
        ) : (
          `${side === "buy" ? "Buy Long" : "Sell Short"} ${sizeMode === "usd" ? "$" : ""}${size || "0"} ${sizeMode === "usd" ? "USD" : selectedMarket}`
        )}
      </Button>

      {/* Order Information */}
      {size && parseFloat(size) > 0 && (
        <div className="mt-2 p-2 bg-gray-900/50 rounded text-xs space-y-1">
          <div className="flex justify-between">
            <span className="text-gray-400">Liquidation Price</span>
            <span className="text-white">${getTradeDetails().liquidationPrice.toFixed(2)}</span>
          </div>
          <div className="flex justify-between">
            <span className="text-gray-400">Order Value</span>
            <span className="text-white">${getTradeDetails().notionalValue.toFixed(2)}</span>
          </div>
          <div className="flex justify-between">
            <span className="text-gray-400">Margin Required</span>
            <span className="text-white">${getTradeDetails().requiredMargin.toFixed(2)}</span>
          </div>
        </div>
      )}

      {/* Trade Confirmation Dialog */}
      <TradeConfirmationDialog
        open={showConfirmDialog}
        onOpenChange={setShowConfirmDialog}
        onConfirm={handleConfirmOrder}
        market={selectedMarket}
        side={side}
        size={parseFloat(size || "0")}
        price={getTradeDetails().orderPrice}
        leverage={leverage}
        isMarketOrder={orderType === "market"}
        markPrice={currentPrice}
        liquidationPrice={getTradeDetails().liquidationPrice}
        notionalValue={getTradeDetails().notionalValue}
        requiredMargin={getTradeDetails().requiredMargin}
        fee={getTradeDetails().fee}
        isReduceOnly={reduceOnly}
        sizeMode={sizeMode}
        tpPrice={enableTP && tpPrice ? parseFloat(tpPrice) : undefined}
        slPrice={enableSL && slPrice ? parseFloat(slPrice) : undefined}
      />

      {/* Leverage Adjustment Modal */}
      <Dialog open={showLeverageModal} onOpenChange={setShowLeverageModal}>
        <DialogContent className="sm:max-w-[425px] bg-gray-900 border-gray-800">
          <DialogHeader>
            <DialogTitle className="text-white">Adjust Leverage</DialogTitle>
          </DialogHeader>
          <div className="py-4">
            <div className="space-y-4">
              <div>
                <div className="flex items-center justify-between mb-2">
                  <Label className="text-sm text-gray-400">Leverage</Label>
                  <span className="text-lg font-medium text-white">{leverage}x</span>
                </div>
                <Slider
                  value={[leverage]}
                  onValueChange={(value) => setLeverage(value[0])}
                  max={maxLeverage}
                  min={1}
                  step={1}
                  className="w-full force-small-slider"
                />
                <div className="flex justify-between text-[10px] text-gray-500 mt-1">
                  <span>1x</span>
                  {maxLeverage >= 25 && <span>{Math.round(maxLeverage * 0.25)}x</span>}
                  {maxLeverage >= 50 && <span>{Math.round(maxLeverage * 0.5)}x</span>}
                  {maxLeverage >= 75 && <span>{Math.round(maxLeverage * 0.75)}x</span>}
                  <span>{maxLeverage}x</span>
                </div>
              </div>
              <div className="space-y-2 text-xs">
                <div className="flex justify-between">
                  <span className="text-gray-400">Max Leverage:</span>
                  <span className="text-white">{maxLeverage}x</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-400">Selected:</span>
                  <span className="text-white">{leverage}x</span>
                </div>
              </div>
            </div>
          </div>
          <div className="flex justify-end space-x-2">
            <Button
              variant="ghost"
              onClick={() => setShowLeverageModal(false)}
              className="text-gray-400 hover:text-white"
            >
              Cancel
            </Button>
            <Button
              onClick={() => setShowLeverageModal(false)}
              className="bg-[#1dd1a1] hover:bg-[#1ab894] text-black"
            >
              Confirm
            </Button>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}
```

---

## File: client/src/components/trading/HyperliquidTradingInterface.tsx

```tsx
import React, { useState, useEffect, useMemo } from 'react';
import { HyperliquidMarkets } from './HyperliquidMarkets';
import { HyperliquidTradeForm } from './HyperliquidTradeForm';
import { HyperliquidPositions } from './HyperliquidPositions';
import { TradingViewChart } from './TradingViewChart';
import { HyperliquidDeposit } from './HyperliquidDeposit';
import { PolymarketInterface } from './PolymarketInterface';
import { SimpleSpotTrading } from './SimpleSpotTrading';
import { usePrivy } from '@privy-io/react-auth';
import { Button } from '@/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';

interface Market {
  name: string;
  displayName: string;
  index: number;
  markPx: string;
  dayNtlVlm: string;
  prevDayPx: string;
  maxLeverage: number;
}

export function HyperliquidTradingInterface() {
  const { authenticated, user } = usePrivy();
  const [selectedMarket, setSelectedMarket] = useState<Market | null>(null);
  const [mobileView, setMobileView] = useState<'markets' | 'chart' | 'trade' | 'spot' | 'funds' | 'predictions'>('chart');
  const [showMobileMenu, setShowMobileMenu] = useState(false);

  const [liveMarketData, setLiveMarketData] = useState<{
    price: string;
    volume24h: string;
    change24h: string;
    high24h: string;
    low24h: string;
    fundingRate: string;
    openInterest: string;
  } | null>(null);

  const address = user?.wallet?.address || '';

  // Get TradingView symbol based on selected market - memoized to prevent unnecessary re-renders
  const tradingViewSymbol = useMemo(() => {
    if (selectedMarket) {
      return `${selectedMarket.name}USDT`;
    }
    return 'BTCUSDT';
  }, [selectedMarket?.name]);

  // Fetch live market data
  useEffect(() => {
    if (!selectedMarket) return;

    const fetchLiveData = async () => {
      try {
        const marketName = selectedMarket?.name;
        if (!marketName) return;

        const response = await fetch('/api/hyperliquid/market-prices');
        const data = await response.json();
        
        if (data[marketName]) {
          const marketData = data[marketName];
          setLiveMarketData({
            price: marketData.price?.toString() || '0',
            volume24h: marketData.volume24h || '0',
            change24h: marketData.change24h?.toString() || '0',
            high24h: marketData.high24h?.toString() || '0',
            low24h: marketData.low24h?.toString() || '0',
            fundingRate: marketData.fundingRate?.toString() || '0',
            openInterest: marketData.openInterest || '0'
          });
        }
      } catch (error) {
        console.error('Error fetching live market data:', error);
      }
    };

    fetchLiveData();
    const interval = setInterval(fetchLiveData, 5000); // Update every 5 seconds to avoid rate limiting

    return () => clearInterval(interval);
  }, [selectedMarket]);

  return (
    <div className="flex flex-col bg-black text-white h-screen lg:h-[600px]">
      {/* Desktop Layout */}
      <div className="hidden lg:flex flex-1 overflow-hidden">
        {/* Markets Sidebar */}
        <div className="w-44 border-r border-gray-800 h-full overflow-y-auto custom-scrollbar">
          <HyperliquidMarkets
            onSelectMarket={setSelectedMarket}
          />
        </div>

        {/* Chart Area */}
        <div className="flex-1 flex flex-col">
          {/* Market Stats Bar */}
          <div className="bg-[#0f0f0f] border-b border-gray-800 px-4 py-2">
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-4">
                <h2 className="text-lg font-semibold">
                  {selectedMarket?.name || 'Select Market'} / USD
                </h2>
                {liveMarketData && selectedMarket && (
                  <>
                    <div>
                      <div className="text-xs text-gray-400">Last Price</div>
                      <div className="text-lg font-semibold">
                        ${parseFloat(liveMarketData.price).toLocaleString(undefined, { 
                          minimumFractionDigits: 2,
                          maximumFractionDigits: 6 
                        })}
                      </div>
                    </div>
                    <div>
                      <div className="text-xs text-gray-400">24h Change</div>
                      <div className={`text-sm ${parseFloat(liveMarketData.change24h) >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                        {parseFloat(liveMarketData.change24h) >= 0 ? '+' : ''}{parseFloat(liveMarketData.change24h).toFixed(2)}%
                      </div>
                    </div>
                    <div>
                      <div className="text-xs text-gray-400">24h Volume</div>
                      <div className="text-sm">
                        ${parseFloat(liveMarketData.volume24h).toLocaleString(undefined, { 
                          maximumFractionDigits: 0 
                        })}
                      </div>
                    </div>
                    <div>
                      <div className="text-xs text-gray-400">24h High</div>
                      <div className="text-sm text-green-400">
                        ${parseFloat(liveMarketData.high24h).toLocaleString(undefined, { 
                          minimumFractionDigits: 2,
                          maximumFractionDigits: 6 
                        })}
                      </div>
                    </div>
                    <div>
                      <div className="text-xs text-gray-400">24h Low</div>
                      <div className="text-sm text-red-400">
                        ${parseFloat(liveMarketData.low24h).toLocaleString(undefined, { 
                          minimumFractionDigits: 2,
                          maximumFractionDigits: 6 
                        })}
                      </div>
                    </div>
                    <div>
                      <div className="text-xs text-gray-400">Funding APR</div>
                      <div className={`text-sm ${parseFloat(liveMarketData.fundingRate) > 0 ? 'text-green-400' : parseFloat(liveMarketData.fundingRate) < 0 ? 'text-red-400' : 'text-gray-400'}`}>
                        {parseFloat(liveMarketData.fundingRate).toFixed(2)}%
                      </div>
                    </div>
                    <div>
                      <div className="text-xs text-gray-400">Open Interest</div>
                      <div className="text-sm">
                        ${parseFloat(liveMarketData.openInterest).toLocaleString(undefined, { 
                          maximumFractionDigits: 0 
                        })}
                      </div>
                    </div>
                  </>
                )}
              </div>
            </div>
            

          </div>

          {/* Chart */}
          <div className="flex-1 min-h-0 relative">
            <div className="absolute inset-0">
              <TradingViewChart 
                symbol={tradingViewSymbol}
                theme="dark"
              />
            </div>
          </div>

          {/* Positions */}
          {authenticated && (
            <div className="border-t border-gray-800 h-64 overflow-y-auto custom-scrollbar">
              <HyperliquidPositions address={address} />
            </div>
          )}
        </div>

        {/* Right Sidebar - Trading Panel & AI Assistant */}
        <div className="w-80 border-l border-gray-800 flex flex-col">
          <Tabs defaultValue="trade" className="flex-1 flex flex-col">
            <TabsList className="w-full rounded-none bg-[#000000] border-b border-gray-800 p-0">
              <TabsTrigger value="trade" className="flex-1 rounded-none data-[state=active]:bg-[#1a1a1a] data-[state=active]:text-white data-[state=inactive]:bg-[#0a0a0a] data-[state=inactive]:text-gray-500 h-10 font-medium transition-all">Trade</TabsTrigger>
              <TabsTrigger value="spot" className="flex-1 rounded-none data-[state=active]:bg-[#1a1a1a] data-[state=active]:text-white data-[state=inactive]:bg-[#0a0a0a] data-[state=inactive]:text-gray-500 h-10 font-medium transition-all">Spot</TabsTrigger>
              <TabsTrigger value="funds" className="flex-1 rounded-none data-[state=active]:bg-[#1a1a1a] data-[state=active]:text-white data-[state=inactive]:bg-[#0a0a0a] data-[state=inactive]:text-gray-500 h-10 font-medium transition-all">Funds</TabsTrigger>
              <TabsTrigger value="predictions" className="flex-1 rounded-none data-[state=active]:bg-[#1a1a1a] data-[state=active]:text-white data-[state=inactive]:bg-[#0a0a0a] data-[state=inactive]:text-gray-500 h-10 font-medium transition-all">Predictions</TabsTrigger>
            </TabsList>
            <TabsContent value="trade" className="flex-1 overflow-y-auto border-b border-gray-800 custom-scrollbar m-0">
              <HyperliquidTradeForm
                selectedMarket={selectedMarket?.name || 'BTC'}
                currentPrice={parseFloat(selectedMarket?.markPx || '0')}
                maxLeverage={selectedMarket?.maxLeverage}
              />
            </TabsContent>
            <TabsContent value="spot" className="flex-1 overflow-y-auto border-b border-gray-800 custom-scrollbar m-0 p-4">
              <SimpleSpotTrading walletAddress={address} />
            </TabsContent>
            <TabsContent value="funds" className="flex-1 overflow-y-auto border-b border-gray-800 custom-scrollbar m-0 p-4">
              <HyperliquidDeposit />
            </TabsContent>
            <TabsContent value="predictions" className="flex-1 m-0 relative">
              <div className="absolute inset-0">
                <PolymarketInterface />
              </div>
            </TabsContent>
          </Tabs>
        </div>
      </div>
      {/* Mobile Layout */}
      <div className="lg:hidden flex flex-col h-full">
        {/* Mobile Header */}
        <div className="border-b border-gray-800 bg-gray-900 sticky top-0 z-10">
          <div className="px-4 py-2 bg-[#0d0000]">
            <div className="flex items-center justify-between">
              <h2 className="text-lg font-semibold text-white">
                {selectedMarket?.displayName || 'Select Market'}
              </h2>
              <button
                onClick={() => setShowMobileMenu(!showMobileMenu)}
                className="p-2 text-gray-400 hover:text-white"
              >
                <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
                </svg>
              </button>
            </div>
            
            {/* Compact Market Stats */}
            {liveMarketData ? (
              <div className="flex items-center justify-between mt-2 text-xs">
                <div>
                  <span className="text-gray-400">Price: </span>
                  <span className="font-semibold">
                    ${parseFloat(liveMarketData.price).toLocaleString(undefined, { 
                      minimumFractionDigits: 2,
                      maximumFractionDigits: 2
                    })}
                  </span>
                </div>
                <div className={parseFloat(liveMarketData.change24h) >= 0 ? 'text-green-400' : 'text-red-400'}>
                  {parseFloat(liveMarketData.change24h) >= 0 ? '+' : ''}{parseFloat(liveMarketData.change24h).toFixed(2)}%
                </div>
                <div>
                  <span className="text-gray-400">Vol: </span>
                  <span>
                    ${(parseFloat(liveMarketData.volume24h) / 1000000).toFixed(1)}M
                  </span>
                </div>
              </div>
            ) : (
              <div className="flex items-center justify-between mt-2 text-xs">
                <div>
                  <span className="text-gray-400">BTC</span>
                  <span className="font-semibold">Price: $116,322.00</span>
                </div>
                <div className="text-red-400">
                  -3.11%
                </div>
                <div>
                  <span className="text-gray-400">Vol: </span>
                  <span>$7905.2M</span>
                </div>
              </div>
            )}
          </div>

          {/* Mobile Navigation Tabs */}
          <div className="flex border-t border-gray-800 relative">
            <button
              onClick={() => {
                console.log('Setting mobile view to markets');
                setMobileView('markets');
              }}
              className={`flex-1 py-2 text-xs font-medium bg-[#000000] relative ${
                mobileView === 'markets' 
                  ? 'text-white' 
                  : 'text-gray-400 hover:text-white'
              }`}
            >
              Markets
              {mobileView === 'markets' && (
                <div className="absolute bottom-0 left-0 right-0 h-[2px] bg-[#1dd1a1]" />
              )}
            </button>
            <button
              onClick={() => {
                console.log('Setting mobile view to chart');
                setMobileView('chart');
              }}
              className={`flex-1 py-2 text-xs font-medium bg-[#000000] relative ${
                mobileView === 'chart' 
                  ? 'text-white' 
                  : 'text-gray-400 hover:text-white'
              }`}
            >
              Chart
              {mobileView === 'chart' && (
                <div className="absolute bottom-0 left-0 right-0 h-[2px] bg-[#1dd1a1]" />
              )}
            </button>
            <button
              onClick={() => {
                console.log('Setting mobile view to trade');
                setMobileView('trade');
              }}
              className={`flex-1 py-2 text-xs font-medium bg-[#000000] relative ${
                mobileView === 'trade' 
                  ? 'text-white' 
                  : 'text-gray-400 hover:text-white'
              }`}
            >
              Trade
              {mobileView === 'trade' && (
                <div className="absolute bottom-0 left-0 right-0 h-[2px] bg-[#1dd1a1]" />
              )}
            </button>
            <button
              onClick={() => {
                console.log('Setting mobile view to spot');
                setMobileView('spot');
              }}
              className={`flex-1 py-2 text-xs font-medium bg-[#000000] relative ${
                mobileView === 'spot' 
                  ? 'text-white' 
                  : 'text-gray-400 hover:text-white'
              }`}
            >
              Spot
              {mobileView === 'spot' && (
                <div className="absolute bottom-0 left-0 right-0 h-[2px] bg-[#1dd1a1]" />
              )}
            </button>
            <button
              onClick={() => {
                console.log('Setting mobile view to funds');
                setMobileView('funds');
              }}
              className={`flex-1 py-2 text-xs font-medium bg-[#000000] relative ${
                mobileView === 'funds' 
                  ? 'text-white' 
                  : 'text-gray-400 hover:text-white'
              }`}
            >
              Funds
              {mobileView === 'funds' && (
                <div className="absolute bottom-0 left-0 right-0 h-[2px] bg-[#1dd1a1]" />
              )}
            </button>
            <button
              onClick={() => {
                console.log('Setting mobile view to predictions');
                setMobileView('predictions');
              }}
              className={`flex-1 py-2 text-xs font-medium bg-[#000000] relative ${
                mobileView === 'predictions' 
                  ? 'text-white' 
                  : 'text-gray-400 hover:text-white'
              }`}
            >
              Predict
              {mobileView === 'predictions' && (
                <div className="absolute bottom-0 left-0 right-0 h-[2px] bg-[#1dd1a1]" />
              )}
            </button>
          </div>
        </div>

        {/* Mobile Content Area */}
        <div className="flex-1 overflow-hidden">
          {mobileView === 'markets' && (
            <HyperliquidMarkets 
              onSelectMarket={(market) => {
                setSelectedMarket(market);
                setMobileView('chart');
              }}
              autoSelectBTC={false}
            />
          )}

          {mobileView === 'chart' && (
            <div className="h-full flex flex-col">
              <div className="flex-1">
                <TradingViewChart 
                  symbol={tradingViewSymbol}
                  theme="dark"
                />
              </div>
              {authenticated && (
                <div className="border-t border-gray-800 h-48 overflow-y-auto">
                  <HyperliquidPositions address={address} />
                </div>
              )}
            </div>
          )}

          {mobileView === 'trade' && (
            <div className="h-full overflow-y-auto">
              <HyperliquidTradeForm
                selectedMarket={selectedMarket?.name || 'BTC'}
                currentPrice={parseFloat(selectedMarket?.markPx || '0')}
                maxLeverage={selectedMarket?.maxLeverage}
              />
            </div>
          )}

          {mobileView === 'spot' && (
            <div className="h-full overflow-y-auto p-4">
              <SimpleSpotTrading walletAddress={address} />
            </div>
          )}

          {mobileView === 'funds' && (
            <div className="h-full overflow-y-auto p-4">
              <HyperliquidDeposit />
            </div>
          )}

          {mobileView === 'predictions' && (
            <div className="h-full overflow-hidden">
              <PolymarketInterface />
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
```

---

## File: client/src/components/trading/market-data.tsx

```tsx
import { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { TrendingUp, TrendingDown, Activity } from "lucide-react";

interface MarketDataProps {
  symbols?: string[];
  height?: number;
  showHeader?: boolean;
}

interface MarketItem {
  symbol: string;
  price: string;
  change24h: string;
  volume: string;
  isPositive: boolean;
}

const generateMockData = (symbols: string[]): MarketItem[] => {
  return symbols.map(symbol => {
    const change = (Math.random() - 0.5) * 10;
    return {
      symbol,
      price: (Math.random() * 50000 + 1000).toFixed(2),
      change24h: change.toFixed(2),
      volume: (Math.random() * 1000000000).toFixed(0),
      isPositive: change > 0
    };
  });
};

export default function MarketData({ 
  symbols = ['BTC/USD', 'ETH/USD', 'SOL/USD', 'AVAX/USD', 'ARB/USD'],
  height,
  showHeader = true
}: MarketDataProps) {
  const [marketData, setMarketData] = useState<MarketItem[]>(generateMockData(symbols));
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    // Simulate real-time market data updates
    const interval = setInterval(() => {
      setMarketData(prevData => 
        prevData.map(item => {
          const priceChange = (Math.random() - 0.5) * 100;
          const newPrice = parseFloat(item.price) + priceChange;
          const newChange = parseFloat(item.change24h) + (Math.random() - 0.5) * 0.5;
          return {
            ...item,
            price: newPrice.toFixed(2),
            change24h: newChange.toFixed(2),
            isPositive: newChange > 0
          };
        })
      );
    }, 3000); // Update every 3 seconds

    return () => clearInterval(interval);
  }, [symbols]);

  const formatVolume = (volume: string) => {
    const num = parseFloat(volume);
    if (num >= 1e9) return `$${(num / 1e9).toFixed(2)}B`;
    if (num >= 1e6) return `$${(num / 1e6).toFixed(2)}M`;
    return `$${(num / 1e3).toFixed(2)}K`;
  };

  return (
    <Card className="h-full">
      {showHeader && (
        <CardHeader className="pb-3">
          <CardTitle className="flex items-center">
            <Activity className="w-5 h-5 mr-2" />
            Market Data
          </CardTitle>
        </CardHeader>
      )}
      <CardContent>
        <div className="space-y-3" style={{ maxHeight: height ? `${height - 100}px` : 'auto', overflowY: 'auto' }}>
          {marketData.map((item, index) => (
            <div key={index} className="bg-gray-50 rounded-lg p-4 hover:bg-gray-100 transition-colors">
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-lg">{item.symbol}</h4>
                <Badge 
                  variant={item.isPositive ? "default" : "destructive"}
                  className={`${item.isPositive ? 'bg-green-500' : 'bg-red-500'} text-white`}
                >
                  {item.isPositive ? <TrendingUp className="w-3 h-3 mr-1" /> : <TrendingDown className="w-3 h-3 mr-1" />}
                  {item.isPositive ? '+' : ''}{item.change24h}%
                </Badge>
              </div>
              <div className="flex justify-between items-end">
                <div>
                  <p className="text-2xl font-bold">${item.price}</p>
                  <p className="text-xs text-gray-500 mt-1">24h Volume</p>
                </div>
                <div className="text-right">
                  <p className="text-sm font-medium text-gray-600">{formatVolume(item.volume)}</p>
                </div>
              </div>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  );
}
```

---

## File: client/src/components/trading/orderbook.tsx

```tsx
import { useState, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { hyperliquidAPI } from "@/lib/hyperliquid";
import { OrderbookData } from "@/types";
import { TrendingUp, TrendingDown } from "lucide-react";

interface OrderbookProps {
  symbol: string;
  height?: number;
  showHeader?: boolean;
}

export default function Orderbook({ symbol, height = 400, showHeader = true }: OrderbookProps) {
  const [spread, setSpread] = useState<number>(0);
  const [midPrice, setMidPrice] = useState<number>(0);

  const { data: orderbook, isLoading, error } = useQuery({
    queryKey: ['/api/hyperliquid/orderbook', symbol],
    queryFn: () => hyperliquidAPI.getOrderbook(symbol),
    refetchInterval: 5000, // Update every 5 seconds
    enabled: !!symbol
  });

  useEffect(() => {
    if (orderbook?.bids?.length && orderbook?.asks?.length) {
      const bestBid = parseFloat(orderbook.bids[0][0]);
      const bestAsk = parseFloat(orderbook.asks[0][0]);
      const currentSpread = bestAsk - bestBid;
      const currentMidPrice = (bestBid + bestAsk) / 2;
      
      setSpread(currentSpread);
      setMidPrice(currentMidPrice);
    }
  }, [orderbook]);

  const formatPrice = (price: string | number) => {
    return parseFloat(price.toString()).toFixed(2);
  };

  const formatSize = (size: string | number) => {
    return parseFloat(size.toString()).toFixed(4);
  };

  const formatSpread = (spread: number) => {
    return spread.toFixed(2);
  };

  if (isLoading) {
    return (
      <Card className="w-full" style={{ height }}>
        {showHeader && (
          <CardHeader className="pb-3">
            <CardTitle className="flex items-center justify-between">
              <span>Order Book</span>
              <Skeleton className="h-6 w-20" />
            </CardTitle>
          </CardHeader>
        )}
        <CardContent>
          <div className="space-y-2">
            {[...Array(10)].map((_, i) => (
              <div key={i} className="flex justify-between">
                <Skeleton className="h-4 w-16" />
                <Skeleton className="h-4 w-20" />
                <Skeleton className="h-4 w-16" />
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card className="w-full" style={{ height }}>
        {showHeader && (
          <CardHeader className="pb-3">
            <CardTitle>Order Book</CardTitle>
          </CardHeader>
        )}
        <CardContent>
          <div className="text-center py-8 text-red-500">
            <p>Failed to load order book</p>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="w-full" style={{ height }}>
      {showHeader && (
        <CardHeader className="pb-3">
          <CardTitle className="flex items-center justify-between">
            <span>Order Book</span>
            <Badge variant="outline">{symbol}</Badge>
          </CardTitle>
          <div className="flex items-center justify-between text-sm text-gray-600">
            <span>Spread: ${formatSpread(spread)}</span>
            <span>Mid: ${formatPrice(midPrice)}</span>
          </div>
        </CardHeader>
      )}
      <CardContent className="p-0">
        <div className="grid grid-cols-2 gap-0 h-full">
          {/* Bids */}
          <div className="border-r">
            <div className="bg-gray-50 px-3 py-2 text-xs font-medium text-gray-600 border-b">
              <div className="flex justify-between">
                <span>Price</span>
                <span>Size</span>
              </div>
            </div>
            <div className="overflow-y-auto" style={{ height: height - 120 }}>
              {orderbook?.bids?.slice(0, 15).map((bid, index) => (
                <div
                  key={index}
                  className="flex justify-between items-center px-3 py-1 text-xs hover:bg-green-50 border-b border-gray-100"
                >
                  <div className="flex items-center space-x-2">
                    <TrendingUp className="w-3 h-3 text-green-500" />
                    <span className="font-mono text-green-600">{formatPrice(bid[0])}</span>
                  </div>
                  <span className="font-mono text-gray-600">{formatSize(bid[1])}</span>
                </div>
              ))}
            </div>
          </div>

          {/* Asks */}
          <div>
            <div className="bg-gray-50 px-3 py-2 text-xs font-medium text-gray-600 border-b">
              <div className="flex justify-between">
                <span>Price</span>
                <span>Size</span>
              </div>
            </div>
            <div className="overflow-y-auto" style={{ height: height - 120 }}>
              {orderbook?.asks?.slice(0, 15).map((ask, index) => (
                <div
                  key={index}
                  className="flex justify-between items-center px-3 py-1 text-xs hover:bg-red-50 border-b border-gray-100"
                >
                  <div className="flex items-center space-x-2">
                    <TrendingDown className="w-3 h-3 text-red-500" />
                    <span className="font-mono text-red-600">{formatPrice(ask[0])}</span>
                  </div>
                  <span className="font-mono text-gray-600">{formatSize(ask[1])}</span>
                </div>
              ))}
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

```

---

## File: client/src/components/trading/PolymarketInterface.tsx

```tsx
import React, { useState, useEffect } from 'react';
import { usePrivy } from '@privy-io/react-auth';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Badge } from '@/components/ui/badge';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Loader2, TrendingUp, AlertCircle, DollarSign } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';

interface Market {
  id: string;
  question: string;
  category: string;
  volume: number;
  liquidity: number;
  endDate: string;
  outcomes: {
    id: string;
    name: string;
    price: number;
    probability: number;
  }[];
}

export function PolymarketInterface() {
  const { authenticated, user, getEthereumProvider } = usePrivy();
  const [loading, setLoading] = useState(false);
  const [currentNetwork, setCurrentNetwork] = useState<string>('');
  const [markets, setMarkets] = useState<Market[]>([]);
  const [selectedMarket, setSelectedMarket] = useState<Market | null>(null);
  const [betAmount, setBetAmount] = useState('');
  const [selectedOutcome, setSelectedOutcome] = useState<string>('');
  const [selectedCategory, setSelectedCategory] = useState<string>('All');
  const { toast } = useToast();

  // Check current network only if authenticated
  useEffect(() => {
    if (authenticated) {
      checkNetwork();
    }
  }, [authenticated]);

  const checkNetwork = async () => {
    if (!authenticated) return;
    
    try {
      const provider = await getEthereumProvider();
      if (provider) {
        const chainId = await provider.request({ method: 'eth_chainId' });
        setCurrentNetwork(chainId);
      }
    } catch (error) {
      console.error('Error checking network:', error);
    }
  };

  // Switch to Polygon network
  const switchToPolygon = async () => {
    try {
      if (!authenticated) {
        toast({
          title: "Connect wallet first",
          description: "Please connect your wallet to place predictions",
          variant: "destructive",
        });
        return;
      }

      const provider = await getEthereumProvider();
      if (!provider) {
        toast({
          title: "Wallet not connected",
          description: "Please connect your wallet first",
          variant: "destructive",
        });
        return;
      }

      setLoading(true);
      
      // Polygon network parameters
      const polygonChainId = '0x89'; // 137 in hex
      
      try {
        // Try to switch to Polygon
        await provider.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: polygonChainId }],
        });
        
        setCurrentNetwork(polygonChainId);
        toast({
          title: "Network switched",
          description: "Successfully switched to Polygon network",
        });
      } catch (switchError: any) {
        // If the chain is not added, add it
        if (switchError.code === 4902) {
          await provider.request({
            method: 'wallet_addEthereumChain',
            params: [{
              chainId: polygonChainId,
              chainName: 'Polygon',
              nativeCurrency: {
                name: 'MATIC',
                symbol: 'MATIC',
                decimals: 18,
              },
              rpcUrls: ['https://polygon-rpc.com/'],
              blockExplorerUrls: ['https://polygonscan.com/'],
            }],
          });
          
          setCurrentNetwork(polygonChainId);
          toast({
            title: "Network added",
            description: "Polygon network added and switched successfully",
          });
        } else {
          throw switchError;
        }
      }
    } catch (error) {
      console.error('Error switching network:', error);
      toast({
        title: "Network switch failed",
        description: "Failed to switch to Polygon network",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  // Fetch sample markets - always load them, regardless of auth status
  useEffect(() => {
    fetchMarkets();
  }, []);

  const fetchMarkets = async () => {
    // Sample data for testing
    const sampleMarkets: Market[] = [
      {
        id: '1',
        question: 'Will BTC reach $150,000 by March 2025?',
        category: 'Crypto',
        volume: 2500000,
        liquidity: 500000,
        endDate: '2025-03-31',
        outcomes: [
          { id: 'yes', name: 'Yes', price: 0.35, probability: 35 },
          { id: 'no', name: 'No', price: 0.65, probability: 65 }
        ]
      },
      {
        id: '2',
        question: 'Will the Fed cut rates in Q1 2025?',
        category: 'Economics',
        volume: 1800000,
        liquidity: 400000,
        endDate: '2025-03-31',
        outcomes: [
          { id: 'yes', name: 'Yes', price: 0.72, probability: 72 },
          { id: 'no', name: 'No', price: 0.28, probability: 28 }
        ]
      },
      {
        id: '3',
        question: 'Will ETH ETF see $1B inflows by February?',
        category: 'Crypto',
        volume: 950000,
        liquidity: 200000,
        endDate: '2025-02-28',
        outcomes: [
          { id: 'yes', name: 'Yes', price: 0.45, probability: 45 },
          { id: 'no', name: 'No', price: 0.55, probability: 55 }
        ]
      },
      {
        id: '4',
        question: 'Will SOL reach $250 before ETH reaches $5000?',
        category: 'Crypto',
        volume: 1200000,
        liquidity: 300000,
        endDate: '2025-06-30',
        outcomes: [
          { id: 'yes', name: 'Yes', price: 0.62, probability: 62 },
          { id: 'no', name: 'No', price: 0.38, probability: 38 }
        ]
      },
      {
        id: '5',
        question: 'Will Trump launch a crypto token in 2025?',
        category: 'Politics',
        volume: 3200000,
        liquidity: 800000,
        endDate: '2025-12-31',
        outcomes: [
          { id: 'yes', name: 'Yes', price: 0.41, probability: 41 },
          { id: 'no', name: 'No', price: 0.59, probability: 59 }
        ]
      },
      {
        id: '6',
        question: 'Will CPI be below 2.5% by April 2025?',
        category: 'Economics',
        volume: 875000,
        liquidity: 150000,
        endDate: '2025-04-30',
        outcomes: [
          { id: 'yes', name: 'Yes', price: 0.28, probability: 28 },
          { id: 'no', name: 'No', price: 0.72, probability: 72 }
        ]
      },
      {
        id: '7',
        question: 'Will Chiefs win Super Bowl LIX?',
        category: 'Sports',
        volume: 4500000,
        liquidity: 1200000,
        endDate: '2025-02-09',
        outcomes: [
          { id: 'yes', name: 'Yes', price: 0.38, probability: 38 },
          { id: 'no', name: 'No', price: 0.62, probability: 62 }
        ]
      },
      {
        id: '8',
        question: 'Will Lakers make NBA playoffs 2025?',
        category: 'Sports',
        volume: 2300000,
        liquidity: 600000,
        endDate: '2025-04-15',
        outcomes: [
          { id: 'yes', name: 'Yes', price: 0.67, probability: 67 },
          { id: 'no', name: 'No', price: 0.33, probability: 33 }
        ]
      }
    ];
    
    setMarkets(sampleMarkets);
  };

  const placeBet = async () => {
    if (!selectedMarket || !selectedOutcome || !betAmount) {
      toast({
        title: "Missing information",
        description: "Please select a market, outcome, and enter an amount",
        variant: "destructive",
      });
      return;
    }

    // Check authentication first
    if (!authenticated) {
      toast({
        title: "Connect wallet",
        description: "Please connect your wallet to place predictions",
        variant: "destructive",
      });
      return;
    }

    // Check network
    if (currentNetwork !== '0x89') {
      await switchToPolygon();
      return;
    }

    const platformFee = parseFloat(betAmount) * 0.005; // 0.5% fee
    const totalAmount = parseFloat(betAmount) + platformFee;

    toast({
      title: "Bet placement",
      description: `Total: $${totalAmount.toFixed(2)} (includes $${platformFee.toFixed(2)} platform fee)`,
    });

    // In production, this would interact with Polymarket contracts
  };



  return (
    <div className="flex flex-col h-full bg-[#0a0a0a] text-white">
      <div className="px-4 py-3 border-b border-gray-800 flex-shrink-0">
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-semibold">Prediction Markets</h2>
          <Badge variant="secondary" className="bg-purple-600/20 text-purple-400 text-[10px] px-2 py-0.5">
            Premium
          </Badge>
        </div>
      </div>

      <div className="flex-1 flex overflow-hidden">
        {/* Markets List */}
        <div className={`${selectedMarket ? 'w-2/3 border-r' : 'w-full'} border-gray-800 flex flex-col`}>
          {/* Category Filter */}
          <div className="p-3 border-b border-gray-800 overflow-x-auto custom-scrollbar-horizontal flex-shrink-0">
            <div className="flex gap-2 min-w-max">
              {['All', 'Crypto', 'Politics', 'Economics', 'Sports'].map((category) => (
                <Button
                  key={category}
                  variant={selectedCategory === category ? "default" : "outline"}
                  size="sm"
                  className={`h-7 text-xs whitespace-nowrap flex-shrink-0 ${
                    selectedCategory === category 
                      ? 'bg-purple-600 hover:bg-purple-700 border-purple-600' 
                      : 'bg-[#0d0d0d] border-gray-700 hover:border-purple-600 text-gray-300'
                  }`}
                  onClick={() => setSelectedCategory(category)}
                >
                  {category}
                </Button>
              ))}
            </div>
          </div>
          
          <div className="flex-1 overflow-y-auto custom-scrollbar p-3 space-y-2">
            {markets
              .filter(market => selectedCategory === 'All' || market.category === selectedCategory)
              .map((market) => (
              <Card 
                key={market.id}
                className={`p-3 cursor-pointer transition-all ${
                  selectedMarket?.id === market.id 
                    ? 'bg-purple-900/20 border-purple-600/50 ring-1 ring-purple-600/50' 
                    : 'bg-[#0d0d0d] border-gray-800 hover:bg-[#1a1a1a] hover:border-gray-700'
                }`}
                onClick={() => setSelectedMarket(market)}
              >
                <div className="space-y-2">
                  <p className="text-sm font-medium leading-tight text-white">{market.question}</p>
                  <div className="flex items-center space-x-3 text-xs text-gray-500">
                    <Badge variant="outline" className="text-[10px] px-1.5 py-0 border-gray-600 text-gray-300">
                      {market.category}
                    </Badge>
                    <span>Vol: ${(market.volume / 1000000).toFixed(1)}M</span>
                    <span>Ends: {new Date(market.endDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</span>
                  </div>
                  <div className="grid grid-cols-2 gap-2">
                    {market.outcomes.map((outcome) => (
                      <div key={outcome.id} className={`
                        rounded px-3 py-1.5 text-center
                        ${outcome.name === 'Yes' 
                          ? 'bg-green-950/50 border border-green-900/50' 
                          : 'bg-red-950/50 border border-red-900/50'
                        }
                      `}>
                        <p className="text-[10px] text-gray-300">{outcome.name}</p>
                        <p className="text-base font-bold text-white">
                          {outcome.probability}%
                        </p>
                        <p className="text-[10px] text-gray-400">${outcome.price}</p>
                      </div>
                    ))}
                  </div>
                </div>
              </Card>
            ))}
          </div>
        </div>

        {/* Betting Interface */}
        {selectedMarket && (
          <div className="flex-1 overflow-y-auto custom-scrollbar">
            <div className="p-4 space-y-4">
              <Card className="bg-[#0d0d0d] border-gray-800 p-4">
                <h3 className="text-sm font-semibold mb-3">{selectedMarket.question}</h3>
                
                <div className="space-y-3">
                  <div className="grid grid-cols-2 gap-2">
                    {selectedMarket.outcomes.map((outcome) => (
                      <Button
                        key={outcome.id}
                        variant={selectedOutcome === outcome.id ? "default" : "outline"}
                        className={`h-14 ${
                          selectedOutcome === outcome.id 
                            ? outcome.name === 'Yes'
                              ? 'bg-green-600 hover:bg-green-700 border-green-600' 
                              : 'bg-red-600 hover:bg-red-700 border-red-600'
                            : 'bg-[#1a1a1a] border-gray-700 hover:border-gray-600'
                        }`}
                        onClick={() => setSelectedOutcome(outcome.id)}
                      >
                        <div>
                          <p className="text-xs">{outcome.name}</p>
                          <p className="text-lg font-bold">${outcome.price.toFixed(2)}</p>
                          <p className="text-[10px] text-gray-400">{outcome.probability}%</p>
                        </div>
                      </Button>
                    ))}
                  </div>

                  <div className="space-y-1.5">
                    <Label className="text-xs text-gray-400">Amount (USDC)</Label>
                    <Input
                      type="number"
                      placeholder="0.00"
                      value={betAmount}
                      onChange={(e) => setBetAmount(e.target.value)}
                      className="bg-black border-gray-700 h-9 text-sm"
                    />
                  </div>

                  {betAmount && selectedOutcome && (
                    <div className="bg-[#1a1a1a] rounded p-3 space-y-1.5 text-xs border border-gray-800">
                      <div className="flex justify-between">
                        <span className="text-gray-500">Shares</span>
                        <span className="font-mono">
                          {(parseFloat(betAmount) / 
                            (selectedMarket.outcomes.find(o => o.id === selectedOutcome)?.price || 1)
                          ).toFixed(2)}
                        </span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-500">Platform Fee (0.5%)</span>
                        <span className="font-mono">${(parseFloat(betAmount) * 0.005).toFixed(2)}</span>
                      </div>
                      <div className="flex justify-between font-semibold text-sm pt-1 border-t border-gray-800">
                        <span>Total</span>
                        <span className="font-mono">${(parseFloat(betAmount) * 1.005).toFixed(2)}</span>
                      </div>
                    </div>
                  )}

                  <Button 
                    className="w-full bg-purple-600 hover:bg-purple-700 h-9 text-sm font-semibold"
                    onClick={placeBet}
                    disabled={!selectedOutcome || !betAmount}
                  >
                    Place Prediction
                  </Button>
                </div>
              </Card>

              <Card className="bg-[#0d0d0d] border-gray-800 p-3">
                <h4 className="text-xs font-semibold mb-2 text-gray-400">MARKET INFO</h4>
                <div className="space-y-1 text-xs">
                  <div className="flex justify-between">
                    <span className="text-gray-500">Volume</span>
                    <span className="font-mono">${(selectedMarket.volume / 1000000).toFixed(2)}M</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-500">Liquidity</span>
                    <span className="font-mono">${(selectedMarket.liquidity / 1000000).toFixed(2)}M</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-500">Ends</span>
                    <span>{new Date(selectedMarket.endDate).toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}</span>
                  </div>
                </div>
              </Card>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
```

---

## File: client/src/components/trading/portfolio.tsx

```tsx
import { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Wallet, TrendingUp, TrendingDown, DollarSign } from "lucide-react";

interface PortfolioProps {
  height?: number;
  showHeader?: boolean;
}

interface Position {
  symbol: string;
  size: string;
  pnl: string;
  pnlPercent: string;
  avgPrice: string;
  currentPrice: string;
}

const mockPortfolio = {
  totalBalance: "125,432.87",
  availableBalance: "45,234.56",
  totalPnL: "+12,543.21",
  totalPnLPercent: "+11.13",
  positions: [
    {
      symbol: "BTC",
      size: "2.45",
      pnl: "+5,234.56",
      pnlPercent: "+15.23",
      avgPrice: "61,234.00",
      currentPrice: "63,345.67"
    },
    {
      symbol: "ETH",
      size: "18.76",
      pnl: "+3,456.78",
      pnlPercent: "+8.45",
      avgPrice: "3,234.56",
      currentPrice: "3,521.34"
    },
    {
      symbol: "SOL",
      size: "234.56",
      pnl: "-1,234.56",
      pnlPercent: "-4.56",
      avgPrice: "98.45",
      currentPrice: "94.12"
    }
  ]
};

export default function Portfolio({ height, showHeader = true }: PortfolioProps) {
  const [portfolio, setPortfolio] = useState(mockPortfolio);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    // Simulate real-time portfolio updates
    const interval = setInterval(() => {
      setPortfolio(prev => ({
        ...prev,
        totalBalance: (parseFloat(prev.totalBalance.replace(/,/g, '')) + (Math.random() - 0.5) * 100).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }),
        totalPnL: (parseFloat(prev.totalPnL.replace(/[+,]/g, '')) + (Math.random() - 0.5) * 10).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }),
      }));
    }, 10000); // Update every 10 seconds

    return () => clearInterval(interval);
  }, []);

  return (
    <Card className="h-full">
      {showHeader && (
        <CardHeader className="pb-3">
          <CardTitle className="flex items-center justify-between">
            <div className="flex items-center">
              <Wallet className="w-5 h-5 mr-2" />
              Portfolio
            </div>
            <Badge variant="secondary" className="text-xs">
              <DollarSign className="w-3 h-3 mr-1" />
              USDT
            </Badge>
          </CardTitle>
        </CardHeader>
      )}
      <CardContent className="space-y-4">
        {/* Account Summary */}
        <div className="grid grid-cols-2 gap-4 pb-4 border-b">
          <div>
            <p className="text-xs text-gray-500">Total Balance</p>
            <p className="text-lg font-semibold">${portfolio.totalBalance}</p>
          </div>
          <div>
            <p className="text-xs text-gray-500">Available</p>
            <p className="text-lg font-semibold">${portfolio.availableBalance}</p>
          </div>
          <div>
            <p className="text-xs text-gray-500">Total P&L</p>
            <p className={`text-lg font-semibold ${portfolio.totalPnL.startsWith('+') ? 'text-green-500' : 'text-red-500'}`}>
              {portfolio.totalPnL}
            </p>
          </div>
          <div>
            <p className="text-xs text-gray-500">P&L %</p>
            <p className={`text-lg font-semibold ${portfolio.totalPnLPercent.startsWith('+') ? 'text-green-500' : 'text-red-500'}`}>
              {portfolio.totalPnLPercent}%
            </p>
          </div>
        </div>

        {/* Positions */}
        <div>
          <h4 className="text-sm font-medium mb-3 flex items-center">
            Open Positions
            <Badge variant="outline" className="ml-2 text-xs">
              {portfolio.positions.length}
            </Badge>
          </h4>
          <div className="space-y-2" style={{ maxHeight: height ? `${height - 250}px` : 'auto', overflowY: 'auto' }}>
            {portfolio.positions.map((position, index) => (
              <div key={index} className="bg-gray-50 rounded-lg p-3">
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center">
                    <span className="font-medium">{position.symbol}</span>
                    <Badge variant="secondary" className="ml-2 text-xs">
                      {position.size}
                    </Badge>
                  </div>
                  <div className="text-right">
                    <div className={`flex items-center ${position.pnl.startsWith('+') ? 'text-green-500' : 'text-red-500'}`}>
                      {position.pnl.startsWith('+') ? <TrendingUp className="w-4 h-4 mr-1" /> : <TrendingDown className="w-4 h-4 mr-1" />}
                      <span className="font-medium">{position.pnl}</span>
                    </div>
                    <span className={`text-xs ${position.pnlPercent.startsWith('+') ? 'text-green-500' : 'text-red-500'}`}>
                      {position.pnlPercent}%
                    </span>
                  </div>
                </div>
                <div className="flex justify-between text-xs text-gray-500">
                  <span>Avg: ${position.avgPrice}</span>
                  <span>Current: ${position.currentPrice}</span>
                </div>
              </div>
            ))}
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
```

---

## File: client/src/components/trading/SimpleSpotTrading.tsx

```tsx
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { useToast } from "@/hooks/use-toast";
import { Loader2, TrendingUp, TrendingDown } from "lucide-react";
import { usePrivy } from "@privy-io/react-auth";

interface SpotPrice {
  symbol: string;
  price: number;
  change24h: number;
  volume24h: number;
}

export function SimpleSpotTrading({ walletAddress }: { walletAddress?: string }) {
  const { authenticated } = usePrivy();
  const { toast } = useToast();
  
  const [prices, setPrices] = useState<Record<string, SpotPrice>>({});
  const [balances, setBalances] = useState<Record<string, string>>({});
  const [loading, setLoading] = useState(true);
  const [placingOrder, setPlacingOrder] = useState(false);
  
  const [selectedPair, setSelectedPair] = useState("HYPE");
  const [orderSide, setOrderSide] = useState<"buy" | "sell">("buy");
  const [amount, setAmount] = useState("");
  
  // All requested tokens with availability status
  const tokenInfo = [
    { symbol: "BTC", available: true, actualSymbol: "UBTC" },
    { symbol: "ETH", available: true, actualSymbol: "UETH" },
    { symbol: "SOL", available: true, actualSymbol: "USOL" },
    { symbol: "FARTCOIN", available: false },
    { symbol: "PUMP", available: true },
    { symbol: "HYPE", available: true }
  ];

  useEffect(() => {
    fetchPrices();
    const interval = setInterval(fetchPrices, 5000);
    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    if (authenticated && walletAddress) {
      fetchBalances();
    }
  }, [authenticated, walletAddress]);

  const fetchPrices = async () => {
    try {
      const response = await fetch('/api/hyperliquid/spot-prices');
      if (!response.ok) throw new Error('Failed to fetch prices');
      
      const data = await response.json();
      setPrices(data);
      setLoading(false);
    } catch (error) {
      console.error('Error fetching spot prices:', error);
      setLoading(false);
    }
  };

  const fetchBalances = async () => {
    if (!walletAddress) return;
    
    try {
      const response = await fetch(`/api/hyperliquid/balances/${walletAddress}`);
      if (!response.ok) throw new Error('Failed to fetch balances');
      
      const data = await response.json();
      
      // Extract spot balances
      const spotBalances: Record<string, string> = {};
      if (data.balances) {
        data.balances.forEach((balance: any) => {
          spotBalances[balance.coin] = balance.total || "0";
        });
      }
      
      setBalances(spotBalances);
    } catch (error) {
      console.error('Error fetching balances:', error);
    }
  };

  const handleTrade = async () => {
    if (!authenticated || !walletAddress) {
      toast({
        title: "Connect Wallet",
        description: "Please connect your wallet to trade",
        variant: "destructive"
      });
      return;
    }

    if (!amount || parseFloat(amount) <= 0) {
      toast({
        title: "Invalid Amount",
        description: "Please enter a valid amount",
        variant: "destructive"
      });
      return;
    }

    setPlacingOrder(true);
    
    try {
      // Find the actual symbol to use for trading
      const tokenData = tokenInfo.find(t => t.symbol === selectedPair);
      const actualSymbol = tokenData?.actualSymbol || selectedPair;
      
      const response = await fetch('/api/hyperliquid/spot-order', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          symbol: actualSymbol,  // Use the actual trading symbol (UBTC, UETH, USOL)
          displaySymbol: selectedPair,  // Display symbol for UI feedback
          side: orderSide,
          amount: amount,
          // IMPORTANT: Lowercase the wallet address to avoid signature recovery issues
          walletAddress: walletAddress.toLowerCase()
        })
      });

      const result = await response.json();
      
      if (response.ok) {
        toast({
          title: "Order Submitted",
          description: `${orderSide.toUpperCase()} ${amount} ${selectedPair} order placed`,
        });
        setAmount("");
        fetchBalances(); // Refresh balances
      } else {
        throw new Error(result.error || 'Failed to place order');
      }
    } catch (error: any) {
      toast({
        title: "Order Failed",
        description: error.message || "Failed to place spot order",
        variant: "destructive"
      });
    } finally {
      setPlacingOrder(false);
    }
  };

  const calculateTotal = () => {
    const price = prices[selectedPair]?.price || 0;
    const qty = parseFloat(amount) || 0;
    return (price * qty).toFixed(2);
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center h-64">
        <Loader2 className="animate-spin h-8 w-8 text-gray-400" />
      </div>
    );
  }

  return (
    <div className="space-y-3">
      <Card className="bg-gray-900 border-gray-800">
        <CardHeader className="py-2 px-3">
          <CardTitle className="text-sm font-semibold text-white">Spot Trading</CardTitle>
        </CardHeader>
        <CardContent className="p-3 space-y-3">
          {/* Market List - Compact single column */}
          <div className="space-y-1.5 max-h-[300px] overflow-y-auto custom-scrollbar">
            {tokenInfo.map((token) => {
              const priceData = prices[token.symbol];
              const isSelected = selectedPair === token.symbol;
              const isAvailable = token.available && priceData;
              
              return (
                <div
                  key={token.symbol}
                  onClick={() => isAvailable && setSelectedPair(token.symbol)}
                  className={`flex items-center justify-between p-2 rounded transition-all ${
                    isAvailable 
                      ? `cursor-pointer ${isSelected ? 'bg-gray-700 border border-green-500' : 'bg-gray-800 hover:bg-gray-750'}`
                      : 'bg-gray-800 opacity-50 cursor-not-allowed'
                  }`}
                >
                  <div className="flex items-center gap-3">
                    <div>
                      <div className="font-medium text-xs text-white flex items-center gap-1">
                        {token.symbol}/USDC
                        {!isAvailable && (
                          <span className="text-[9px] text-yellow-400 bg-yellow-900/30 px-1 rounded">
                            Soon
                          </span>
                        )}
                      </div>
                      <div className="text-[10px] text-gray-400">
                        {isAvailable && priceData?.volume24h > 0 
                          ? `Vol: $${priceData.volume24h < 1000 
                            ? priceData.volume24h.toFixed(0)
                            : (priceData.volume24h / 1000000).toFixed(1) + 'M'}`
                          : 'Vol: --'}
                      </div>
                    </div>
                  </div>
                  <div className="text-right">
                    <div className="text-sm font-medium text-white">
                      {isAvailable && priceData?.price ? (
                        // Display prices directly from API without conversion
                        `$${priceData.price >= 1000 
                          ? priceData.price.toFixed(0) 
                          : priceData.price >= 1 
                          ? priceData.price.toFixed(2)
                          : priceData.price >= 0.01
                          ? priceData.price.toFixed(4)
                          : priceData.price.toFixed(6)}`
                      ) : '--'}
                    </div>
                    <div className={`text-[10px] ${
                      isAvailable 
                        ? (priceData?.change24h || 0) >= 0 ? 'text-green-400' : 'text-red-400'
                        : 'text-gray-500'
                    }`}>
                      {isAvailable && priceData?.change24h !== undefined
                        ? `${priceData.change24h >= 0 ? '+' : ''}${priceData.change24h.toFixed(2)}%`
                        : '--'}
                    </div>
                  </div>
                </div>
              );
            })}
          </div>

          {/* Trading Form */}
          <Card className="bg-gray-800 border-gray-700">
            <CardContent className="p-4 space-y-3">
              {/* Buy/Sell Toggle */}
              <div className="grid grid-cols-2 gap-2">
                <Button
                  onClick={() => setOrderSide("buy")}
                  className={`h-10 ${
                    orderSide === "buy"
                      ? "bg-green-600 hover:bg-green-700 text-white"
                      : "bg-gray-700 hover:bg-gray-600 text-gray-300"
                  }`}
                >
                  Buy {selectedPair}
                </Button>
                <Button
                  onClick={() => setOrderSide("sell")}
                  className={`h-10 ${
                    orderSide === "sell"
                      ? "bg-red-600 hover:bg-red-700 text-white"
                      : "bg-gray-700 hover:bg-gray-600 text-gray-300"
                  }`}
                >
                  Sell {selectedPair}
                </Button>
              </div>

              {/* Balance Display */}
              {authenticated && (
                <div className="text-xs text-gray-400">
                  Available: {balances[orderSide === "buy" ? "USDC" : selectedPair] || "0"} {orderSide === "buy" ? "USDC" : selectedPair}
                </div>
              )}

              {/* Amount Input */}
              <div>
                <div className="flex justify-between text-xs text-gray-400 mb-1">
                  <span>Amount</span>
                  <span>{selectedPair}</span>
                </div>
                <Input
                  type="number"
                  value={amount}
                  onChange={(e) => setAmount(e.target.value)}
                  placeholder="0.00"
                  className="bg-gray-900 border-gray-700 text-white"
                />
              </div>

              {/* Total Display */}
              <div className="border-t border-gray-700 pt-3">
                <div className="flex justify-between text-sm">
                  <span className="text-gray-400">Total</span>
                  <span className="font-medium text-white">${calculateTotal()} USDC</span>
                </div>
              </div>

              {/* Trade Button */}
              <Button
                onClick={handleTrade}
                disabled={!authenticated || placingOrder}
                className={`w-full h-10 font-medium ${
                  orderSide === "buy"
                    ? "bg-green-600 hover:bg-green-700"
                    : "bg-red-600 hover:bg-red-700"
                } text-white disabled:opacity-50`}
              >
                {placingOrder ? (
                  <Loader2 className="animate-spin h-4 w-4" />
                ) : authenticated ? (
                  `${orderSide.toUpperCase()} ${selectedPair}`
                ) : (
                  "Connect Wallet"
                )}
              </Button>
            </CardContent>
          </Card>

          {/* Info Card */}
          <Card className="bg-gray-800 border-gray-700">
            <CardContent className="p-3">
              <div className="text-xs text-gray-400 space-y-1">
                <p>• Spot trading on Hyperliquid DEX</p>
                <p>• No leverage, direct token swaps</p>
                <p>• 0.2% trading fee on all spot trades</p>
              </div>
            </CardContent>
          </Card>
        </CardContent>
      </Card>
    </div>
  );
}
```

---

## File: client/src/components/trading/TradeConfirmationDialog.tsx

```tsx
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { AlertCircle } from "lucide-react";

interface TradeConfirmationDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onConfirm: () => void;
  market: string;
  side: 'buy' | 'sell';
  size: number;
  price: number;
  leverage: number;
  isMarketOrder: boolean;
  markPrice: number;
  liquidationPrice?: number;
  notionalValue: number;
  requiredMargin: number;
  fee: number;
  isReduceOnly?: boolean;
  sizeMode?: 'asset' | 'usd';
  tpPrice?: number;
  slPrice?: number;
}

export function TradeConfirmationDialog({
  open,
  onOpenChange,
  onConfirm,
  market,
  side,
  size,
  price,
  leverage,
  isMarketOrder,
  markPrice,
  liquidationPrice,
  notionalValue,
  requiredMargin,
  fee,
  isReduceOnly,
  sizeMode = 'asset',
  tpPrice,
  slPrice
}: TradeConfirmationDialogProps) {
  const priceDisplay = isMarketOrder ? markPrice : price;
  const sideColor = side === 'buy' ? 'text-green-400' : 'text-red-400';
  const sideBgColor = side === 'buy' ? 'bg-green-900/20' : 'bg-red-900/20';

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-md bg-gray-900 text-white border-gray-700">
        <DialogHeader>
          <DialogTitle className="text-xl">Confirm Trade</DialogTitle>
          <DialogDescription className="text-gray-400">
            Review your order details before submitting
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4">
          {/* Market and Side */}
          <Card className="p-4 bg-gray-800 border-gray-700">
            <div className="flex justify-between items-center">
              <span className="text-gray-400">Market</span>
              <span className="font-semibold text-white">{market}</span>
            </div>
            <div className="flex justify-between items-center mt-2">
              <span className="text-gray-400">Side</span>
              <span className={`font-semibold uppercase ${sideColor} ${sideBgColor} px-2 py-1 rounded`}>
                {side}
              </span>
            </div>
          </Card>

          {/* Order Details */}
          <Card className="p-4 bg-gray-800 border-gray-700">
            <div className="space-y-2">
              <div className="flex justify-between">
                <span className="text-gray-400">Order Type</span>
                <span className="text-white">{isMarketOrder ? 'Market' : 'Limit'}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-400">Size</span>
                <span className="text-white">
                  {sizeMode === 'usd' ? `$${size.toFixed(2)} USD` : `${size.toLocaleString()} ${market}`}
                </span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-400">Price</span>
                <span className="text-white">${priceDisplay.toFixed(2)}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-400">Leverage</span>
                <span className="font-semibold text-white">{leverage}x</span>
              </div>
              {isReduceOnly && (
                <div className="flex justify-between">
                  <span className="text-gray-400">Reduce Only</span>
                  <span className="text-yellow-400">Yes</span>
                </div>
              )}
            </div>
          </Card>

          <Separator className="bg-gray-700" />

          {/* Position Details */}
          <Card className="p-4 bg-gray-800 border-gray-700">
            <h4 className="font-semibold mb-3 text-sm uppercase text-gray-400">Position Details</h4>
            <div className="space-y-2 text-sm">
              <div className="flex justify-between">
                <span className="text-gray-400">Notional Value</span>
                <span className="text-white">${notionalValue.toFixed(2)}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-400">Required Margin</span>
                <span className="text-white">${requiredMargin.toFixed(2)}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-400">Est. Fee (0.1%)</span>
                <span className="text-white">${fee.toFixed(2)}</span>
              </div>
              {liquidationPrice && (
                <div className="flex justify-between">
                  <span className="text-gray-400">Est. Liquidation Price</span>
                  <span className="text-orange-400 font-semibold">
                    ${liquidationPrice.toFixed(2)}
                  </span>
                </div>
              )}
            </div>
          </Card>

          {/* Take Profit / Stop Loss */}
          {(tpPrice || slPrice) && (
            <Card className="p-4 bg-gray-800 border-gray-700">
              <h4 className="font-semibold mb-3 text-sm uppercase text-gray-400">Risk Management</h4>
              <div className="space-y-2 text-sm">
                {tpPrice && (
                  <div className="flex justify-between">
                    <span className="text-gray-400">Take Profit</span>
                    <span className="text-green-400 font-semibold">
                      ${tpPrice.toFixed(2)}
                    </span>
                  </div>
                )}
                {slPrice && (
                  <div className="flex justify-between">
                    <span className="text-gray-400">Stop Loss</span>
                    <span className="text-red-400 font-semibold">
                      ${slPrice.toFixed(2)}
                    </span>
                  </div>
                )}
              </div>
            </Card>
          )}

          {/* Warning for high leverage */}
          {leverage >= 10 && (
            <div className="flex items-start space-x-2 p-3 bg-yellow-900/20 border border-yellow-700 rounded-lg">
              <AlertCircle className="h-5 w-5 text-yellow-400 mt-0.5" />
              <div className="text-sm">
                <p className="text-yellow-400 font-semibold">High Leverage Warning</p>
                <p className="text-gray-300 mt-1">
                  You are using {leverage}x leverage. High leverage increases both potential profits and losses.
                </p>
              </div>
            </div>
          )}
        </div>

        <DialogFooter className="sm:justify-between">
          <Button
            variant="outline"
            onClick={() => onOpenChange(false)}
            className="border-red-600 text-red-400 hover:bg-red-600 hover:text-white"
          >
            Cancel
          </Button>
          <Button
            onClick={onConfirm}
            className={side === 'buy' ? 'bg-green-600 hover:bg-green-700' : 'bg-red-600 hover:bg-red-700'}
          >
            Confirm {side === 'buy' ? 'Buy' : 'Sell'} Order
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

---

## File: client/src/components/trading/trade-form.tsx

```tsx
import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Badge } from "@/components/ui/badge";
import { Slider } from "@/components/ui/slider";
import { walletService } from "@/lib/wallet";
import { hyperliquidAPI } from "@/lib/hyperliquid";
import { useToast } from "@/hooks/use-toast";
import { TrendingUp, TrendingDown, Wallet, AlertCircle } from "lucide-react";

interface TradeFormProps {
  symbol: string;
  height?: number;
  showHeader?: boolean;
}

export default function TradeForm({ symbol, height = 400, showHeader = true }: TradeFormProps) {
  const [orderType, setOrderType] = useState<'limit' | 'market'>('limit');
  const [side, setSide] = useState<'buy' | 'sell'>('buy');
  const [price, setPrice] = useState('');
  const [quantity, setQuantity] = useState('');
  const [leverage, setLeverage] = useState([1]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { toast } = useToast();

  const walletState = walletService.getWalletState();

  const { data: marketData } = useQuery({
    queryKey: ['/api/hyperliquid/market-data', symbol],
    queryFn: () => hyperliquidAPI.getMarketData(symbol),
    refetchInterval: 5000,
    enabled: !!symbol
  });

  const { data: userState } = useQuery({
    queryKey: ['/api/hyperliquid/user-state', walletState.address],
    queryFn: () => hyperliquidAPI.getUserState(walletState.address!),
    enabled: !!walletState.address
  });

  const handleSubmitOrder = async () => {
    if (!walletState.isConnected) {
      toast({
        title: "Wallet not connected",
        description: "Please connect your wallet to place orders",
        variant: "destructive"
      });
      return;
    }

    if (!price || !quantity) {
      toast({
        title: "Invalid order",
        description: "Please enter both price and quantity",
        variant: "destructive"
      });
      return;
    }

    setIsSubmitting(true);
    
    try {
      const order = {
        symbol,
        side,
        orderType,
        price: orderType === 'limit' ? parseFloat(price) : undefined,
        quantity: parseFloat(quantity),
        leverage: leverage[0]
      };

      await hyperliquidAPI.placeOrder(walletState.address!, order);
      
      toast({
        title: "Order placed successfully",
        description: `${side.toUpperCase()} order for ${quantity} ${symbol} has been placed`
      });
      
      // Reset form
      setPrice('');
      setQuantity('');
    } catch (error) {
      toast({
        title: "Order failed",
        description: "Failed to place order. Please try again.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const getCurrentPrice = () => {
    if (marketData && typeof marketData === 'object') {
      return Object.values(marketData)[0] || '0';
    }
    return '0';
  };

  const calculateTotal = () => {
    if (!price || !quantity) return '0';
    return (parseFloat(price) * parseFloat(quantity)).toFixed(2);
  };

  const formatBalance = (balance: string | number) => {
    return parseFloat(balance.toString()).toFixed(4);
  };

  const currentPrice = getCurrentPrice();
  const total = calculateTotal();

  return (
    <Card className="w-full" style={{ height }}>
      {showHeader && (
        <CardHeader className="pb-3">
          <CardTitle className="flex items-center justify-between">
            <span>Trade</span>
            <Badge variant="outline">{symbol}</Badge>
          </CardTitle>
        </CardHeader>
      )}
      <CardContent className="p-4">
        <Tabs value={side} onValueChange={(value) => setSide(value as 'buy' | 'sell')}>
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="buy" className="text-green-600">
              <TrendingUp className="w-4 h-4 mr-2" />
              Buy
            </TabsTrigger>
            <TabsTrigger value="sell" className="text-red-600">
              <TrendingDown className="w-4 h-4 mr-2" />
              Sell
            </TabsTrigger>
          </TabsList>

          <TabsContent value="buy" className="space-y-4 mt-4">
            <TradeFormContent
              orderType={orderType}
              setOrderType={setOrderType}
              price={price}
              setPrice={setPrice}
              quantity={quantity}
              setQuantity={setQuantity}
              leverage={leverage}
              setLeverage={setLeverage}
              currentPrice={currentPrice}
              total={total}
              side="buy"
              isSubmitting={isSubmitting}
              onSubmit={handleSubmitOrder}
              walletConnected={walletState.isConnected}
              balance={walletState.balance || '0'}
            />
          </TabsContent>

          <TabsContent value="sell" className="space-y-4 mt-4">
            <TradeFormContent
              orderType={orderType}
              setOrderType={setOrderType}
              price={price}
              setPrice={setPrice}
              quantity={quantity}
              setQuantity={setQuantity}
              leverage={leverage}
              setLeverage={setLeverage}
              currentPrice={currentPrice}
              total={total}
              side="sell"
              isSubmitting={isSubmitting}
              onSubmit={handleSubmitOrder}
              walletConnected={walletState.isConnected}
              balance={walletState.balance || '0'}
            />
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  );
}

interface TradeFormContentProps {
  orderType: 'limit' | 'market';
  setOrderType: (type: 'limit' | 'market') => void;
  price: string;
  setPrice: (price: string) => void;
  quantity: string;
  setQuantity: (quantity: string) => void;
  leverage: number[];
  setLeverage: (leverage: number[]) => void;
  currentPrice: string;
  total: string;
  side: 'buy' | 'sell';
  isSubmitting: boolean;
  onSubmit: () => void;
  walletConnected: boolean;
  balance: string;
}

function TradeFormContent({
  orderType,
  setOrderType,
  price,
  setPrice,
  quantity,
  setQuantity,
  leverage,
  setLeverage,
  currentPrice,
  total,
  side,
  isSubmitting,
  onSubmit,
  walletConnected,
  balance
}: TradeFormContentProps) {
  return (
    <div className="space-y-4">
      <div>
        <Label htmlFor="order-type">Order Type</Label>
        <Select value={orderType} onValueChange={(value) => setOrderType(value as 'limit' | 'market')}>
          <SelectTrigger>
            <SelectValue placeholder="Select order type" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="limit">Limit Order</SelectItem>
            <SelectItem value="market">Market Order</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {orderType === 'limit' && (
        <div>
          <Label htmlFor="price">Price</Label>
          <Input
            id="price"
            type="number"
            value={price}
            onChange={(e) => setPrice(e.target.value)}
            placeholder={currentPrice}
            step="0.01"
          />
          <div className="text-xs text-gray-500 mt-1">
            Current: ${currentPrice}
          </div>
        </div>
      )}

      <div>
        <Label htmlFor="quantity">Quantity</Label>
        <Input
          id="quantity"
          type="number"
          value={quantity}
          onChange={(e) => setQuantity(e.target.value)}
          placeholder="0.00"
          step="0.0001"
        />
      </div>

      <div>
        <Label>Leverage: {leverage[0]}x</Label>
        <Slider
          value={leverage}
          onValueChange={setLeverage}
          max={20}
          min={1}
          step={1}
          className="mt-2"
        />
        <div className="flex justify-between text-xs text-gray-500 mt-1">
          <span>1x</span>
          <span>20x</span>
        </div>
      </div>

      <div className="bg-gray-50 p-3 rounded-lg">
        <div className="flex justify-between items-center mb-2">
          <span className="text-sm text-gray-600">Total</span>
          <span className="font-semibold">${total}</span>
        </div>
        <div className="flex justify-between items-center">
          <span className="text-sm text-gray-600">Available</span>
          <div className="flex items-center space-x-2">
            <Wallet className="w-4 h-4 text-gray-400" />
            <span className="text-sm">{balance} ETH</span>
          </div>
        </div>
      </div>

      {!walletConnected && (
        <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-3">
          <div className="flex items-center space-x-2">
            <AlertCircle className="w-4 h-4 text-yellow-600" />
            <span className="text-sm text-yellow-800">
              Connect your wallet to place orders
            </span>
          </div>
        </div>
      )}

      <Button
        onClick={onSubmit}
        disabled={!walletConnected || isSubmitting || !quantity}
        className={`w-full ${
          side === 'buy' 
            ? 'bg-green-500 hover:bg-green-600' 
            : 'bg-red-500 hover:bg-red-600'
        }`}
      >
        {isSubmitting ? 'Placing Order...' : `${side.toUpperCase()} ${quantity || '0'}`}
      </Button>
    </div>
  );
}

```

---

## File: client/src/components/trading/TradingViewChart.tsx

```tsx
import React, { useMemo, memo, useState, useEffect } from 'react';

interface TradingViewChartProps {
  symbol: string;
  theme?: 'light' | 'dark';
}

// Memoize the chart component to prevent re-renders unless symbol or theme changes
export const TradingViewChart = memo(({ symbol = 'BTCUSDT', theme = 'dark' }: TradingViewChartProps) => {
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);
  
  // Ensure we have a valid symbol
  const validSymbol = symbol && symbol.length > 0 ? symbol : 'BTCUSDT';
  
  // Try simplified URL first for better desktop compatibility
  const embedUrl = useMemo(() => {
    // Simplified URL that works better with strict browser security
    return `https://www.tradingview.com/widgetembed/?symbol=BINANCE:${validSymbol}&interval=D&theme=${theme}&style=1&locale=en&enable_publishing=false&allow_symbol_change=false&container_id=tradingview_${Date.now()}`;
  }, [validSymbol, theme]);

  // Reset loading state when symbol changes
  useEffect(() => {
    setIsLoading(true);
    setHasError(false);
  }, [validSymbol]);

  // Add timeout for slow loading
  useEffect(() => {
    const timer = setTimeout(() => {
      if (isLoading) {
        setHasError(true);
      }
    }, 15000); // 15 second timeout

    return () => clearTimeout(timer);
  }, [isLoading]);

  const handleLoad = () => {
    setIsLoading(false);
    setHasError(false);
  };

  const handleError = () => {
    setIsLoading(false);
    setHasError(true);
  };

  const handleRetry = () => {
    setIsLoading(true);
    setHasError(false);
    // Force iframe reload by changing key
    window.location.reload();
  };

  return (
    <div className="h-full w-full relative bg-[#131313]">
      {(isLoading || hasError) && (
        <div className="absolute inset-0 flex items-center justify-center bg-[#131313] z-10">
          <div className="flex flex-col items-center p-4">
            {hasError ? (
              <>
                <div className="text-yellow-500 mb-4">
                  <svg className="w-12 h-12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                  </svg>
                </div>
                <p className="text-gray-300 text-sm font-semibold mb-2">TradingView Chart Loading Slowly</p>
                <p className="text-gray-500 text-xs text-center mb-4">
                  TradingView may be blocked by browser extensions or security settings.
                </p>
                <div className="flex flex-col items-center space-y-3">
                  <button 
                    onClick={handleRetry}
                    className="px-4 py-2 bg-liquid-green text-black rounded hover:bg-liquid-accent transition-colors text-sm font-medium"
                  >
                    Retry Loading
                  </button>
                  <a 
                    href={`https://www.tradingview.com/chart/?symbol=BINANCE:${validSymbol}`}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-liquid-green text-xs hover:underline"
                  >
                    Open TradingView in new tab →
                  </a>
                </div>
                <div className="text-gray-600 text-xs mt-4 text-center space-y-1">
                  <p>If charts aren't loading on desktop:</p>
                  <p>• Disable ad blockers temporarily</p>
                  <p>• Try a different browser</p>
                  <p>• Check firewall settings</p>
                </div>
              </>
            ) : (
              <>
                <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-liquid-green"></div>
                <p className="mt-4 text-gray-400 text-sm">Loading TradingView Chart...</p>
                <p className="mt-2 text-gray-500 text-xs">This may take a moment during peak hours</p>
              </>
            )}
          </div>
        </div>
      )}
      <iframe
        key={`${validSymbol}-${theme}-${hasError ? 'retry' : 'normal'}`}
        src={embedUrl}
        style={{ 
          width: '100%', 
          height: '100%', 
          border: 'none', 
          display: isLoading && !hasError ? 'none' : 'block',
          position: 'absolute',
          top: 0,
          left: 0
        }}
        frameBorder={0}
        scrolling="no"
        allowFullScreen
        allow="clipboard-write; fullscreen"
        onLoad={handleLoad}
        onError={handleError}
        loading="eager"
        referrerPolicy="no-referrer"
        title={`TradingView Chart - ${validSymbol}`}
      />
    </div>
  );
}, (prevProps, nextProps) => {
  // Only re-render if symbol or theme actually changes
  return prevProps.symbol === nextProps.symbol && prevProps.theme === nextProps.theme;
});
```

---

## File: client/src/components/TrustIndicators.tsx

```tsx
import { Shield, CheckCircle, Lock, Info } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { useState } from "react";

interface TrustIndicatorsProps {
  platformName: string;
  platformId: number;
  builderCode: string;
  customDomain?: string;
  verificationCode?: string;
}

export function TrustIndicators({ 
  platformName, 
  platformId, 
  builderCode,
  customDomain,
  verificationCode 
}: TrustIndicatorsProps) {
  const [showDetails, setShowDetails] = useState(false);

  return (
    <div className="dark:bg-teal-950/20 border border-teal-200 dark:border-teal-800 rounded-md px-2 py-1 mb-1 bg-[#080505]">
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-1">
        <div className="flex flex-col sm:flex-row sm:items-center gap-1 sm:gap-4">
          <div className="flex items-center gap-1.5">
            <Shield className="w-3.5 h-3.5 text-teal-600 dark:text-teal-400" />
            <span className="text-[10px] font-medium text-teal-900 dark:text-teal-100">Secure Platform</span>
          </div>
          
          <TooltipProvider>
            <div className="flex flex-wrap items-center gap-2 sm:gap-3">
              <Tooltip>
                <TooltipTrigger asChild>
                  <div className="flex items-center gap-1">
                    <CheckCircle className="w-3 h-3 text-teal-600 dark:text-teal-400" />
                    <span className="text-[10px] text-teal-800 dark:text-teal-200">SSL</span>
                  </div>
                </TooltipTrigger>
                <TooltipContent>
                  <p>All data is encrypted using SSL/TLS certificates</p>
                </TooltipContent>
              </Tooltip>

              <Tooltip>
                <TooltipTrigger asChild>
                  <div className="flex items-center gap-1">
                    <Lock className="w-3 h-3 text-teal-600 dark:text-teal-400" />
                    <span className="text-[10px] text-teal-800 dark:text-teal-200">Privy</span>
                  </div>
                </TooltipTrigger>
                <TooltipContent>
                  <p>Enterprise-grade wallet security by Privy</p>
                </TooltipContent>
              </Tooltip>



              {verificationCode && (
                <Tooltip>
                  <TooltipTrigger asChild>
                    <div className="flex items-center gap-1 dark:bg-blue-900/30 px-1.5 py-0.5 rounded bg-[#0b0d0c]">
                      <Shield className="w-3 h-3 text-blue-600 dark:text-blue-400" />
                      <span className="text-[10px] text-blue-800 dark:text-blue-200 font-mono font-bold">{verificationCode}</span>
                    </div>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Verification code - verify at liquidlab.trade/verify</p>
                  </TooltipContent>
                </Tooltip>
              )}

              <Tooltip>
                <TooltipTrigger asChild>
                  <div className="flex items-center gap-2 overflow-visible">
                    <div className="relative">
                      <CheckCircle className="w-4 h-4 text-teal-600 dark:text-teal-400" />
                      <div className="absolute -top-0.5 -right-0.5 w-2 h-2 bg-teal-500 rounded-full animate-pulse"></div>
                    </div>
                    <img 
                      src="/powered-by-hyperliquid.png" 
                      alt="Connected to Hyperliquid" 
                      className="h-28 -my-10"
                    />
                  </div>
                </TooltipTrigger>
                <TooltipContent>
                  <p>Live connection to Hyperliquid DEX established</p>
                </TooltipContent>
              </Tooltip>
            </div>
          </TooltipProvider>
        </div>
        
        <Button
          variant="ghost"
          size="sm"
          onClick={() => setShowDetails(!showDetails)}
          className="text-[10px] text-teal-700 dark:text-teal-300 hover:bg-teal-100 dark:hover:bg-teal-900/20 h-5 px-2 self-start sm:self-auto"
        >
          {showDetails ? "Hide" : "Details"}
        </Button>
      </div>
      {showDetails && (
        <div className="mt-2 pt-2 border-t border-teal-200 dark:border-teal-800 space-y-2">
          <div className="bg-white dark:bg-gray-900 rounded p-2 space-y-1.5">
            <h4 className="font-medium text-xs text-gray-900 dark:text-gray-100">Security Features</h4>
            
            <div className="space-y-1 text-xs text-gray-600 dark:text-gray-400">
              <div className="flex items-start gap-1.5">
                <CheckCircle className="w-3 h-3 text-teal-500 mt-0.5" />
                <div>
                  <strong>Non-Custodial:</strong> Your wallet remains in your control
                </div>
              </div>
              
              <div className="flex items-start gap-1.5">
                <CheckCircle className="w-3 h-3 text-teal-500 mt-0.5" />
                <div>
                  <strong>Direct Trading:</strong> Trades execute on Hyperliquid DEX
                </div>
              </div>
              
              <div className="flex items-start gap-1.5">
                <CheckCircle className="w-3 h-3 text-teal-500 mt-0.5" />
                <div>
                  <strong>Transparent:</strong> Builder code <Badge variant="outline" className="ml-1 text-xs h-4 px-1">{builderCode}</Badge>
                </div>
              </div>
            </div>
          </div>

          <div className="bg-white dark:bg-gray-900 rounded p-2">
            <h4 className="font-medium text-xs text-gray-900 dark:text-gray-100 mb-1">Verify This Platform</h4>
            
            <ol className="space-y-0.5 text-xs text-gray-600 dark:text-gray-400 list-decimal list-inside">
              <li>Visit <a href="https://liquidlab.trade/verify" target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline">liquidlab.trade/verify</a></li>
              <li>Enter Verification Code: <strong>{verificationCode || `#${platformId}`}</strong></li>
              <li>Confirm the URL matches: <strong>{customDomain || window.location.hostname}</strong></li>
            </ol>
            
            <p className="text-xs text-gray-500 dark:text-gray-400 mt-2">
              Report suspicious platforms to <a href="mailto:security@liquidlab.trade" className="text-blue-600 hover:underline">security@liquidlab.trade</a>
            </p>
          </div>
        </div>
      )}
    </div>
  );
}
```

---

## File: client/src/components/TwoFactorSetup.tsx

```tsx
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from "@/lib/queryClient";
import { queryClient } from "@/lib/queryClient";
import { Shield, Copy, Check } from "lucide-react";

interface TwoFactorSetupProps {
  enabled: boolean;
  onStatusChange: () => void;
}

export default function TwoFactorSetup({ enabled, onStatusChange }: TwoFactorSetupProps) {
  const { toast } = useToast();
  const [setupData, setSetupData] = useState<{
    qrCode: string;
    secret: string;
    backupCodes: string[];
  } | null>(null);
  const [verificationCode, setVerificationCode] = useState("");
  const [password, setPassword] = useState("");
  const [isSetupDialogOpen, setIsSetupDialogOpen] = useState(false);
  const [isDisableDialogOpen, setIsDisableDialogOpen] = useState(false);
  const [copiedIndex, setCopiedIndex] = useState<number | null>(null);
  const [loading, setLoading] = useState(false);

  const handleSetup = async () => {
    try {
      setLoading(true);
      const response = await apiRequest("GET", "/api/auth/2fa/setup");
      const data = await response.json();
      console.log("2FA Setup Response:", data);
      
      if (!data || !data.qrCode || !data.secret || !data.backupCodes) {
        throw new Error("Invalid 2FA setup response");
      }
      
      setSetupData(data);
      setIsSetupDialogOpen(true);
    } catch (error: any) {
      console.error("2FA Setup Error:", error);
      toast({
        title: "Setup Failed",
        description: error.message || "Failed to initialize 2FA setup",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  const handleEnable = async () => {
    try {
      setLoading(true);
      const response = await apiRequest("POST", "/api/auth/2fa/enable", { totp: verificationCode });
      const data = await response.json();
      
      if (data.success) {
        toast({
          title: "2FA Enabled",
          description: "Two-factor authentication has been successfully enabled for your account.",
        });
        
        setIsSetupDialogOpen(false);
        setSetupData(null);
        setVerificationCode("");
        onStatusChange();
      } else {
        throw new Error(data.error || "Failed to enable 2FA");
      }
    } catch (error: any) {
      toast({
        title: "Verification Failed",
        description: error.message || "Invalid verification code",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  const handleDisable = async () => {
    try {
      setLoading(true);
      const response = await apiRequest("POST", "/api/auth/2fa/disable", { password });
      const data = await response.json();
      
      if (data.success) {
        toast({
          title: "2FA Disabled",
          description: "Two-factor authentication has been disabled for your account.",
        });
        
        setIsDisableDialogOpen(false);
        setPassword("");
        onStatusChange();
      } else {
        throw new Error(data.error || "Failed to disable 2FA");
      }
    } catch (error: any) {
      toast({
        title: "Disable Failed",
        description: error.message || "Invalid password",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  const copyBackupCode = (code: string, index: number) => {
    navigator.clipboard.writeText(code);
    setCopiedIndex(index);
    setTimeout(() => setCopiedIndex(null), 2000);
  };

  return (
    <>
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Shield className="h-5 w-5" />
            Two-Factor Authentication
          </CardTitle>
          <CardDescription>
            Add an extra layer of security to your account
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <div className={`flex items-center justify-between p-4 rounded-lg ${
              enabled ? 'bg-green-50 dark:bg-green-950' : 'bg-gray-50 dark:bg-gray-900'
            }`}>
              <div>
                <p className="font-medium">
                  Status: <span className={enabled ? 'text-green-600 dark:text-green-400' : 'text-gray-600 dark:text-gray-400'}>
                    {enabled ? 'Enabled' : 'Disabled'}
                  </span>
                </p>
                <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                  {enabled 
                    ? 'Your account is protected with 2FA' 
                    : 'Enable 2FA to secure your account'}
                </p>
              </div>
              <Button
                onClick={enabled ? () => setIsDisableDialogOpen(true) : handleSetup}
                variant={enabled ? "destructive" : "default"}
                disabled={loading}
              >
                {enabled ? 'Disable 2FA' : 'Enable 2FA'}
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Setup Dialog */}
      <Dialog open={isSetupDialogOpen} onOpenChange={setIsSetupDialogOpen}>
        <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>Set Up Two-Factor Authentication</DialogTitle>
            <DialogDescription>
              Follow these steps to enable 2FA on your account
            </DialogDescription>
          </DialogHeader>
          
          {setupData && (
            <div className="space-y-4 pb-4">
              <div>
                <h3 className="font-medium mb-1 text-sm">Step 1: Scan QR Code</h3>
                <p className="text-xs text-gray-600 dark:text-gray-400 mb-2">
                  Scan this QR code with your authenticator app (Google Authenticator, Authy, etc.)
                </p>
                <div className="flex justify-center mb-2">
                  {setupData.qrCode ? (
                    <img src={setupData.qrCode} alt="2FA QR Code" className="border rounded h-48 w-48" />
                  ) : (
                    <div className="p-4 border rounded bg-gray-50 dark:bg-gray-900">
                      <p className="text-sm text-gray-600">QR Code loading...</p>
                    </div>
                  )}
                </div>
                <p className="text-xs text-gray-500 dark:text-gray-500 text-center">
                  Can't scan? Enter manually: <code className="bg-gray-100 dark:bg-gray-800 px-1 rounded text-xs">{setupData.secret}</code>
                </p>
              </div>

              <div>
                <h3 className="font-medium mb-1 text-sm">Step 2: Save Backup Codes</h3>
                <p className="text-xs text-gray-600 dark:text-gray-400 mb-2">
                  Save these backup codes. Use them if you lose your authenticator.
                </p>
                <div className="grid grid-cols-2 gap-1 text-xs max-h-32 overflow-y-auto">
                  {setupData.backupCodes.map((code, index) => (
                    <div key={index} className="flex items-center justify-between bg-gray-50 dark:bg-gray-900 p-1 rounded">
                      <code className="text-xs">{code}</code>
                      <Button
                        size="sm"
                        variant="ghost"
                        className="h-6 w-6 p-0"
                        onClick={() => copyBackupCode(code, index)}
                      >
                        {copiedIndex === index ? <Check className="h-3 w-3" /> : <Copy className="h-3 w-3" />}
                      </Button>
                    </div>
                  ))}
                </div>
              </div>

              <div>
                <h3 className="font-medium mb-1 text-sm">Step 3: Verify Setup</h3>
                <p className="text-xs text-gray-600 dark:text-gray-400 mb-2">
                  Enter the 6-digit code from your authenticator app
                </p>
                <div className="space-y-1">
                  <Label htmlFor="verification-code" className="text-xs">Verification Code</Label>
                  <Input
                    id="verification-code"
                    type="text"
                    placeholder="123456"
                    value={verificationCode}
                    onChange={(e) => setVerificationCode(e.target.value)}
                    maxLength={6}
                    className="h-8"
                  />
                </div>
              </div>

              <Alert className="p-2">
                <AlertDescription className="text-xs">
                  <strong>Important:</strong> You'll need a code from your authenticator app every time you log in.
                </AlertDescription>
              </Alert>
            </div>
          )}

          <DialogFooter className="mt-2">
            <Button variant="outline" size="sm" onClick={() => setIsSetupDialogOpen(false)}>
              Cancel
            </Button>
            <Button size="sm" onClick={handleEnable} disabled={!verificationCode || loading}>
              {loading ? "Enabling..." : "Enable 2FA"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Disable Dialog */}
      <Dialog open={isDisableDialogOpen} onOpenChange={setIsDisableDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Disable Two-Factor Authentication</DialogTitle>
            <DialogDescription>
              Enter your password to disable 2FA. This will make your account less secure.
            </DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="Enter your password"
              />
            </div>
            
            <Alert>
              <AlertDescription>
                <strong>Warning:</strong> Disabling 2FA will make your account more vulnerable to unauthorized access.
              </AlertDescription>
            </Alert>
          </div>

          <DialogFooter>
            <Button variant="outline" onClick={() => setIsDisableDialogOpen(false)}>
              Cancel
            </Button>
            <Button variant="destructive" onClick={handleDisable} disabled={!password || loading}>
              Disable 2FA
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}
```

---

## File: client/src/components/ui/accordion.tsx

```tsx
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }

```

---

## File: client/src/components/ui/alert-dialog.tsx

```tsx
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}

```

---

## File: client/src/components/ui/alert.tsx

```tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }

```

---

## File: client/src/components/ui/aspect-ratio.tsx

```tsx
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }

```

---

## File: client/src/components/ui/avatar.tsx

```tsx
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

```

---

## File: client/src/components/ui/badge.tsx

```tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
```

---

## File: client/src/components/ui/breadcrumb.tsx

```tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}

```

---

## File: client/src/components/ui/button.tsx

```tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
```

---

## File: client/src/components/ui/calendar.tsx

```tsx
import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("h-4 w-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("h-4 w-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }

```

---

## File: client/src/components/ui/card.tsx

```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex flex-col space-y-1.5 p-6", className)} {...props} />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center p-6 pt-0", className)} {...props} />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
```

---

## File: client/src/components/ui/carousel.tsx

```tsx
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}

```

---

## File: client/src/components/ui/chart.tsx

```tsx
"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item?.dataKey || item?.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}

```

---

## File: client/src/components/ui/checkbox.tsx

```tsx
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

```

---

## File: client/src/components/ui/collapsible.tsx

```tsx
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }

```

---

## File: client/src/components/ui/command.tsx

```tsx
import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}

```

---

## File: client/src/components/ui/context-menu.tsx

```tsx
import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 max-h-[--radix-context-menu-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}

```

---

## File: client/src/components/ui/dialog.tsx

```tsx
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
```

---

## File: client/src/components/ui/drawer.tsx

```tsx
"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}

```

---

## File: client/src/components/ui/dropdown-menu.tsx

```tsx
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
```

---

## File: client/src/components/ui/form.tsx

```tsx
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

```

---

## File: client/src/components/ui/hover-card.tsx

```tsx
"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-hover-card-content-transform-origin]",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }

```

---

## File: client/src/components/ui/input-otp.tsx

```tsx
import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }

```

---

## File: client/src/components/ui/input.tsx

```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
```

---

## File: client/src/components/ui/label.tsx

```tsx
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
```

---

## File: client/src/components/ui/menubar.tsx

```tsx
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return <MenubarPrimitive.RadioGroup {...props} />
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}

```

---

## File: client/src/components/ui/navigation-menu.tsx

```tsx
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:text-accent-foreground data-[state=open]:bg-accent/50 data-[state=open]:hover:bg-accent data-[state=open]:focus:bg-accent"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}

```

---

## File: client/src/components/ui/pagination.tsx

```tsx
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}

```

---

## File: client/src/components/ui/popover.tsx

```tsx
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }

```

---

## File: client/src/components/ui/progress.tsx

```tsx
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }

```

---

## File: client/src/components/ui/radio-group.tsx

```tsx
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }

```

---

## File: client/src/components/ui/resizable.tsx

```tsx
"use client"

import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }

```

---

## File: client/src/components/ui/scroll-area.tsx

```tsx
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

```

---

## File: client/src/components/ui/select.tsx

```tsx
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

```

---

## File: client/src/components/ui/separator.tsx

```tsx
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

```

---

## File: client/src/components/ui/sheet.tsx

```tsx
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

```

---

## File: client/src/components/ui/sidebar.tsx

```tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContextProps>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <SheetHeader className="sr-only">
              <SheetTitle>Sidebar</SheetTitle>
              <SheetDescription>Displays the mobile sidebar.</SheetDescription>
            </SheetHeader>
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden text-sidebar-foreground md:block"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex w-full flex-1 flex-col bg-background",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}

```

---

## File: client/src/components/ui/skeleton.tsx

```tsx
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
```

---

## File: client/src/components/ui/slider.tsx

```tsx
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-[#0d0d0d]">
      <SliderPrimitive.Range className="absolute h-full bg-[#1dd1a1]" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-[#1dd1a1] bg-[#1a1a1a] ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 hover:bg-[#262626]" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }

```

---

## File: client/src/components/ui/switch.tsx

```tsx
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

```

---

## File: client/src/components/ui/table.tsx

```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

```

---

## File: client/src/components/ui/tabs.tsx

```tsx
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
```

---

## File: client/src/components/ui/textarea.tsx

```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

```

---

## File: client/src/components/ui/toaster.tsx

```tsx
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"
import { useToast } from "@/hooks/use-toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
```

---

## File: client/src/components/ui/toast.tsx

```tsx
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
```

---

## File: client/src/components/ui/toggle-group.tsx

```tsx
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }

```

---

## File: client/src/components/ui/toggle.tsx

```tsx
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3 min-w-10",
        sm: "h-9 px-2.5 min-w-9",
        lg: "h-11 px-5 min-w-11",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }

```

---

## File: client/src/components/ui/tooltip.tsx

```tsx
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
```

---

## File: client/src/components/ui/trading-background.tsx

```tsx
import { useEffect, useRef } from 'react';

export default function TradingBackground() {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Set canvas size
    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Trading data visualization
    const drawTradingData = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw subtle grid lines
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
      ctx.lineWidth = 1;
      
      // Vertical lines
      for (let x = 0; x < canvas.width; x += 100) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      
      // Horizontal lines
      for (let y = 0; y < canvas.height; y += 100) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Draw floating trading symbols
      ctx.font = '16px monospace';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      
      const symbols = ['ETH', 'BTC', 'SOL', 'USDC', 'AVAX', 'DOT'];
      const time = Date.now() * 0.001;
      
      symbols.forEach((symbol, index) => {
        const x = (Math.sin(time + index * 2) * 200) + (canvas.width / 2);
        const y = (Math.cos(time + index * 1.5) * 100) + (canvas.height / 2);
        ctx.fillText(symbol, x, y);
      });

      // Draw price lines
      ctx.strokeStyle = 'rgba(0, 208, 132, 0.2)';
      ctx.lineWidth = 2;
      
      for (let i = 0; i < 5; i++) {
        ctx.beginPath();
        const y = (Math.sin(time + i) * 50) + (canvas.height / 2) + (i * 40);
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    };

    // Animation loop
    const animate = () => {
      drawTradingData();
      requestAnimationFrame(animate);
    };

    animate();

    return () => {
      window.removeEventListener('resize', resizeCanvas);
    };
  }, []);

  return (
    <canvas
      ref={canvasRef}
      className="absolute inset-0 pointer-events-none"
      style={{ opacity: 0.8 }}
    />
  );
}
```

---

## File: client/src/components/WalletConnect.tsx

```tsx
import { usePrivy } from '@privy-io/react-auth';
import { Button } from '@/components/ui/button';
import { Wallet } from 'lucide-react';
import { useEffect, useState } from 'react';
import { apiRequest } from '@/lib/queryClient';

export function WalletConnect() {
  const { ready, authenticated, user, login, logout } = usePrivy();
  const [hasTimedOut, setHasTimedOut] = useState(false);

  // Set timeout for Privy initialization
  useEffect(() => {
    const timer = setTimeout(() => {
      if (!ready) {
        setHasTimedOut(true);
      }
    }, 5000); // Wait 5 seconds before timing out

    return () => clearTimeout(timer);
  }, [ready]);

  // Listen for custom login event from other components
  useEffect(() => {
    const handlePrivyLogin = () => {
      console.log('Privy login event received', { ready, hasTimedOut, authenticated });
      if ((ready || hasTimedOut) && !authenticated) {
        console.log('Calling login...');
        login();
      }
    };

    window.addEventListener('privy:login', handlePrivyLogin);
    return () => window.removeEventListener('privy:login', handlePrivyLogin);
  }, [ready, authenticated, login, hasTimedOut]);

  // Save wallet address when user connects
  useEffect(() => {
    const saveWalletAddress = async () => {
      if (authenticated && user && user.wallet?.address && user.email?.address) {
        try {
          await apiRequest('/api/privy/wallet', {
            method: 'POST',
            body: JSON.stringify({
              walletAddress: user.wallet.address,
              email: user.email.address
            })
          });
          console.log('Wallet address saved successfully');
        } catch (error) {
          console.error('Error saving wallet address:', error);
        }
      }
    };

    saveWalletAddress();
  }, [authenticated, user]);

  if (!ready && !hasTimedOut) {
    return (
      <Button disabled variant="outline" size="sm">
        <Wallet className="w-4 h-4 mr-2" />
        Loading...
      </Button>
    );
  }

  if (authenticated && user) {
    const address = user.wallet?.address || user.email?.address || 'Connected';
    const displayAddress = address.length > 10 
      ? `${address.slice(0, 6)}...${address.slice(-4)}` 
      : address;

    return (
      <button 
        onClick={logout} 
        className="h-8 px-4 text-sm font-medium text-[#1dd1a1] bg-[#0a0a0a] border border-[#1dd1a1]/20 rounded hover:bg-[#1dd1a1]/10 hover:border-[#1dd1a1]/40 transition-all duration-200 flex items-center gap-2"
      >
        <div className="w-1.5 h-1.5 bg-[#1dd1a1] rounded-full" />
        <span>{displayAddress}</span>
      </button>
    );
  }

  return (
    <button 
      onClick={login} 
      className="h-8 px-4 text-sm font-medium text-black bg-[#1dd1a1] rounded hover:bg-[#19b894] transition-all duration-200"
    >
      Connect
    </button>
  );
}
```

---

## File: client/src/components/wallet/wallet-connection.tsx

```tsx
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { walletService } from "@/lib/wallet";
import { WalletState } from "@/types";
import { Wallet, Copy, ExternalLink, CheckCircle } from "lucide-react";

export default function WalletConnection() {
  const [walletState, setWalletState] = useState<WalletState>(walletService.getWalletState());
  const [isConnecting, setIsConnecting] = useState(false);
  const [copied, setCopied] = useState(false);

  useEffect(() => {
    const unsubscribe = walletService.subscribe(setWalletState);
    return unsubscribe;
  }, []);

  const handleConnect = async () => {
    setIsConnecting(true);
    try {
      await walletService.connectWallet();
    } catch (error) {
      console.error('Failed to connect wallet:', error);
    } finally {
      setIsConnecting(false);
    }
  };

  const handleDisconnect = async () => {
    await walletService.disconnectWallet();
  };

  const handleCopyAddress = async () => {
    if (walletState.address) {
      await navigator.clipboard.writeText(walletState.address);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  const formatAddress = (address: string) => {
    return `${address.slice(0, 6)}...${address.slice(-4)}`;
  };

  if (!walletState.isConnected) {
    return (
      <Card className="w-full max-w-md mx-auto">
        <CardHeader className="text-center">
          <div className="w-16 h-16 bg-liquid-green/10 rounded-full flex items-center justify-center mx-auto mb-4">
            <Wallet className="w-8 h-8 text-liquid-green" />
          </div>
          <CardTitle>Connect Your Wallet</CardTitle>
          <p className="text-sm text-gray-600">
            Connect your wallet to start building and earning revenue
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <Button 
            onClick={handleConnect}
            disabled={isConnecting}
            className="w-full bg-liquid-green text-white hover:bg-liquid-accent"
          >
            {isConnecting ? 'Connecting...' : 'Connect Wallet'}
          </Button>
          <p className="text-xs text-gray-500 text-center">
            We support MetaMask, WalletConnect, and other popular wallets
          </p>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader className="text-center">
        <div className="w-16 h-16 bg-green-500/10 rounded-full flex items-center justify-center mx-auto mb-4">
          <CheckCircle className="w-8 h-8 text-green-500" />
        </div>
        <CardTitle>Wallet Connected</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="bg-gray-50 p-4 rounded-lg">
          <div className="flex items-center justify-between mb-2">
            <span className="text-sm text-gray-600">Address</span>
            <div className="flex items-center space-x-2">
              <Button
                variant="ghost"
                size="sm"
                onClick={handleCopyAddress}
                className="p-1 h-auto"
              >
                {copied ? (
                  <CheckCircle className="w-4 h-4 text-green-500" />
                ) : (
                  <Copy className="w-4 h-4 text-gray-400" />
                )}
              </Button>
              <Button
                variant="ghost"
                size="sm"
                className="p-1 h-auto"
                onClick={() => window.open(`https://etherscan.io/address/${walletState.address}`, '_blank')}
              >
                <ExternalLink className="w-4 h-4 text-gray-400" />
              </Button>
            </div>
          </div>
          <p className="font-mono text-sm">{formatAddress(walletState.address!)}</p>
        </div>

        <div className="bg-gray-50 p-4 rounded-lg">
          <div className="flex items-center justify-between mb-2">
            <span className="text-sm text-gray-600">Balance</span>
            <Badge variant="outline">ETH</Badge>
          </div>
          <p className="text-lg font-semibold">{walletState.balance}</p>
        </div>

        <div className="bg-gray-50 p-4 rounded-lg">
          <div className="flex items-center justify-between mb-2">
            <span className="text-sm text-gray-600">Network</span>
            <Badge variant="outline">
              {walletState.networkId === 1 ? 'Mainnet' : `Chain ${walletState.networkId}`}
            </Badge>
          </div>
        </div>

        <Button
          onClick={handleDisconnect}
          variant="outline"
          className="w-full"
        >
          Disconnect
        </Button>
      </CardContent>
    </Card>
  );
}

```

---

## File: client/src/hooks/useAuth.ts

```typescript
import { useQuery } from "@tanstack/react-query";
import { User } from "@shared/schema";
import { queryClient } from "@/lib/queryClient";
import { apiRequest } from "@/lib/queryClient";
import { clearPWACachesOnLogout } from "@/lib/pwa-security";

export function useAuth() {
  const { data: user, isLoading, error } = useQuery<User>({
    queryKey: ["/api/auth/user"],
    retry: false,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

  const logout = async () => {
    // SECURITY: Clear all PWA caches before logout to prevent data leakage
    clearPWACachesOnLogout();
    
    await apiRequest("POST", "/api/auth/logout");
    await queryClient.invalidateQueries({ queryKey: ["/api/auth/user"] });
  };

  return {
    user,
    isLoading,
    isAuthenticated: !!user,
    error,
    logout,
  };
}
```

---

## File: client/src/hooks/use-drag-drop.ts

```typescript
import { useState, useCallback } from "react";
import {
  DndContext,
  DragEndEvent,
  DragStartEvent,
  PointerSensor,
  useSensor,
  useSensors,
  MouseSensor,
  TouchSensor,
  KeyboardSensor,
  closestCenter,
  DragOverEvent
} from "@dnd-kit/core";
import { sortableKeyboardCoordinates } from "@dnd-kit/sortable";

interface UseDragDropProps {
  onDragStart?: (event: DragStartEvent) => void;
  onDragEnd?: (event: DragEndEvent) => void;
  onDragOver?: (event: DragOverEvent) => void;
}

export function useDragDrop({ onDragStart, onDragEnd, onDragOver }: UseDragDropProps) {
  const [isDragging, setIsDragging] = useState(false);
  const [activeId, setActiveId] = useState<string | null>(null);

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    }),
    useSensor(MouseSensor, {
      activationConstraint: {
        distance: 8,
      },
    }),
    useSensor(TouchSensor, {
      activationConstraint: {
        delay: 250,
        tolerance: 5,
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  const handleDragStart = useCallback(
    (event: DragStartEvent) => {
      setIsDragging(true);
      setActiveId(event.active.id as string);
      onDragStart?.(event);
    },
    [onDragStart]
  );

  const handleDragEnd = useCallback(
    (event: DragEndEvent) => {
      setIsDragging(false);
      setActiveId(null);
      onDragEnd?.(event);
    },
    [onDragEnd]
  );

  const handleDragOver = useCallback(
    (event: DragOverEvent) => {
      onDragOver?.(event);
    },
    [onDragOver]
  );

  return {
    sensors,
    isDragging,
    activeId,
    handleDragStart,
    handleDragEnd,
    handleDragOver,
    collisionDetection: closestCenter,
  };
}

```

---

## File: client/src/hooks/useHyperliquidTrading.ts

```typescript
import { useState } from 'react';
import { usePrivy } from '@privy-io/react-auth';
import { useQuery, useMutation } from '@tanstack/react-query';
import { queryClient } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import { signOrder, signBracketOrders, formatOrderRequest, HyperliquidOrder } from '@/lib/hyperliquid-signing';

export function useHyperliquidTrading() {
  const { authenticated, ready, user, getEthersProvider } = usePrivy();
  const { toast } = useToast();
  const [isPlacingOrder, setIsPlacingOrder] = useState(false);

  // Get user's wallet address
  const userAddress = user?.wallet?.address;

  // Fetch user positions
  const { data: positions, isLoading: positionsLoading } = useQuery({
    queryKey: [`/api/hyperliquid/user-positions/${userAddress}`],
    enabled: !!userAddress && authenticated,
    refetchInterval: 5000, // Refresh every 5 seconds to avoid rate limiting
  });

  // Fetch open orders
  const { data: openOrders, isLoading: ordersLoading } = useQuery({
    queryKey: [`/api/hyperliquid/open-orders/${userAddress}`],
    enabled: !!userAddress && authenticated,
    refetchInterval: 5000, // Refresh every 5 seconds to avoid rate limiting
  });

  // Place order mutation
  const placeOrderMutation = useMutation({
    mutationFn: async (orderRequest: any) => {
      const response = await fetch('/api/hyperliquid/place-order', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ orderRequest }),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to place order');
      }
      
      return response.json();
    },
    onSuccess: (data) => {
      toast({
        title: "Order Placed Successfully",
        description: `Order ID: ${data.response?.data?.statuses?.[0]?.resting?.oid || 'Unknown'}`,
      });
      
      // Invalidate queries to refresh data
      queryClient.invalidateQueries({ queryKey: [`/api/hyperliquid/user-positions/${userAddress}`] });
      queryClient.invalidateQueries({ queryKey: [`/api/hyperliquid/open-orders/${userAddress}`] });
    },
    onError: (error: Error) => {
      toast({
        title: "Order Failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const placeOrder = async (order: HyperliquidOrder) => {
    if (!authenticated || !ready) {
      toast({
        title: "Not Connected",
        description: "Please connect your wallet to trade",
        variant: "destructive",
      });
      return;
    }

    if (!userAddress) {
      toast({
        title: "No Wallet",
        description: "No wallet address found",
        variant: "destructive",
      });
      return;
    }

    setIsPlacingOrder(true);
    
    try {
      // Get the signer from Privy
      const provider = await getEthersProvider();
      if (!provider) {
        throw new Error("Failed to get wallet provider");
      }
      
      const signer = provider.getSigner();
      
      // Sign the order(s) - use bracket orders if TP/SL are set
      let signedOrders: any[];
      if (order.tpPrice || order.slPrice) {
        signedOrders = await signBracketOrders(order, signer);
      } else {
        const signedOrder = await signOrder(order, signer);
        signedOrders = [signedOrder];
      }
      
      // Format the request for Hyperliquid API
      // IMPORTANT: Lowercase the user address to avoid signature recovery issues
      const orderRequest = formatOrderRequest(userAddress.toLowerCase(), signedOrders);
      
      // Submit the order
      await placeOrderMutation.mutateAsync(orderRequest);
      
    } catch (error) {
      console.error("Error placing order:", error);
      toast({
        title: "Order Error",
        description: error instanceof Error ? error.message : "Failed to sign order",
        variant: "destructive",
      });
    } finally {
      setIsPlacingOrder(false);
    }
  };

  // Calculate account summary from positions
  const accountSummary = positions ? {
    accountValue: positions.marginSummary?.accountValue || "0",
    totalMarginUsed: positions.marginSummary?.totalMarginUsed || "0",
    totalNtlPos: positions.marginSummary?.totalNtlPos || "0",
    withdrawable: positions.withdrawable || "0",
  } : null;

  // Format positions for display
  const formattedPositions = positions?.assetPositions?.map((pos: any, index: number) => {
    const position = pos.position;
    const positionValue = parseFloat(position.szi) * parseFloat(position.entryPx || "0");
    const unrealizedPnl = parseFloat(position.unrealizedPnl || "0");
    const pnlPercentage = positionValue > 0 ? (unrealizedPnl / positionValue * 100) : 0;
    
    return {
      coin: position.coin,
      side: parseFloat(position.szi) > 0 ? 'LONG' : 'SHORT',
      size: Math.abs(parseFloat(position.szi)),
      entryPrice: parseFloat(position.entryPx || "0"),
      markPrice: parseFloat(position.markPx || "0"),
      liquidationPrice: parseFloat(position.liquidationPx || "0"),
      unrealizedPnl: unrealizedPnl,
      pnlPercentage: pnlPercentage,
      positionValue: Math.abs(positionValue),
      marginUsed: parseFloat(position.marginUsed || "0"),
    };
  }).filter((pos: any) => pos.size > 0) || [];

  return {
    authenticated,
    ready,
    userAddress,
    positions: formattedPositions,
    openOrders: openOrders || [],
    accountSummary,
    isPlacingOrder,
    positionsLoading,
    ordersLoading,
    placeOrder,
  };
}
```

---

## File: client/src/hooks/use-mobile.tsx

```tsx
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

```

---

## File: client/src/hooks/use-toast.ts

```typescript
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

```

---

## File: client/src/lib/hyperliquid-api.ts

```typescript
// Hyperliquid API functions for spot trading

export const HYPERLIQUID_INFO_URL = 'https://api.hyperliquid.xyz/info';
export const HYPERLIQUID_API_URL = 'https://api.hyperliquid.xyz/exchange';

export async function fetchSpotMarkets() {
  try {
    const response = await fetch('/api/hyperliquid/spot-markets');
    if (!response.ok) throw new Error('Failed to fetch spot markets');
    return await response.json();
  } catch (error) {
    console.error('Error fetching spot markets:', error);
    return [];
  }
}

export async function fetchSpotAccountState(address: string) {
  try {
    const response = await fetch(`/api/hyperliquid/spot-account/${address}`);
    if (!response.ok) throw new Error('Failed to fetch spot account state');
    return await response.json();
  } catch (error) {
    console.error('Error fetching spot account state:', error);
    return null;
  }
}

export async function submitSpotTransfer(data: {
  address: string;
  amount: string;
  toPerp: boolean;
  nonce: number;
  signature: string;
}) {
  try {
    const response = await fetch('/api/hyperliquid/spot-transfer', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Transfer failed');
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error submitting spot transfer:', error);
    throw error;
  }
}

export async function submitSpotOrder(data: {
  address: string;
  token: string;
  isBuy: boolean;
  amount: string;
  limitPrice: string | null;
  nonce: number;
  signature: string;
}) {
  try {
    const response = await fetch('/api/hyperliquid/spot-order', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Order failed');
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error submitting spot order:', error);
    throw error;
  }
}
```

---

## File: client/src/lib/hyperliquid-signing.ts

```typescript
import { ethers } from 'ethers';

// Generate a unique client order ID (128-bit hex string)
function generateCloid(): string {
  // Use timestamp (8 bytes) + random data (8 bytes) = 16 bytes = 128 bits
  const timestamp = Date.now().toString(16).padStart(16, '0');
  const randomBytes = Array.from(crypto.getRandomValues(new Uint8Array(8)))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
  return '0x' + timestamp + randomBytes;
}

// Hyperliquid EIP-712 Domain
const HYPERLIQUID_DOMAIN = {
  name: 'Exchange',
  version: '1',
  chainId: 42161, // Arbitrum mainnet
  verifyingContract: '0x0000000000000000000000000000000000000000' // Hyperliquid doesn't use a verifying contract
};

// EIP-712 Types for Hyperliquid Orders
const ORDER_TYPES = {
  Order: [
    { name: 'asset', type: 'uint32' },
    { name: 'isBuy', type: 'bool' },
    { name: 'limitPx', type: 'uint64' },
    { name: 'sz', type: 'uint64' },
    { name: 'nonce', type: 'uint64' },
    { name: 'tif', type: 'uint8' }
  ]
};

// Time in Force options
export enum TimeInForce {
  ALO = 0, // Add Liquidity Only (Post Only)
  IOC = 1, // Immediate or Cancel
  GTC = 2, // Good Till Cancel
  GTD = 3  // Good Till Date (not commonly used)
}

// Convert price and size to Hyperliquid's internal format
function floatToWire(x: number, decimals: number): string {
  const rounded = Math.round(x * Math.pow(10, decimals));
  return rounded.toString();
}

// Get asset index from symbol
function getAssetIndex(symbol: string): number {
  // This would need to be fetched from Hyperliquid's meta endpoint
  // For now, using common indices
  const assetMap: { [key: string]: number } = {
    'BTC': 0,
    'ETH': 1,
    'BNB': 2,
    'XRP': 3,
    'SOL': 4,
    'DOGE': 5,
    'MATIC': 6,
    'LTC': 7,
    'SHIB': 8,
    'AVAX': 9,
    'LINK': 10,
    'ATOM': 11,
    'UNI': 12,
    'ETC': 13,
    'TON': 14,
    'XLM': 15,
    'INJ': 16,
    'HBAR': 17,
    'ICP': 18,
    'TRX': 19,
    'APT': 20,
    'FIL': 21,
    'ARB': 22,
    'STX': 23,
    'NEAR': 24,
    'RENDER': 25,
    'IMX': 26,
    'OP': 27,
    'MNT': 28,
    'TIA': 29,
    'SEI': 30,
    'SUI': 31,
    'ZETA': 32,
    'MEME': 33,
    'TAO': 34,
    'FET': 35,
    'RNDR': 36,
    'WIF': 37,
    'BONK': 38,
    'PEPE': 39,
    'PYTH': 40,
    'JUP': 41,
    'STRK': 42,
    'DYM': 43,
    'ALT': 44,
    'MANTA': 45,
    'PIXEL': 46,
    'WLD': 47,
    'PENDLE': 48,
    'AEVO': 49,
    'BOME': 50,
    'ETHFI': 51,
    'ENA': 52,
    'W': 53,
    'TNSR': 54,
    'SAGA': 55,
    'OMNI': 57,
    'MERL': 58,
    'REZ': 59,
    'BB': 60,
    'NOT': 61,
    'IO': 62,
    'ZK': 63,
    'LISTA': 64,
    'ZRO': 65,
    'BLAST': 66,
    'BANANA': 67,
    'AAVE': 68,
    'POPCAT': 69,
    'G': 70,
    'SWELL': 71,
    'HMSTR': 72,
    'EIGEN': 73,
    'LUMIA': 74,
    'SCR': 75,
    'GOAT': 76,
    'MOODENG': 77,
    'PNUT': 78,
    'ACT': 79,
    'GRASS': 80,
    'CETUS': 81,
    'MORPHO': 82,
    'SPX': 83,
    'VIRTUAL': 84,
    'HYPE': 85,
    'ME': 86,
    'MOVE': 87,
    'SUPRA': 88,
    'ORCA': 89,
    'FARTCOIN': 90,
    'PENGU': 91,
    'VANA': 92,
    'CGPT': 93,
    'AVA': 94,
    'AIXBT': 95,
    'SWARMS': 96,
    'COOKIE': 97,
    'ZEREBRO': 98,
    'BIO': 99,
    'GRIFFAIN': 100,
    'AI16Z': 101,
    'USUAL': 102,
    'DINO': 103
  };
  
  return assetMap[symbol] ?? 0;
}

export interface HyperliquidOrder {
  symbol: string;
  side: 'buy' | 'sell';
  price: number;
  size: number;
  orderType: 'limit' | 'market';
  reduceOnly?: boolean;
  postOnly?: boolean;
  ioc?: boolean;
  tpPrice?: number;
  slPrice?: number;
}

export interface SignedOrder {
  order: any;
  signature: string;
  nonce: number;
  cloid: string;
}

export async function signOrder(
  order: HyperliquidOrder,
  signer: any // Privy's embedded wallet signer
): Promise<SignedOrder> {
  const nonce = Date.now();
  const assetIndex = getAssetIndex(order.symbol);
  const cloid = generateCloid(); // Generate unique client order ID
  
  // Determine time in force
  let tif = TimeInForce.GTC;
  if (order.postOnly) {
    tif = TimeInForce.ALO;
  } else if (order.ioc || order.orderType === 'market') {
    tif = TimeInForce.IOC;
  }
  
  // For market orders, use a very high/low price
  const limitPrice = order.orderType === 'market' 
    ? (order.side === 'buy' ? 1e9 : 0.0001)
    : order.price;
  
  // Convert to wire format (Hyperliquid uses 8 decimals for price, 5 for size on perps)
  const wireLimitPx = floatToWire(limitPrice, 8);
  const wireSz = floatToWire(order.size, 5);
  
  // Create the order object for signing
  const orderData = {
    asset: assetIndex,
    isBuy: order.side === 'buy',
    limitPx: wireLimitPx,
    sz: wireSz,
    nonce: nonce,
    tif: tif
  };
  
  // Create the typed data for EIP-712 signing
  const typedData = {
    types: ORDER_TYPES,
    domain: HYPERLIQUID_DOMAIN,
    primaryType: 'Order',
    message: orderData
  };
  
  // Sign the order using Privy's signer
  const signature = await signer._signTypedData(
    typedData.domain,
    typedData.types,
    orderData
  );
  
  // Create the final order format for Hyperliquid API
  const hyperliquidOrder = {
    a: assetIndex,
    b: order.side === 'buy',
    p: wireLimitPx,
    s: wireSz,
    r: order.reduceOnly || false,
    t: {
      limit: {
        tif: tif === TimeInForce.ALO ? 'Alo' : tif === TimeInForce.IOC ? 'Ioc' : 'Gtc'
      }
    },
    // Builder code format: {"b": builder_address, "f": fee_in_tenths_of_bps}
    // 100 = 10 basis points = 0.1% fee (maximum allowed for perps)
    // IMPORTANT: Lowercase the builder address to avoid signature recovery issues
    c: {
      b: (process.env.VITE_BUILDER_WALLET_ADDRESS || '0x0000000000000000000000000000000000000000').toLowerCase(),
      f: 100 // 10 basis points = 0.1% fee
    },
    // Client order ID for tracking
    cloid: cloid
  };
  
  return {
    order: hyperliquidOrder,
    signature,
    nonce,
    cloid
  };
}

// Sign multiple orders for bracket orders (entry + TP/SL)
export async function signBracketOrders(
  order: HyperliquidOrder,
  signer: any
): Promise<SignedOrder[]> {
  const orders: SignedOrder[] = [];
  
  // Sign the main entry order
  const mainOrder = await signOrder(order, signer);
  orders.push(mainOrder);
  
  // If TP is enabled, create a TP order
  if (order.tpPrice) {
    const tpOrder: HyperliquidOrder = {
      symbol: order.symbol,
      side: order.side === 'buy' ? 'sell' : 'buy', // Opposite side to close position
      price: order.tpPrice,
      size: order.size,
      orderType: 'limit',
      reduceOnly: true // TP orders must be reduce-only
    };
    
    const signedTP = await signTriggerOrder(tpOrder, signer, 'tp', order.tpPrice);
    orders.push(signedTP);
  }
  
  // If SL is enabled, create a SL order
  if (order.slPrice) {
    const slOrder: HyperliquidOrder = {
      symbol: order.symbol,
      side: order.side === 'buy' ? 'sell' : 'buy', // Opposite side to close position
      price: order.slPrice,
      size: order.size,
      orderType: 'limit',
      reduceOnly: true // SL orders must be reduce-only
    };
    
    const signedSL = await signTriggerOrder(slOrder, signer, 'sl', order.slPrice);
    orders.push(signedSL);
  }
  
  return orders;
}

// Sign a trigger order (TP or SL)
async function signTriggerOrder(
  order: HyperliquidOrder,
  signer: any,
  tpsl: 'tp' | 'sl',
  triggerPrice: number
): Promise<SignedOrder> {
  const nonce = Date.now();
  const assetIndex = getAssetIndex(order.symbol);
  const cloid = generateCloid(); // Generate unique client order ID
  
  // Convert to wire format
  const wireLimitPx = floatToWire(order.price, 8);
  const wireSz = floatToWire(order.size, 5);
  const wireTriggerPx = floatToWire(triggerPrice, 8);
  
  // Create the order object for signing (same structure as regular orders)
  const orderData = {
    asset: assetIndex,
    isBuy: order.side === 'buy',
    limitPx: wireLimitPx,
    sz: wireSz,
    nonce: nonce,
    tif: TimeInForce.GTC
  };
  
  // Create the typed data for EIP-712 signing
  const typedData = {
    types: ORDER_TYPES,
    domain: HYPERLIQUID_DOMAIN,
    primaryType: 'Order',
    message: orderData
  };
  
  // Sign the order
  const signature = await signer._signTypedData(
    typedData.domain,
    typedData.types,
    orderData
  );
  
  // Create the trigger order format for Hyperliquid API
  const hyperliquidOrder = {
    a: assetIndex,
    b: order.side === 'buy',
    p: wireLimitPx,
    s: wireSz,
    r: true, // Always reduce-only for TP/SL
    t: {
      trigger: {
        triggerPx: wireTriggerPx,
        isMarket: false, // Use limit order when triggered
        tpsl: tpsl
      }
    },
    // Builder code format: {"b": builder_address, "f": fee_in_tenths_of_bps}
    // IMPORTANT: Lowercase the builder address to avoid signature recovery issues
    c: {
      b: (process.env.VITE_BUILDER_WALLET_ADDRESS || '0x0000000000000000000000000000000000000000').toLowerCase(),
      f: 10 // 1 basis point = 0.01% fee
    },
    // Client order ID for tracking
    cloid: cloid
  };
  
  return {
    order: hyperliquidOrder,
    signature,
    nonce,
    cloid
  };
}

// Helper function to format order for API submission
export function formatOrderRequest(
  userAddress: string,
  signedOrders: SignedOrder[]
): any {
  // For bracket orders with multiple orders, we need to send them together
  if (signedOrders.length > 1) {
    return {
      action: {
        type: 'batchModify',
        orders: signedOrders.map(so => ({
          order: so.order,
          signature: so.signature,
          nonce: so.nonce
        })),
        grouping: 'normalTpsl'
      }
    };
  }
  
  // Single order
  return {
    action: {
      type: 'order',
      orders: signedOrders.map(so => so.order),
      grouping: 'na'
    },
    nonce: signedOrders[0].nonce,
    signature: signedOrders[0].signature
  };
}

// Sign L1 action for spot trading
export async function signL1Action(
  signer: ethers.Signer,
  action: any,
  nonce: number
): Promise<string> {
  const domain = {
    name: 'HyperliquidL1',
    version: '1',
    chainId: 1337, // Hyperliquid chain ID
    verifyingContract: '0x0000000000000000000000000000000000000000'
  };

  const types = {
    L1Action: [
      { name: 'action', type: 'string' },
      { name: 'nonce', type: 'uint64' }
    ]
  };

  const value = {
    action: JSON.stringify(action),
    nonce: nonce
  };

  const signature = await signer._signTypedData(domain, types, value);
  return signature;
}
```

---

## File: client/src/lib/hyperliquid.ts

```typescript
import { MarketData, OrderbookData } from "@/types";

export class HyperliquidAPI {
  private baseUrl = '/api/hyperliquid';

  async getMarketData(symbol?: string): Promise<MarketData[]> {
    const response = await fetch(`${this.baseUrl}/market-data${symbol ? `?symbol=${symbol}` : ''}`);
    if (!response.ok) {
      throw new Error('Failed to fetch market data');
    }
    return response.json();
  }

  async getOrderbook(symbol: string): Promise<OrderbookData> {
    const response = await fetch(`${this.baseUrl}/orderbook/${symbol}`);
    if (!response.ok) {
      throw new Error('Failed to fetch orderbook');
    }
    return response.json();
  }

  async placeOrder(userAddress: string, order: any): Promise<any> {
    const response = await fetch(`${this.baseUrl}/place-order`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        userAddress,
        order,
      }),
    });
    
    if (!response.ok) {
      throw new Error('Failed to place order');
    }
    return response.json();
  }

  async getCandleData(symbol: string, interval: string = '1m'): Promise<any> {
    const response = await fetch(`${this.baseUrl}/candles/${symbol}?interval=${interval}`);
    if (!response.ok) {
      throw new Error('Failed to fetch candle data');
    }
    return response.json();
  }
}

export const hyperliquidAPI = new HyperliquidAPI();

```

---

## File: client/src/lib/pwa-security.ts

```typescript
// PWA Security utilities to prevent data leakage

/**
 * Clear all service worker caches on logout
 * This prevents sensitive data from being accessible after logout
 */
export function clearPWACachesOnLogout() {
  if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
    // Send message to service worker to clear all caches
    navigator.serviceWorker.controller.postMessage({
      type: 'CLEAR_CACHE'
    });
    
    // Also dispatch custom event for PWAInstaller listener
    window.dispatchEvent(new Event('user-logout'));
  }
  
  // Clear all client-side storage as well
  try {
    // Clear sessionStorage
    sessionStorage.clear();
    
    // Clear specific localStorage items (preserve non-sensitive settings)
    const keysToPreserve = ['theme', 'language', 'dismissed-install-prompt'];
    const allKeys = Object.keys(localStorage);
    
    allKeys.forEach(key => {
      if (!keysToPreserve.includes(key)) {
        localStorage.removeItem(key);
      }
    });
    
    // Clear IndexedDB if used
    if ('indexedDB' in window) {
      indexedDB.databases().then(databases => {
        databases.forEach(db => {
          if (db.name) {
            indexedDB.deleteDatabase(db.name);
          }
        });
      }).catch(() => {
        // Silently fail if IndexedDB is not accessible
      });
    }
  } catch (error) {
    console.error('Error clearing storage:', error);
  }
}

/**
 * Check if PWA is installed and running in standalone mode
 */
export function isPWAInstalled(): boolean {
  return window.matchMedia('(display-mode: standalone)').matches ||
         // @ts-ignore - navigator.standalone is iOS specific
         (window.navigator as any).standalone === true;
}

/**
 * Security check for service worker updates
 * Forces update if a security patch is available
 */
export async function checkForSecurityUpdates() {
  if ('serviceWorker' in navigator) {
    const registration = await navigator.serviceWorker.getRegistration();
    if (registration) {
      // Check for updates
      await registration.update();
      
      // If update is available and it's a security update, force activation
      if (registration.waiting) {
        // In production, you might check a version header to determine if it's a security update
        registration.waiting.postMessage({ type: 'SKIP_WAITING' });
      }
    }
  }
}
```

---

## File: client/src/lib/queryClient.ts

```typescript
import { QueryClient, QueryFunction } from "@tanstack/react-query";

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    const text = (await res.text()) || res.statusText;
    throw new Error(`${res.status}: ${text}`);
  }
}

// Get CSRF token from cookie
function getCsrfToken(): string | null {
  const match = document.cookie.match(/(?:^|; )_csrf=([^;]*)/);
  return match ? decodeURIComponent(match[1]) : null;
}

export async function apiRequest(
  method: string,
  url: string,
  data?: unknown | undefined,
): Promise<Response> {
  const headers: HeadersInit = {};
  
  // Add CSRF token for state-changing methods
  if (method !== 'GET' && method !== 'HEAD') {
    const csrfToken = getCsrfToken();
    if (csrfToken) {
      headers['X-CSRF-Token'] = csrfToken;
    }
  }
  
  if (data) {
    headers['Content-Type'] = 'application/json';
  }
  
  const res = await fetch(url, {
    method,
    headers,
    body: data ? JSON.stringify(data) : undefined,
    credentials: "include",
  });

  await throwIfResNotOk(res);
  return res;
}

type UnauthorizedBehavior = "returnNull" | "throw";
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    const res = await fetch(queryKey.join("/") as string, {
      credentials: "include",
    });

    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
      return null;
    }

    await throwIfResNotOk(res);
    return await res.json();
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: false,
      staleTime: Infinity,
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});

```

---

## File: client/src/lib/urlValidator.ts

```typescript
/**
 * Validates and sanitizes URLs to prevent XSS and redirect attacks
 */

// List of allowed protocols for URLs
const ALLOWED_PROTOCOLS = ['http:', 'https:'];

// List of allowed domains for redirects (add your trusted domains here)
const ALLOWED_REDIRECT_DOMAINS = [
  'liquidlab.trade',
  'app.liquidlab.trade',
  'api.liquidlab.trade'
];

/**
 * Validates if a URL is safe to use for images or links
 * @param url - The URL to validate
 * @returns The validated URL or null if invalid
 */
export function validateImageUrl(url: string | null | undefined): string | null {
  if (!url) return null;
  
  try {
    const parsedUrl = new URL(url);
    
    // Check if protocol is allowed
    if (!ALLOWED_PROTOCOLS.includes(parsedUrl.protocol)) {
      console.warn('Invalid URL protocol:', parsedUrl.protocol);
      return null;
    }
    
    // Additional check for data URLs or javascript
    if (url.toLowerCase().includes('javascript:') || 
        url.toLowerCase().includes('data:') ||
        url.toLowerCase().includes('vbscript:')) {
      console.warn('Potentially dangerous URL detected:', url);
      return null;
    }
    
    return url;
  } catch (error) {
    console.warn('Invalid URL:', url);
    return null;
  }
}

/**
 * Validates if a URL is safe for redirects
 * @param url - The URL to validate for redirect
 * @returns The validated URL or null if invalid
 */
export function validateRedirectUrl(url: string | null | undefined): string | null {
  if (!url) return null;
  
  try {
    const parsedUrl = new URL(url);
    
    // Check if protocol is allowed
    if (!ALLOWED_PROTOCOLS.includes(parsedUrl.protocol)) {
      console.warn('Invalid redirect URL protocol:', parsedUrl.protocol);
      return null;
    }
    
    // Check if it's a relative URL (same origin)
    if (url.startsWith('/')) {
      return url;
    }
    
    // Check if the domain is in our allowed list
    const hostname = parsedUrl.hostname.toLowerCase();
    const isAllowedDomain = ALLOWED_REDIRECT_DOMAINS.some(domain => 
      hostname === domain || hostname.endsWith(`.${domain}`)
    );
    
    if (!isAllowedDomain) {
      console.warn('Redirect to untrusted domain blocked:', hostname);
      return null;
    }
    
    return url;
  } catch (error) {
    console.warn('Invalid redirect URL:', url);
    return null;
  }
}

/**
 * Sanitizes a URL for safe use in href attributes
 * @param url - The URL to sanitize
 * @param fallback - Fallback URL if validation fails
 * @returns Safe URL or fallback
 */
export function sanitizeUrl(url: string | null | undefined, fallback: string = '#'): string {
  const validated = validateRedirectUrl(url);
  return validated || fallback;
}
```

---

## File: client/src/lib/utils.ts

```typescript
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

```

---

## File: client/src/lib/wallet.ts

```typescript
import { WalletState } from "@/types";

export class WalletService {
  private static instance: WalletService;
  private walletState: WalletState = {
    isConnected: false,
    address: null,
    balance: null,
    networkId: null,
  };
  private listeners: ((state: WalletState) => void)[] = [];

  static getInstance(): WalletService {
    if (!WalletService.instance) {
      WalletService.instance = new WalletService();
    }
    return WalletService.instance;
  }

  async connectWallet(): Promise<WalletState> {
    try {
      if (typeof window.ethereum !== 'undefined') {
        const accounts = await window.ethereum.request({
          method: 'eth_requestAccounts',
        });
        
        if (accounts.length > 0) {
          const address = accounts[0];
          const balance = await this.getBalance(address);
          const networkId = await this.getNetworkId();
          
          this.walletState = {
            isConnected: true,
            address,
            balance,
            networkId,
          };
          
          this.notifyListeners();
          return this.walletState;
        }
      } else {
        throw new Error('MetaMask is not installed');
      }
    } catch (error) {
      console.error('Failed to connect wallet:', error);
      throw error;
    }
    
    return this.walletState;
  }

  async disconnectWallet(): Promise<void> {
    this.walletState = {
      isConnected: false,
      address: null,
      balance: null,
      networkId: null,
    };
    this.notifyListeners();
  }

  async getBalance(address: string): Promise<string> {
    try {
      const balance = await window.ethereum.request({
        method: 'eth_getBalance',
        params: [address, 'latest'],
      });
      return (parseInt(balance, 16) / 1e18).toFixed(4);
    } catch (error) {
      console.error('Failed to get balance:', error);
      return '0';
    }
  }

  async getNetworkId(): Promise<number> {
    try {
      const networkId = await window.ethereum.request({
        method: 'eth_chainId',
      });
      return parseInt(networkId, 16);
    } catch (error) {
      console.error('Failed to get network ID:', error);
      return 1;
    }
  }

  getWalletState(): WalletState {
    return this.walletState;
  }

  subscribe(listener: (state: WalletState) => void): () => void {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }

  private notifyListeners(): void {
    this.listeners.forEach(listener => listener(this.walletState));
  }
}

export const walletService = WalletService.getInstance();

```

---

## File: client/src/main.tsx

```tsx
import { createRoot } from "react-dom/client";
import App from "./App";
import "./index.css";

createRoot(document.getElementById("root")!).render(<App />);

```

---

## File: client/src/pages/admin-dashboard.tsx

```tsx
import { useQuery, useMutation } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useLocation } from "wouter";
import { 
  DollarSign, 
  Users, 
  BarChart3, 
  TrendingUp,
  Shield,
  LogOut,
  Building,
  Activity,
  PieChart,
  KeyRound,
  Mail,
  User,
  Wallet,
  Send,
  FileText,
  CreditCard
} from "lucide-react";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useEffect, useState } from "react";
import { PayoutManagement } from "@/components/admin/PayoutManagement";

export default function AdminDashboard() {
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const [resetPasswordDialogOpen, setResetPasswordDialogOpen] = useState(false);
  const [selectedUser, setSelectedUser] = useState<any>(null);
  const [newPassword, setNewPassword] = useState("");
  const [userSearchQuery, setUserSearchQuery] = useState("");

  const { data: dashboardData, isLoading, error } = useQuery({
    queryKey: ['/api/admin/dashboard'],
    retry: false,
    queryFn: async () => {
      console.log("Fetching admin dashboard...");
      const response = await fetch('/api/admin/dashboard', {
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        console.error("Dashboard fetch failed:", response.status, errorData);
        throw new Error(errorData.message || `Error: ${response.status}`);
      }
      
      const data = await response.json();
      console.log("Dashboard data received:", data);
      return data;
    },
  });

  const { data: usersData, isLoading: usersLoading } = useQuery({
    queryKey: ['/api/admin/users'],
    retry: false,
    enabled: !!dashboardData, // Only fetch users if dashboard data is loaded
  });

  const { data: walletBalance } = useQuery({
    queryKey: ['/api/admin/wallet-balance'],
    retry: false,
    enabled: !!dashboardData,
    refetchInterval: 30000, // Refresh every 30 seconds
  });

  const { data: pendingPlatforms, isLoading: pendingLoading } = useQuery({
    queryKey: ['/api/admin/platforms/pending'],
    retry: false,
    enabled: !!dashboardData,
  });

  const approvePlatformMutation = useMutation({
    mutationFn: async ({ platformId, notes }: { platformId: number; notes?: string }) => {
      return apiRequest("POST", `/api/admin/platforms/${platformId}/approve`, { notes });
    },
    onSuccess: () => {
      toast({
        title: "Platform Approved",
        description: "The platform has been approved and can now go live.",
      });
      queryClient.invalidateQueries({ queryKey: ['/api/admin/platforms/pending'] });
      queryClient.invalidateQueries({ queryKey: ['/api/admin/dashboard'] });
    },
    onError: (error: Error) => {
      toast({
        title: "Approval Failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const rejectPlatformMutation = useMutation({
    mutationFn: async ({ platformId, reason }: { platformId: number; reason: string }) => {
      return apiRequest("POST", `/api/admin/platforms/${platformId}/reject`, { reason });
    },
    onSuccess: () => {
      toast({
        title: "Platform Rejected",
        description: "The platform has been rejected.",
        variant: "destructive",
      });
      queryClient.invalidateQueries({ queryKey: ['/api/admin/platforms/pending'] });
      queryClient.invalidateQueries({ queryKey: ['/api/admin/dashboard'] });
    },
    onError: (error: Error) => {
      toast({
        title: "Rejection Failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const { data: suspiciousPlatforms } = useQuery({
    queryKey: ['/api/admin/platforms/suspicious'],
    retry: false,
    enabled: !!dashboardData,
  });

  const resetPasswordMutation = useMutation({
    mutationFn: async ({ userId, newPassword }: { userId: number; newPassword: string }) => {
      await apiRequest("POST", `/api/admin/users/${userId}/reset-password`, { newPassword });
    },
    onSuccess: () => {
      toast({
        title: "Password Reset",
        description: "User password has been reset successfully.",
      });
      setResetPasswordDialogOpen(false);
      setSelectedUser(null);
      setNewPassword("");
    },
    onError: (error: any) => {
      toast({
        title: "Error",
        description: error.message || "Failed to reset password.",
        variant: "destructive",
      });
    },
  });
  
  // Handle authentication and other errors
  useEffect(() => {
    if (error) {
      console.error("Dashboard fetch error:", error);
      const errorMessage = error?.message || "Could not fetch admin data";
      
      // Always redirect to login on any error for admin dashboard
      toast({
        title: "Authentication Required",
        description: "Please log in as admin to access this page",
        variant: "destructive",
      });
      
      setLocation("/admin/login");
    }
  }, [error, setLocation, toast]);

  const handleLogout = async () => {
    try {
      // SECURITY: Clear all PWA caches before logout to prevent data leakage
      if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({
          type: 'CLEAR_CACHE'
        });
      }
      
      await apiRequest("POST", "/api/admin/logout");
      toast({
        title: "Logged Out",
        description: "Admin session ended successfully",
      });
      setLocation("/");
    } catch (error) {
      console.error("Logout error:", error);
    }
  };

  if (isLoading) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
          {[...Array(4)].map((_, i) => (
            <Card key={i}>
              <CardContent className="p-6">
                <Skeleton className="h-4 w-20 mb-2" />
                <Skeleton className="h-8 w-16 mb-2" />
                <Skeleton className="h-4 w-24" />
              </CardContent>
            </Card>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Admin Header */}
      <div className="bg-red-600 text-white shadow-lg">
        <div className="container mx-auto px-4 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <Shield className="w-6 h-6" />
              <h1 className="text-xl font-bold">LiquidLab Admin Dashboard</h1>
            </div>
            <Button 
              variant="outline" 
              className="text-white border-white hover:bg-white hover:text-red-600"
              onClick={handleLogout}
            >
              <LogOut className="w-4 h-4 mr-2" />
              Logout
            </Button>
          </div>
        </div>
      </div>

      <div className="container mx-auto px-4 py-8">
        {/* Key Metrics */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-6 mb-8">
          <Card className="border-2 border-green-500">
            <CardContent className="p-6">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-gray-600">Total Revenue</p>
                  <p className="text-2xl font-bold text-gray-900">
                    ${dashboardData?.stats?.totalRevenue || '0.00'}
                  </p>
                  <p className="text-sm text-green-600">All platforms combined</p>
                </div>
                <div className="bg-green-500/10 p-3 rounded-full">
                  <DollarSign className="w-6 h-6 text-green-500" />
                </div>
              </div>
            </CardContent>
          </Card>

          <Card className="border-2 border-purple-500">
            <CardContent className="p-6">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-gray-600">LiquidLab Revenue (30%)</p>
                  <p className="text-2xl font-bold text-gray-900">
                    ${dashboardData?.stats?.liquidlabRevenue || '0.00'}
                  </p>
                  <p className="text-sm text-purple-600">Platform fees</p>
                </div>
                <div className="bg-purple-500/10 p-3 rounded-full">
                  <PieChart className="w-6 h-6 text-purple-500" />
                </div>
              </div>
            </CardContent>
          </Card>

          <Card className="border-2 border-blue-500">
            <CardContent className="p-6">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-gray-600">Platform Owners (70%)</p>
                  <p className="text-2xl font-bold text-gray-900">
                    ${dashboardData?.stats?.platformOwnerRevenue || '0.00'}
                  </p>
                  <p className="text-sm text-blue-600">Distributed earnings</p>
                </div>
                <div className="bg-blue-500/10 p-3 rounded-full">
                  <TrendingUp className="w-6 h-6 text-blue-500" />
                </div>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-6">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-gray-600">Total Users</p>
                  <p className="text-2xl font-bold text-gray-900">
                    {dashboardData?.stats?.userCount || 0}
                  </p>
                  <p className="text-sm text-gray-500">Registered accounts</p>
                </div>
                <div className="bg-gray-500/10 p-3 rounded-full">
                  <Users className="w-6 h-6 text-gray-500" />
                </div>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="p-6">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm text-gray-600">Active Platforms</p>
                  <p className="text-2xl font-bold text-gray-900">
                    {dashboardData?.stats?.platformCount || 0}
                  </p>
                  <p className="text-sm text-gray-500">Created platforms</p>
                </div>
                <div className="bg-gray-500/10 p-3 rounded-full">
                  <Building className="w-6 h-6 text-gray-500" />
                </div>
              </div>
            </CardContent>
          </Card>
        </div>

        {/* MoonPay Revenue Section */}
        <div className="mb-8">
          <h2 className="text-xl font-bold text-gray-900 mb-4">MoonPay Affiliate Revenue</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
            <Card className="border-2 border-purple-500">
              <CardContent className="p-6">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm text-gray-600">Total Fiat Purchases</p>
                    <p className="text-2xl font-bold text-gray-900">
                      ${dashboardData?.moonpayStats?.totalPurchases || '0.00'}
                    </p>
                    <p className="text-sm text-purple-600">Crypto bought via MoonPay</p>
                  </div>
                  <div className="bg-purple-500/10 p-3 rounded-full">
                    <DollarSign className="w-6 h-6 text-purple-500" />
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card className="border-2 border-indigo-500">
              <CardContent className="p-6">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm text-gray-600">Total Affiliate Fees (1%)</p>
                    <p className="text-2xl font-bold text-gray-900">
                      ${dashboardData?.moonpayStats?.totalAffiliateFees || '0.00'}
                    </p>
                    <p className="text-sm text-indigo-600">1% of purchases</p>
                  </div>
                  <div className="bg-indigo-500/10 p-3 rounded-full">
                    <Activity className="w-6 h-6 text-indigo-500" />
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card className="border-2 border-red-500">
              <CardContent className="p-6">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm text-gray-600">LiquidLab MoonPay (50%)</p>
                    <p className="text-2xl font-bold text-gray-900">
                      ${dashboardData?.moonpayStats?.liquidlabEarnings || '0.00'}
                    </p>
                    <p className="text-sm text-red-600">LiquidLab's share</p>
                  </div>
                  <div className="bg-red-500/10 p-3 rounded-full">
                    <BarChart3 className="w-6 h-6 text-red-500" />
                  </div>
                </div>
              </CardContent>
            </Card>

            <Card className="border-2 border-green-500">
              <CardContent className="p-6">
                <div className="flex items-center justify-between">
                  <div>
                    <p className="text-sm text-gray-600">Platform MoonPay (50%)</p>
                    <p className="text-2xl font-bold text-gray-900">
                      ${dashboardData?.moonpayStats?.platformEarnings || '0.00'}
                    </p>
                    <p className="text-sm text-green-600">Platform owners' share</p>
                  </div>
                  <div className="bg-green-500/10 p-3 rounded-full">
                    <TrendingUp className="w-6 h-6 text-green-500" />
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>
        </div>

        {/* Detailed Data Tabs */}
        <Tabs defaultValue="pending" className="w-full">
          <TabsList className="grid w-full grid-cols-8">
            <TabsTrigger value="pending">Pending Approvals</TabsTrigger>
            <TabsTrigger value="platforms">All Platforms</TabsTrigger>
            <TabsTrigger value="transactions">Recent Transactions</TabsTrigger>
            <TabsTrigger value="revenue">Revenue Breakdown</TabsTrigger>
            <TabsTrigger value="users">User Management</TabsTrigger>
            <TabsTrigger value="wallets">Wallet Management</TabsTrigger>
            <TabsTrigger value="payouts">Payouts</TabsTrigger>
            <TabsTrigger value="security">Security Monitor</TabsTrigger>
          </TabsList>

          <TabsContent value="pending" className="space-y-4">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center justify-between">
                  <span>Platforms Awaiting Approval</span>
                  <Badge variant="destructive" className="text-lg px-3 py-1">
                    {pendingPlatforms?.length || 0} Pending
                  </Badge>
                </CardTitle>
              </CardHeader>
              <CardContent>
                {pendingLoading ? (
                  <div className="space-y-3">
                    {[...Array(3)].map((_, i) => (
                      <div key={i} className="p-4 border rounded-lg">
                        <Skeleton className="h-6 w-48 mb-2" />
                        <Skeleton className="h-4 w-32 mb-2" />
                        <Skeleton className="h-4 w-64" />
                      </div>
                    ))}
                  </div>
                ) : pendingPlatforms && pendingPlatforms.length > 0 ? (
                  <div className="space-y-4">
                    {pendingPlatforms.map((platform: any) => (
                      <div key={platform.id} className="border rounded-lg p-6">
                        <div className="flex justify-between items-start mb-4">
                          <div>
                            <h3 className="text-lg font-semibold">{platform.name}</h3>
                            <p className="text-sm text-gray-600">Platform ID: {platform.id}</p>
                            <p className="text-sm text-gray-600">Created: {new Date(platform.createdAt).toLocaleString()}</p>
                          </div>
                          <Badge variant="outline" className="text-orange-600 border-orange-600">
                            Pending Approval
                          </Badge>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-4 mb-4">
                          <div>
                            <p className="text-sm font-medium text-gray-700">Owner Details</p>
                            <p className="text-sm">User ID: {platform.userId}</p>
                            <p className="text-sm">Username: {platform.user?.username || 'N/A'}</p>
                            <p className="text-sm">Email: {platform.user?.email || 'N/A'}</p>
                          </div>
                          <div>
                            <p className="text-sm font-medium text-gray-700">Platform Configuration</p>
                            <p className="text-sm">Builder Wallet: {platform.builderWallet || 'Not configured'}</p>
                            <p className="text-sm">Has Logo: {platform.logoUrl ? 'Yes' : 'No'}</p>
                          </div>
                        </div>

                        <div className="flex gap-3 pt-4 border-t">
                          <Button
                            variant="default"
                            className="bg-green-600 hover:bg-green-700"
                            onClick={() => {
                              const notes = prompt('Any approval notes? (optional)');
                              approvePlatformMutation.mutate({ 
                                platformId: platform.id, 
                                notes: notes || undefined 
                              });
                            }}
                            disabled={approvePlatformMutation.isPending}
                          >
                            <Shield className="w-4 h-4 mr-2" />
                            Approve Platform
                          </Button>
                          <Button
                            variant="destructive"
                            onClick={() => {
                              const reason = prompt('Please provide a reason for rejection:');
                              if (reason) {
                                rejectPlatformMutation.mutate({ 
                                  platformId: platform.id, 
                                  reason 
                                });
                              }
                            }}
                            disabled={rejectPlatformMutation.isPending}
                          >
                            Reject Platform
                          </Button>
                        </div>
                      </div>
                    ))}
                  </div>
                ) : (
                  <div className="text-center py-12 text-gray-500">
                    <Shield className="w-12 h-12 mx-auto mb-4 text-gray-300" />
                    <p className="text-lg">No platforms awaiting approval</p>
                    <p className="text-sm mt-2">New platforms will appear here for review</p>
                  </div>
                )}
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="platforms" className="space-y-4">
            <Card>
              <CardHeader>
                <CardTitle>All Trading Platforms</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="overflow-x-auto">
                  <table className="w-full">
                    <thead className="border-b">
                      <tr>
                        <th className="text-left p-3">Platform Name</th>
                        <th className="text-left p-3">Owner</th>
                        <th className="text-left p-3">Created</th>
                        <th className="text-left p-3">Status</th>
                        <th className="text-left p-3">Domain</th>
                      </tr>
                    </thead>
                    <tbody>
                      {dashboardData?.platforms?.map((platform: any) => (
                        <tr key={platform.id} className="border-b hover:bg-gray-50">
                          <td className="p-3 font-medium">{platform.name}</td>
                          <td className="p-3">
                            <div>
                              <p className="font-medium">User #{platform.userId}</p>
                              <p className="text-sm text-gray-500">{platform.payoutWallet || 'No wallet'}</p>
                            </div>
                          </td>
                          <td className="p-3 text-sm text-gray-600">
                            {new Date(platform.createdAt).toLocaleDateString()}
                          </td>
                          <td className="p-3">
                            <Badge variant={platform.isPublished ? "default" : "secondary"}>
                              {platform.isPublished ? "Published" : "Draft"}
                            </Badge>
                          </td>
                          <td className="p-3">
                            {platform.customDomain || 'No custom domain'}
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                  {(!dashboardData?.platforms || dashboardData.platforms.length === 0) && (
                    <div className="text-center py-8 text-gray-500">
                      No platforms created yet
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="transactions" className="space-y-4">
            <Card>
              <CardHeader>
                <CardTitle>Recent Fee Transactions</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="overflow-x-auto">
                  <table className="w-full">
                    <thead className="border-b">
                      <tr>
                        <th className="text-left p-3">Date</th>
                        <th className="text-left p-3">Platform</th>
                        <th className="text-left p-3">Type</th>
                        <th className="text-left p-3">Volume</th>
                        <th className="text-left p-3">Total Fee</th>
                        <th className="text-left p-3">LiquidLab (30%)</th>
                        <th className="text-left p-3">Platform (70%)</th>
                        <th className="text-left p-3">Status</th>
                      </tr>
                    </thead>
                    <tbody>
                      {dashboardData?.recentTransactions?.map((tx: any) => (
                        <tr key={tx.id} className="border-b hover:bg-gray-50">
                          <td className="p-3 text-sm">
                            {new Date(tx.createdAt).toLocaleString()}
                          </td>
                          <td className="p-3 text-sm">Platform #{tx.platformId}</td>
                          <td className="p-3">
                            <Badge variant={tx.tradeType === 'spot' ? 'default' : 'secondary'}>
                              {tx.tradeType === 'spot' ? 'Spot' : 'Perp'}
                            </Badge>
                          </td>
                          <td className="p-3 text-sm">${parseFloat(tx.tradeVolume).toFixed(2)}</td>
                          <td className="p-3 font-medium">${parseFloat(tx.totalFee).toFixed(4)}</td>
                          <td className="p-3 text-purple-600">${parseFloat(tx.liquidlabFee).toFixed(4)}</td>
                          <td className="p-3 text-blue-600">${parseFloat(tx.platformFee).toFixed(4)}</td>
                          <td className="p-3">
                            <Badge variant={tx.status === 'distributed' ? 'default' : 'secondary'}>
                              {tx.status}
                            </Badge>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                  {(!dashboardData?.recentTransactions || dashboardData.recentTransactions.length === 0) && (
                    <div className="text-center py-8 text-gray-500">
                      No transactions recorded yet
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="revenue" className="space-y-4">
            <Card>
              <CardHeader>
                <CardTitle>Platform Revenue Summary</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="overflow-x-auto">
                  <table className="w-full">
                    <thead className="border-b">
                      <tr>
                        <th className="text-left p-3">Platform ID</th>
                        <th className="text-left p-3">Period</th>
                        <th className="text-left p-3">Total Fees</th>
                        <th className="text-left p-3">LiquidLab Earnings (30%)</th>
                        <th className="text-left p-3">Platform Earnings (70%)</th>
                        <th className="text-left p-3">Last Updated</th>
                      </tr>
                    </thead>
                    <tbody>
                      {dashboardData?.revenueSummaries?.map((summary: any) => (
                        <tr key={`${summary.platformId}-${summary.period}`} className="border-b hover:bg-gray-50">
                          <td className="p-3 font-medium">Platform #{summary.platformId}</td>
                          <td className="p-3">
                            <Badge>{summary.period}</Badge>
                          </td>
                          <td className="p-3 font-medium">${parseFloat(summary.totalFees).toFixed(2)}</td>
                          <td className="p-3 text-purple-600">${parseFloat(summary.liquidlabEarnings).toFixed(2)}</td>
                          <td className="p-3 text-blue-600">${parseFloat(summary.platformEarnings).toFixed(2)}</td>
                          <td className="p-3 text-sm text-gray-500">
                            {new Date(summary.updatedAt).toLocaleString()}
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                  {(!dashboardData?.revenueSummaries || dashboardData.revenueSummaries.length === 0) && (
                    <div className="text-center py-8 text-gray-500">
                      No revenue data available yet
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="users" className="space-y-4">
            <Card>
              <CardHeader>
                <CardTitle>User Management</CardTitle>
              </CardHeader>
              <CardContent>
                {usersLoading ? (
                  <div className="flex justify-center py-8">
                    <Skeleton className="h-8 w-8 animate-spin rounded-full" />
                  </div>
                ) : (
                  <div className="space-y-4">
                    {/* Search Input */}
                    <div className="flex items-center gap-2">
                      <Input
                        placeholder="Search by username or email..."
                        value={userSearchQuery}
                        onChange={(e) => setUserSearchQuery(e.target.value)}
                        className="max-w-sm"
                      />
                    </div>

                    <div className="overflow-x-auto">
                      <table className="w-full">
                        <thead className="border-b">
                          <tr>
                            <th className="text-left p-3">ID</th>
                            <th className="text-left p-3">Username</th>
                            <th className="text-left p-3">Email</th>
                            <th className="text-left p-3">Wallet Address</th>
                            <th className="text-left p-3">Builder Code</th>
                            <th className="text-left p-3">Created</th>
                            <th className="text-left p-3">Actions</th>
                          </tr>
                        </thead>
                        <tbody>
                          {usersData?.users
                            ?.filter((user: any) => {
                              const query = userSearchQuery.toLowerCase();
                              return (
                                user.username?.toLowerCase().includes(query) ||
                                user.email?.toLowerCase().includes(query)
                              );
                            })
                            ?.map((user: any) => (
                          <tr key={user.id} className="border-b hover:bg-gray-50">
                            <td className="p-3 font-medium">#{user.id}</td>
                            <td className="p-3">
                              <div className="flex items-center gap-2">
                                <User className="w-4 h-4 text-gray-400" />
                                {user.username}
                              </div>
                            </td>
                            <td className="p-3">
                              <div className="flex items-center gap-2">
                                <Mail className="w-4 h-4 text-gray-400" />
                                {user.email}
                              </div>
                            </td>
                            <td className="p-3">
                              {user.walletAddress ? (
                                <div className="flex items-center gap-2">
                                  <Wallet className="w-4 h-4 text-gray-400" />
                                  <span className="font-mono text-sm">
                                    {user.walletAddress.slice(0, 6)}...{user.walletAddress.slice(-4)}
                                  </span>
                                </div>
                              ) : (
                                <span className="text-gray-400">No wallet</span>
                              )}
                            </td>
                            <td className="p-3">
                              {user.builderCode ? (
                                <Badge variant="secondary">{user.builderCode}</Badge>
                              ) : (
                                <span className="text-gray-400">-</span>
                              )}
                            </td>
                            <td className="p-3 text-sm text-gray-600">
                              {new Date(user.createdAt).toLocaleDateString()}
                            </td>
                            <td className="p-3">
                              <Button
                                size="sm"
                                variant="outline"
                                onClick={() => {
                                  setSelectedUser(user);
                                  setResetPasswordDialogOpen(true);
                                }}
                              >
                                <KeyRound className="w-4 h-4 mr-1" />
                                Reset Password
                              </Button>
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                    {(!usersData?.users || usersData.users.length === 0) && (
                      <div className="text-center py-8 text-gray-500">
                        No users registered yet
                      </div>
                    )}
                  </div>
                </div>
                )}
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="wallets" className="space-y-4">
            <Card>
              <CardHeader>
                <CardTitle>Wallet Management</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-6">
                  {/* Main Collection Wallet */}
                  <div className="border-2 border-purple-500 rounded-lg p-6">
                    <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
                      <Wallet className="w-5 h-5 text-purple-500" />
                      Main Collection Wallet
                    </h3>
                    <div className="space-y-4">
                      <div>
                        <p className="text-sm text-gray-600 mb-1">Builder Wallet Address</p>
                        <p className="font-mono text-sm bg-gray-100 p-2 rounded">
                          {import.meta.env.VITE_BUILDER_WALLET_ADDRESS || 'Not configured'}
                        </p>
                        <p className="text-xs text-gray-500 mt-1">
                          All platform trading fees are collected through this builder wallet
                        </p>
                      </div>
                      
                      <div>
                        <p className="text-sm text-gray-600 mb-1">Total Collected Revenue</p>
                        <p className="text-2xl font-bold text-purple-600">
                          ${dashboardData?.stats?.totalRevenue || '0.00'}
                        </p>
                      </div>
                    </div>
                  </div>

                  {/* Payout Wallet Configuration */}
                  <div className="border rounded-lg p-6">
                    <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
                      <Send className="w-5 h-5 text-blue-500" />
                      Payout Wallet Configuration
                    </h3>
                    <div className="space-y-4">
                      <div>
                        <p className="text-sm text-gray-600 mb-1">Network</p>
                        <Badge variant="secondary">Arbitrum</Badge>
                      </div>
                      
                      <div>
                        <p className="text-sm text-gray-600 mb-1">Currency</p>
                        <Badge variant="secondary">USDC</Badge>
                      </div>
                      
                      <div>
                        <p className="text-sm text-gray-600 mb-1">Current Balance</p>
                        <p className="text-2xl font-bold text-green-600">
                          ${walletBalance?.balance || '0.00'} USDC
                        </p>
                        {walletBalance?.error && (
                          <p className="text-xs text-red-500 mt-1">{walletBalance.error}</p>
                        )}
                      </div>
                      
                      <div>
                        <p className="text-sm text-gray-600 mb-1">Payout Schedule</p>
                        <p className="text-sm">Weekly (Every Monday)</p>
                      </div>
                      
                      <div>
                        <p className="text-sm text-gray-600 mb-1">Minimum Payout Threshold</p>
                        <p className="font-medium">$10.00</p>
                      </div>
                    </div>
                  </div>

                  {/* Revenue Distribution */}
                  <div className="border rounded-lg p-6">
                    <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
                      <PieChart className="w-5 h-5 text-green-500" />
                      Revenue Distribution
                    </h3>
                    <div className="space-y-3">
                      <div className="flex justify-between items-center">
                        <span className="text-sm">LiquidLab Share (30%)</span>
                        <span className="font-medium text-purple-600">
                          ${dashboardData?.stats?.liquidlabRevenue || '0.00'}
                        </span>
                      </div>
                      <div className="flex justify-between items-center">
                        <span className="text-sm">Platform Owners Share (70%)</span>
                        <span className="font-medium text-blue-600">
                          ${dashboardData?.stats?.platformOwnerRevenue || '0.00'}
                        </span>
                      </div>
                      <div className="pt-3 border-t">
                        <div className="flex justify-between items-center">
                          <span className="text-sm font-medium">Pending Payouts</span>
                          <span className="font-medium text-orange-600">
                            ${dashboardData?.pendingPayouts || '0.00'}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>

                  {/* Manual Actions */}
                  <div className="border rounded-lg p-6">
                    <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
                      <Shield className="w-5 h-5 text-red-500" />
                      Manual Actions
                    </h3>
                    <div className="space-y-3">
                      <Button 
                        variant="outline"
                        className="w-full justify-start"
                        onClick={() => {
                          toast({
                            title: "Process Payouts",
                            description: "This feature requires production configuration",
                          });
                        }}
                      >
                        <Send className="w-4 h-4 mr-2" />
                        Process Weekly Payouts
                      </Button>
                      
                      <Button 
                        variant="outline"
                        className="w-full justify-start"
                        onClick={() => {
                          toast({
                            title: "Export Revenue Report",
                            description: "Revenue report export started",
                          });
                        }}
                      >
                        <FileText className="w-4 h-4 mr-2" />
                        Export Revenue Report
                      </Button>
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          {/* Security Monitor Tab */}
          <TabsContent value="security" className="space-y-4">
            <Card>
              <CardHeader>
                <CardTitle>Security Monitoring System</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-6">
                  {/* Security Overview */}
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <Card>
                      <CardContent className="p-4">
                        <div className="flex items-center justify-between">
                          <div>
                            <p className="text-sm text-gray-600">Suspicious Platforms</p>
                            <p className="text-2xl font-bold text-red-600">
                              {dashboardData?.securityStats?.suspiciousCount || 0}
                            </p>
                          </div>
                          <Shield className="w-6 h-6 text-red-500" />
                        </div>
                      </CardContent>
                    </Card>

                    <Card>
                      <CardContent className="p-4">
                        <div className="flex items-center justify-between">
                          <div>
                            <p className="text-sm text-gray-600">Platforms Under Review</p>
                            <p className="text-2xl font-bold text-yellow-600">
                              {dashboardData?.securityStats?.underReviewCount || 0}
                            </p>
                          </div>
                          <Shield className="w-6 h-6 text-yellow-500" />
                        </div>
                      </CardContent>
                    </Card>

                    <Card>
                      <CardContent className="p-4">
                        <div className="flex items-center justify-between">
                          <div>
                            <p className="text-sm text-gray-600">Banned Platforms</p>
                            <p className="text-2xl font-bold text-gray-600">
                              {dashboardData?.securityStats?.bannedCount || 0}
                            </p>
                          </div>
                          <Shield className="w-6 h-6 text-gray-500" />
                        </div>
                      </CardContent>
                    </Card>
                  </div>

                  {/* Suspicious Platforms Table */}
                  <div>
                    <h3 className="text-lg font-semibold mb-4">Platforms Requiring Review</h3>
                    <div className="overflow-x-auto">
                      <table className="w-full">
                        <thead className="border-b">
                          <tr>
                            <th className="text-left p-3">Platform</th>
                            <th className="text-left p-3">Owner</th>
                            <th className="text-left p-3">Risk Score</th>
                            <th className="text-left p-3">Status</th>
                            <th className="text-left p-3">Reported</th>
                            <th className="text-left p-3">Actions</th>
                          </tr>
                        </thead>
                        <tbody>
                          {suspiciousPlatforms?.map((platform: any) => (
                            <tr key={platform.id} className="border-b hover:bg-gray-50">
                              <td className="p-3">
                                <div>
                                  <p className="font-medium">{platform.name}</p>
                                  <p className="text-sm text-gray-500">ID: {platform.id}</p>
                                </div>
                              </td>
                              <td className="p-3">
                                <p className="text-sm">User #{platform.userId}</p>
                              </td>
                              <td className="p-3">
                                <Badge variant={platform.riskScore > 50 ? "destructive" : "secondary"}>
                                  {platform.riskScore}/100
                                </Badge>
                              </td>
                              <td className="p-3">
                                <Badge variant={
                                  platform.status === 'banned' ? "destructive" : 
                                  platform.status === 'suspended' ? "secondary" : 
                                  "default"
                                }>
                                  {platform.status}
                                </Badge>
                              </td>
                              <td className="p-3">
                                <p className="text-sm text-gray-600">
                                  {new Date(platform.createdAt).toLocaleDateString()}
                                </p>
                              </td>
                              <td className="p-3">
                                <div className="flex gap-2">
                                  <Button 
                                    size="sm" 
                                    variant="outline"
                                    onClick={() => {
                                      toast({
                                        title: "Platform Review",
                                        description: `Reviewing platform ${platform.name}`,
                                      });
                                    }}
                                  >
                                    Review
                                  </Button>
                                  {platform.status !== 'banned' && (
                                    <Button 
                                      size="sm" 
                                      variant="destructive"
                                      onClick={() => {
                                        toast({
                                          title: "Platform Banned",
                                          description: `Platform ${platform.name} has been banned`,
                                          variant: "destructive",
                                        });
                                      }}
                                    >
                                      Ban
                                    </Button>
                                  )}
                                </div>
                              </td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                      {(!dashboardData?.suspiciousPlatforms || dashboardData.suspiciousPlatforms.length === 0) && (
                        <div className="text-center py-8 text-gray-500">
                          No suspicious platforms detected
                        </div>
                      )}
                    </div>
                  </div>

                  {/* Recent Security Activity */}
                  <div>
                    <h3 className="text-lg font-semibold mb-4">Recent Security Activity</h3>
                    <div className="space-y-2 max-h-64 overflow-y-auto">
                      {dashboardData?.recentSecurityActivity?.map((activity: any, index: number) => (
                        <div key={index} className="flex items-start gap-3 p-3 border rounded-lg">
                          <Shield className="w-4 h-4 text-gray-500 mt-1" />
                          <div className="flex-1">
                            <p className="text-sm">{activity.description}</p>
                            <p className="text-xs text-gray-500 mt-1">
                              {new Date(activity.createdAt).toLocaleString()}
                            </p>
                          </div>
                        </div>
                      ))}
                      {(!dashboardData?.recentSecurityActivity || dashboardData.recentSecurityActivity.length === 0) && (
                        <div className="text-center py-4 text-gray-500">
                          No recent security activity
                        </div>
                      )}
                    </div>
                  </div>

                  {/* Security Actions */}
                  <div className="border rounded-lg p-6">
                    <h3 className="text-lg font-semibold mb-4">Security Actions</h3>
                    <div className="space-y-3">
                      <Button 
                        variant="outline"
                        className="w-full justify-start"
                        onClick={() => {
                          toast({
                            title: "Security Scan",
                            description: "Running comprehensive security scan on all platforms...",
                          });
                        }}
                      >
                        <Shield className="w-4 h-4 mr-2" />
                        Run Full Security Scan
                      </Button>
                      
                      <Button 
                        variant="outline"
                        className="w-full justify-start text-red-600 border-red-200"
                        onClick={() => {
                          toast({
                            title: "Emergency Mode",
                            description: "This would suspend all new platform creation temporarily",
                            variant: "destructive",
                          });
                        }}
                      >
                        <Shield className="w-4 h-4 mr-2" />
                        Emergency Lockdown Mode
                      </Button>
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="payouts" className="space-y-4">
            <PayoutManagement />
          </TabsContent>
        </Tabs>

        {/* Password Reset Dialog */}
        <Dialog open={resetPasswordDialogOpen} onOpenChange={setResetPasswordDialogOpen}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Reset Password for {selectedUser?.username}</DialogTitle>
            </DialogHeader>
            <div className="space-y-4">
              <div>
                <Label htmlFor="newPassword">New Password</Label>
                <Input
                  id="newPassword"
                  type="password"
                  value={newPassword}
                  onChange={(e) => setNewPassword(e.target.value)}
                  placeholder="Enter new password (min. 8 characters)"
                />
              </div>
            </div>
            <DialogFooter>
              <Button
                variant="outline"
                onClick={() => {
                  setResetPasswordDialogOpen(false);
                  setNewPassword("");
                }}
              >
                Cancel
              </Button>
              <Button
                onClick={() => {
                  if (selectedUser && newPassword.length >= 8) {
                    resetPasswordMutation.mutate({
                      userId: selectedUser.id,
                      newPassword
                    });
                  } else {
                    toast({
                      title: "Invalid Password",
                      description: "Password must be at least 8 characters long.",
                      variant: "destructive",
                    });
                  }
                }}
                disabled={resetPasswordMutation.isPending}
              >
                {resetPasswordMutation.isPending ? "Resetting..." : "Reset Password"}
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
    </div>
  );
}
```

---

## File: client/src/pages/admin-login.tsx

```tsx
import { useState } from "react";
import { Link, useLocation } from "wouter";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from "@/lib/queryClient";
import { queryClient } from "@/lib/queryClient";
import { Loader2, Shield } from "lucide-react";

export default function AdminLogin() {
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const [loading, setLoading] = useState(false);
  const [requires2FA, setRequires2FA] = useState(false);
  const [formData, setFormData] = useState({
    email: "",
    password: "",
    totp: "",
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    setLoading(true);
    try {
      const response = await apiRequest("POST", "/api/admin/login", formData);
      
      // Check if 2FA is required
      if (response.requiresTwoFactor) {
        setRequires2FA(true);
        toast({
          title: "2FA Required",
          description: "Please enter your admin authentication code",
        });
        return;
      }
      
      toast({
        title: "Admin Access Granted",
        description: "Welcome to the admin dashboard.",
      });
      
      // Navigate to admin dashboard
      setTimeout(() => {
        setLocation("/admin/dashboard");
      }, 500);
    } catch (error: any) {
      toast({
        title: "Access Denied",
        description: error.message || "Invalid admin credentials.",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
      <Card className="w-full max-w-md">
        <CardHeader className="text-center">
          <div className="mx-auto mb-4 bg-red-100 p-3 rounded-full w-fit">
            <Shield className="w-8 h-8 text-red-600" />
          </div>
          <CardTitle>{requires2FA ? "Admin 2FA Verification" : "Admin Access"}</CardTitle>
          <CardDescription>
            {requires2FA 
              ? "Enter your admin authentication code"
              : "This area is restricted to LiquidLab administrators only"}
          </CardDescription>
        </CardHeader>
        <form onSubmit={handleSubmit}>
          <CardContent className="space-y-4">
            {!requires2FA ? (
              <>
                <div>
                  <Label htmlFor="email">Admin Email</Label>
                  <Input
                    id="email"
                    type="email"
                    placeholder="admin@liquidlab.trade"
                    value={formData.email}
                    onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                    required
                  />
                </div>
                <div>
                  <Label htmlFor="password">Admin Password</Label>
                  <Input
                    id="password"
                    type="password"
                    placeholder="••••••••"
                    value={formData.password}
                    onChange={(e) => setFormData({ ...formData, password: e.target.value })}
                    required
                  />
                </div>
              </>
            ) : (
              <div>
                <Label htmlFor="totp">Authentication Code</Label>
                <Input
                  id="totp"
                  type="text"
                  placeholder="123456"
                  value={formData.totp}
                  onChange={(e) => setFormData({ ...formData, totp: e.target.value })}
                  maxLength={6}
                  required
                  autoFocus
                />
                <p className="text-sm text-gray-600 mt-2">
                  Enter the 6-digit code from your authenticator app
                </p>
              </div>
            )}
          </CardContent>
          <CardFooter className="flex flex-col gap-4">
            <Button
              type="submit"
              className="w-full bg-red-600 hover:bg-red-700 text-white"
              disabled={loading}
            >
              {loading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  {requires2FA ? "Verifying..." : "Authenticating..."}
                </>
              ) : (
                requires2FA ? "Verify Code" : "Access Admin Dashboard"
              )}
            </Button>
            {requires2FA ? (
              <Button
                type="button"
                variant="outline"
                className="w-full"
                onClick={() => {
                  setRequires2FA(false);
                  setFormData({ ...formData, totp: "" });
                }}
              >
                Back to Login
              </Button>
            ) : (
              <Link href="/">
                <Button variant="link" className="text-sm">
                  Return to Main Site
                </Button>
              </Link>
            )}
          </CardFooter>
        </form>
      </Card>
    </div>
  );
}
```

---

## File: client/src/pages/analytics.tsx

```tsx
import { useQuery } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Skeleton } from "@/components/ui/skeleton";
import { 
  TrendingUp, 
  DollarSign, 
  Users, 
  BarChart3, 
  ArrowUp, 
  ArrowDown,
  Calendar,
  Download
} from "lucide-react";

export default function Analytics() {
  const { data: analytics, isLoading } = useQuery({
    queryKey: ['/api/analytics/dashboard/1'],
    queryFn: async () => {
      // Mock analytics data
      return {
        totalRevenue: "2847.50",
        dailyRevenue: "124.30",
        monthlyRevenue: "1642.80",
        activeUsers: 1234,
        totalVolume: "45200.00",
        platforms: [
          { name: "Pro Trading Platform", revenue: "1234.50", change: "+12.5" },
          { name: "Mobile Trader", revenue: "892.30", change: "+8.3" },
          { name: "DeFi Dashboard", revenue: "721.70", change: "+5.1" }
        ],
        revenueHistory: [
          { date: "2024-01", amount: "890.50" },
          { date: "2024-02", amount: "1240.80" },
          { date: "2024-03", amount: "1680.20" },
          { date: "2024-04", amount: "2100.40" },
          { date: "2024-05", amount: "2350.60" },
          { date: "2024-06", amount: "2847.50" }
        ]
      };
    }
  });

  if (isLoading) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
          {[...Array(4)].map((_, i) => (
            <Card key={i}>
              <CardContent className="p-6">
                <Skeleton className="h-4 w-20 mb-2" />
                <Skeleton className="h-8 w-16 mb-2" />
                <Skeleton className="h-4 w-24" />
              </CardContent>
            </Card>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center justify-between mb-8">
        <div>
          <h1 className="text-3xl font-bold text-gray-900">Analytics</h1>
          <p className="text-gray-600">Track your platform performance and revenue</p>
        </div>
        <div className="flex items-center space-x-4">
          <Button variant="outline">
            <Calendar className="w-4 h-4 mr-2" />
            Last 30 days
          </Button>
          <Button variant="outline">
            <Download className="w-4 h-4 mr-2" />
            Export
          </Button>
        </div>
      </div>

      {/* Key Metrics */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-600">Total Revenue</p>
                <p className="text-2xl font-bold text-gray-900">${analytics?.totalRevenue}</p>
                <div className="flex items-center mt-1">
                  <ArrowUp className="w-4 h-4 text-green-500 mr-1" />
                  <span className="text-sm text-green-600">+12.5%</span>
                </div>
              </div>
              <div className="bg-green-500/10 p-3 rounded-full">
                <DollarSign className="w-6 h-6 text-green-500" />
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-600">Daily Revenue</p>
                <p className="text-2xl font-bold text-gray-900">${analytics?.dailyRevenue}</p>
                <div className="flex items-center mt-1">
                  <ArrowUp className="w-4 h-4 text-green-500 mr-1" />
                  <span className="text-sm text-green-600">+8.3%</span>
                </div>
              </div>
              <div className="bg-blue-500/10 p-3 rounded-full">
                <TrendingUp className="w-6 h-6 text-blue-500" />
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-600">Active Users</p>
                <p className="text-2xl font-bold text-gray-900">{analytics?.activeUsers}</p>
                <div className="flex items-center mt-1">
                  <ArrowUp className="w-4 h-4 text-green-500 mr-1" />
                  <span className="text-sm text-green-600">+15.2%</span>
                </div>
              </div>
              <div className="bg-purple-500/10 p-3 rounded-full">
                <Users className="w-6 h-6 text-purple-500" />
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-600">Total Volume</p>
                <p className="text-2xl font-bold text-gray-900">${analytics?.totalVolume}</p>
                <div className="flex items-center mt-1">
                  <ArrowUp className="w-4 h-4 text-green-500 mr-1" />
                  <span className="text-sm text-green-600">+5.7%</span>
                </div>
              </div>
              <div className="bg-orange-500/10 p-3 rounded-full">
                <BarChart3 className="w-6 h-6 text-orange-500" />
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Detailed Analytics */}
      <div className="grid lg:grid-cols-2 gap-8">
        {/* Revenue Overview */}
        <Card>
          <CardHeader>
            <CardTitle>Revenue Overview</CardTitle>
          </CardHeader>
          <CardContent>
            <Tabs defaultValue="chart" className="w-full">
              <TabsList className="grid w-full grid-cols-2">
                <TabsTrigger value="chart">Chart</TabsTrigger>
                <TabsTrigger value="data">Data</TabsTrigger>
              </TabsList>
              
              <TabsContent value="chart" className="space-y-4">
                <div className="grid grid-cols-3 gap-4 mb-6">
                  <div className="text-center">
                    <div className="text-2xl font-bold text-liquid-green">${analytics?.totalRevenue}</div>
                    <div className="text-sm text-gray-600">Total Revenue</div>
                  </div>
                  <div className="text-center">
                    <div className="text-2xl font-bold text-blue-600">{analytics?.activeUsers}</div>
                    <div className="text-sm text-gray-600">Active Users</div>
                  </div>
                  <div className="text-center">
                    <div className="text-2xl font-bold text-purple-600">${analytics?.totalVolume}</div>
                    <div className="text-sm text-gray-600">Volume</div>
                  </div>
                </div>
                
                {/* Chart placeholder */}
                <div className="h-48 bg-gradient-to-r from-liquid-green to-blue-500 rounded-lg opacity-20 flex items-center justify-center">
                  <p className="text-gray-500">Revenue Chart</p>
                </div>
              </TabsContent>
              
              <TabsContent value="data" className="space-y-4">
                <div className="space-y-3">
                  {analytics?.revenueHistory.map((item: any, index: number) => (
                    <div key={index} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                      <span className="text-sm font-medium">{item.date}</span>
                      <span className="text-sm font-bold">${item.amount}</span>
                    </div>
                  ))}
                </div>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>

        {/* Platform Performance */}
        <Card>
          <CardHeader>
            <CardTitle>Platform Performance</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              {analytics?.platforms.map((platform: any, index: number) => (
                <div key={index} className="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                  <div className="flex items-center">
                    <div className="w-3 h-3 bg-liquid-green rounded-full mr-3"></div>
                    <span className="text-gray-700">{platform.name}</span>
                  </div>
                  <div className="text-right">
                    <div className="font-semibold text-gray-900">${platform.revenue}</div>
                    <div className="text-sm text-green-600 flex items-center">
                      <ArrowUp className="w-3 h-3 mr-1" />
                      {platform.change}%
                    </div>
                  </div>
                </div>
              ))}
            </div>
            
            <div className="mt-6 pt-6 border-t border-gray-200">
              <div className="flex items-center justify-between mb-2">
                <span className="text-gray-700">Builder Code:</span>
                <Badge variant="outline" className="font-mono">LIQUIDLAB2024</Badge>
              </div>
              <div className="flex items-center justify-between">
                <span className="text-gray-700">Commission Rate:</span>
                <span className="font-semibold text-liquid-green">0.5%</span>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Recent Activity */}
      <Card className="mt-8">
        <CardHeader>
          <CardTitle>Recent Activity</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {[
              { type: "revenue", message: "Earned $24.50 from Pro Trading Platform", time: "2 hours ago" },
              { type: "user", message: "New user signed up via referral code", time: "4 hours ago" },
              { type: "platform", message: "Mobile Trader platform updated", time: "6 hours ago" },
              { type: "revenue", message: "Earned $12.30 from DeFi Dashboard", time: "8 hours ago" }
            ].map((activity, index) => (
              <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
                <div className="flex items-center">
                  <div className={`w-2 h-2 rounded-full mr-3 ${
                    activity.type === 'revenue' ? 'bg-green-500' : 
                    activity.type === 'user' ? 'bg-blue-500' : 'bg-purple-500'
                  }`}></div>
                  <span className="text-sm">{activity.message}</span>
                </div>
                <span className="text-sm text-gray-500">{activity.time}</span>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

```

---

## File: client/src/pages/builder.tsx

```tsx
import { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useToast } from "@/hooks/use-toast";
import templatePreview from "@assets/Trade_1752276632533.png";
import { useAuth } from "@/hooks/useAuth";
import { apiRequest } from "@/lib/queryClient";
import { useMutation, useQuery } from "@tanstack/react-query";
import { queryClient } from "@/lib/queryClient";
import { useLocation } from "wouter";
import { CustomDomainManager } from "@/components/CustomDomainManager";
import { 
  Eye,
  Save,
  Settings,
  Globe,
  Code,
  Palette,
  DollarSign,
  Monitor,
  Smartphone,
  Check,
  Copy,
  ExternalLink,
  Upload,
  Image,
  Plus,
  FolderOpen
} from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

export default function Builder() {
  const { toast } = useToast();
  const { user, isAuthenticated } = useAuth();
  const [, setLocation] = useLocation();
  const [platformName, setPlatformName] = useState("");
  const [customDomain, setCustomDomain] = useState("");
  const [previewMode, setPreviewMode] = useState<'desktop' | 'mobile'>('desktop');
  const [savedChanges, setSavedChanges] = useState(false);
  const [logoUrl, setLogoUrl] = useState("");
  const [uploadingLogo, setUploadingLogo] = useState(false);
  const [payoutWallet, setPayoutWallet] = useState("");
  const [savingPlatform, setSavingPlatform] = useState(false);
  const [savedPlatformId, setSavedPlatformId] = useState<number | null>(null);
  const [isCreatingNew, setIsCreatingNew] = useState(false);
  const [verificationCode, setVerificationCode] = useState<string | null>(null);

  // Builder wallet address (must have 100+ USDC in perps account)
  const BUILDER_WALLET_ADDRESS = import.meta.env.VITE_BUILDER_WALLET_ADDRESS || "0x0000000000000000000000000000000000000000";

  // Function to reset all form fields for a new platform
  const resetFormForNewPlatform = () => {
    setPlatformName("");
    setCustomDomain("");
    setLogoUrl("");
    setPayoutWallet("");
    setSavedPlatformId(null);
    setSavedChanges(false);
    setPreviewMode('desktop');
    setIsCreatingNew(true);
    setVerificationCode(null);
    toast({
      title: "Creating New Platform",
      description: "Form cleared. Enter details for your new platform.",
    });
  };

  // Redirect if not authenticated
  if (!isAuthenticated) {
    setLocation('/login');
    return null;
  }

  // Load existing platforms
  const { data: platforms } = useQuery({
    queryKey: ['/api/platforms', { userId: user?.id }],
    queryFn: async () => {
      const response = await fetch(`/api/platforms?userId=${user?.id}`);
      if (!response.ok) throw new Error('Failed to fetch platforms');
      return response.json();
    },
    enabled: !!user?.id
  });

  // Don't auto-load any platform - start with blank form
  // Users can explicitly choose to load an existing platform if they want

  // Ensure the page starts fresh when mounted
  useEffect(() => {
    // Only reset if we're creating a new platform (no specific platform ID in URL)
    if (!window.location.search.includes('platformId=')) {
      resetFormForNewPlatform();
    }
  }, []); // Run only on mount

  // Fetch verification code for saved platform
  const { data: platformVerificationCode } = useQuery({
    queryKey: [`/api/platforms/${savedPlatformId}/verification-code`],
    enabled: !!savedPlatformId
  });

  useEffect(() => {
    if (platformVerificationCode?.code) {
      setVerificationCode(platformVerificationCode.code);
    } else if (savedPlatformId) {
      // If we have a saved platform but no code yet, refetch
      queryClient.invalidateQueries({ queryKey: [`/api/platforms/${savedPlatformId}/verification-code`] });
    }
  }, [platformVerificationCode, savedPlatformId]);

  // Load selected platform data
  const handleLoadPlatform = async (platformId: string) => {
    if (platformId === "new") {
      resetFormForNewPlatform();
      return;
    }
    
    const platform = platforms?.find(p => p.id.toString() === platformId);
    if (platform) {
      setSavedPlatformId(platform.id);
      setPlatformName(platform.name || '');
      setLogoUrl(platform.logoUrl || '');
      setPayoutWallet(platform.payoutWallet || '');
      setCustomDomain(platform.customDomain || '');
      setSavedChanges(true);
      setIsCreatingNew(false);
      setVerificationCode(''); // Clear the old code
      
      // Immediately invalidate and refetch the verification code
      queryClient.invalidateQueries({ queryKey: [`/api/platforms/${platform.id}/verification-code`] });
      
      toast({
        title: "Platform Loaded",
        description: `Loaded "${platform.name}" for editing.`,
      });
    }
  };

  const savePlatformMutation = useMutation({
    mutationFn: async (data: any) => {
      if (savedPlatformId) {
        // Update existing platform
        return apiRequest("PUT", `/api/platforms/${savedPlatformId}`, data);
      } else {
        // Create new platform
        return apiRequest("POST", "/api/platforms", data);
      }
    },
    onSuccess: (data) => {
      setSavedChanges(true);
      setSavedPlatformId(data.id);
      setIsCreatingNew(false); // Reset the creating new flag after successful save
      toast({
        title: "Platform Saved",
        description: "Your platform configuration has been saved successfully.",
      });
      queryClient.invalidateQueries({ queryKey: ['/api/platforms'] });
      // Also invalidate the verification code query to fetch the newly generated code
      queryClient.invalidateQueries({ queryKey: [`/api/platforms/${data.id}/verification-code`] });
    },
    onError: (error: any) => {
      toast({
        title: "Save Failed",
        description: error.message || "Failed to save platform. Please try again.",
        variant: "destructive",
      });
    }
  });

  const handleSave = async () => {
    if (!platformName) {
      toast({
        title: "Platform Name Required",
        description: "Please enter a name for your trading platform.",
        variant: "destructive",
      });
      return;
    }

    if (!payoutWallet) {
      toast({
        title: "Wallet Address Required",
        description: "Please enter your wallet address to receive revenue payouts.",
        variant: "destructive",
      });
      return;
    }

    // Basic wallet validation (Ethereum address format)
    const walletRegex = /^0x[a-fA-F0-9]{40}$/;
    if (!walletRegex.test(payoutWallet)) {
      toast({
        title: "Invalid Wallet Address",
        description: "Please enter a valid Ethereum wallet address.",
        variant: "destructive",
      });
      return;
    }

    setSavingPlatform(true);
    
    const platformData = {
      userId: user?.id || 1, // Default to userId 1 for demo
      name: platformName,
      customDomain: customDomain || null,
      payoutWallet: payoutWallet,
      logoUrl: logoUrl || null,
      config: {
        logo: logoUrl || null,
        template: "hyperliquid", // We only have one template now
        builderCode: BUILDER_WALLET_ADDRESS,
      },
      isPublished: false, // Save as draft initially
    };

    await savePlatformMutation.mutateAsync(platformData);
    setSavingPlatform(false);
  };

  const handleLogoUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) {
      console.error("No file selected");
      return;
    }
    console.log("Uploading file:", file.name, file.size, file.type);

    // Validate file type
    if (!file.type.startsWith('image/')) {
      toast({
        title: "Invalid File",
        description: "Please upload an image file (PNG, JPG, etc.)",
        variant: "destructive",
      });
      return;
    }

    // Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
      toast({
        title: "File Too Large",
        description: "Please upload an image smaller than 5MB",
        variant: "destructive",
      });
      return;
    }

    setUploadingLogo(true);
    const formData = new FormData();
    formData.append('logo', file);

    try {
      const response = await fetch('/api/upload-logo', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Failed to upload logo');
      }

      const data = await response.json();
      setLogoUrl(data.url);
      toast({
        title: "Logo Uploaded",
        description: "Your logo has been uploaded successfully.",
      });
    } catch (error) {
      toast({
        title: "Upload Failed",
        description: "Failed to upload logo. Please try again.",
        variant: "destructive",
      });
    } finally {
      setUploadingLogo(false);
    }
  };

  const handlePublish = () => {
    if (!savedChanges) {
      toast({
        title: "Save Required",
        description: "Please save your platform before publishing.",
        variant: "destructive",
      });
      return;
    }

    toast({
      title: "Platform Published!",
      description: "Your trading platform is now live and accessible.",
    });
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="container mx-auto px-4 py-8">
        <div className="flex items-center justify-between mb-8">
          <div>
            <h1 className="text-3xl font-bold text-gray-900">Platform Builder</h1>
            <p className="text-gray-600">
              Create your trading platform based on the Hyperliquid template
            </p>
          </div>
          <div className="flex items-center space-x-4">
            {savedPlatformId && (
              <Button 
                variant="outline" 
                onClick={resetFormForNewPlatform}
              >
                <Plus className="w-4 h-4 mr-2" />
                New Platform
              </Button>
            )}
            <Button 
              variant="outline" 
              onClick={handleSave}
              disabled={savingPlatform}
            >
              <Save className="w-4 h-4 mr-2" />
              {savingPlatform ? "Saving..." : "Save Platform"}
            </Button>
            <Button 
              className="bg-liquid-green text-white hover:bg-liquid-accent"
              onClick={handlePublish}
            >
              <Eye className="w-4 h-4 mr-2" />
              Publish
            </Button>
          </div>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Configuration Panel */}
          <div className="lg:col-span-1">
            <Card className="sticky top-4">
              <CardHeader>
                <CardTitle className="flex items-center">
                  <Settings className="w-5 h-5 mr-2" />
                  Platform Configuration
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-6">
                {/* Platform Selector */}
                <div>
                  <Label className="flex items-center mb-2">
                    <FolderOpen className="w-4 h-4 mr-2" />
                    Load Existing Platform
                  </Label>
                  <Select 
                    value={savedPlatformId?.toString() || "new"} 
                    onValueChange={handleLoadPlatform}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Select a platform" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="new">
                        <span className="flex items-center">
                          <Plus className="w-4 h-4 mr-2" />
                          Create New Platform
                        </span>
                      </SelectItem>
                      {platforms?.map((platform) => (
                        <SelectItem key={platform.id} value={platform.id.toString()}>
                          {platform.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <p className="text-sm text-gray-500 mt-1">
                    Select an existing platform to edit or create a new one
                  </p>
                </div>

                <Tabs defaultValue="basic" className="w-full">
                  <TabsList className="grid w-full grid-cols-3">
                    <TabsTrigger value="basic">Basic</TabsTrigger>
                    <TabsTrigger value="revenue">Revenue</TabsTrigger>
                    <TabsTrigger value="domain">Domain</TabsTrigger>
                  </TabsList>
                  
                  <TabsContent value="basic" className="space-y-4 mt-4">
                    <div>
                      <Label htmlFor="platform-name">Platform Name</Label>
                      <Input
                        id="platform-name"
                        placeholder="My Trading Platform"
                        value={platformName}
                        onChange={(e) => setPlatformName(e.target.value)}
                        className="mt-1"
                      />
                    </div>

                    <div>
                      <Label htmlFor="payout-wallet">Revenue Payout Wallet</Label>
                      <Input
                        id="payout-wallet"
                        placeholder="0x..."
                        value={payoutWallet}
                        onChange={(e) => setPayoutWallet(e.target.value)}
                        className="mt-1 font-mono"
                      />
                      <p className="text-xs text-gray-500 mt-1">
                        Your Ethereum wallet address where you'll receive your 70% share of trading fees
                      </p>
                    </div>

                    <div>
                      <Label>Platform Logo</Label>
                      <div className="mt-1 space-y-2">
                        {logoUrl ? (
                          <div className="flex items-center gap-3">
                            <img 
                              src={logoUrl} 
                              alt="Platform logo" 
                              className="w-16 h-16 object-cover rounded-lg border"
                            />
                            <Button
                              variant="outline"
                              size="sm"
                              onClick={() => setLogoUrl("")}
                            >
                              Remove
                            </Button>
                          </div>
                        ) : (
                          <div className="border-2 border-dashed border-gray-300 rounded-lg p-4">
                            <label 
                              htmlFor="logo-upload" 
                              className={`flex flex-col items-center ${uploadingLogo ? 'cursor-not-allowed opacity-50' : 'cursor-pointer'}`}
                            >
                              <Upload className="w-8 h-8 text-gray-400 mb-2" />
                              <span className="text-sm font-medium text-gray-700">
                                {uploadingLogo ? "Uploading..." : "Upload Logo"}
                              </span>
                              <span className="text-xs text-gray-500 mt-1">
                                PNG, JPG up to 5MB
                              </span>
                              <input
                                id="logo-upload"
                                type="file"
                                accept="image/*"
                                onChange={handleLogoUpload}
                                className="hidden"
                              />
                            </label>
                          </div>
                        )}
                      </div>
                    </div>

                    <div className="pt-4">
                      <h4 className="font-medium mb-3">Included Features</h4>
                      <div className="space-y-2">
                        <div className="flex items-center gap-2">
                          <Check className="w-4 h-4 text-green-500" />
                          <span className="text-sm">TradingView Charts</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <Check className="w-4 h-4 text-green-500" />
                          <span className="text-sm">Real-time Order Book</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <Check className="w-4 h-4 text-green-500" />
                          <span className="text-sm">Spot & Perpetual Trading</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <Check className="w-4 h-4 text-green-500" />
                          <span className="text-sm">Privy Wallet Integration</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <Check className="w-4 h-4 text-green-500" />
                          <span className="text-sm">MoonPay Fiat On-Ramp</span>
                        </div>
                      </div>
                    </div>
                  </TabsContent>
                  
                  <TabsContent value="revenue" className="space-y-4 mt-4">
                    <div>
                      <Label>Builder Wallet Address</Label>
                      <div className="flex gap-2 mt-1">
                        <Input
                          value={BUILDER_WALLET_ADDRESS}
                          readOnly
                          className="font-mono text-xs"
                        />
                        <Button
                          variant="outline"
                          size="icon"
                          onClick={() => {
                            navigator.clipboard.writeText(BUILDER_WALLET_ADDRESS);
                            toast({
                              title: "Copied!",
                              description: "Builder wallet address copied to clipboard.",
                            });
                          }}
                        >
                          <Copy className="w-4 h-4" />
                        </Button>
                      </div>
                      <p className="text-xs text-gray-500 mt-1">
                        Builder wallet must have 100+ USDC in perps account
                      </p>
                    </div>
                    
                    <div>
                      <Label>Builder Fee</Label>
                      <div className="p-3 bg-gray-100 rounded-md">
                        <p className="text-sm font-mono">0.1% (10 basis points)</p>
                        <p className="text-xs text-gray-500 mt-1">
                          Users must approve your builder address before fees can be collected
                        </p>
                      </div>
                    </div>

                    <div className="bg-green-50 p-4 rounded-lg">
                      <h4 className="font-medium mb-2 flex items-center">
                        <DollarSign className="w-4 h-4 mr-1" />
                        Revenue Share
                      </h4>
                      <div className="space-y-1 text-sm">
                        <p><strong>Spot Trading:</strong> 0.14% (of 0.2% fee)</p>
                        <p><strong>Perp Trading:</strong> 0.07% (of 0.1% fee)</p>
                        <p className="text-gray-600 text-xs mt-2">
                          You keep 70% of all builder fees
                        </p>
                      </div>
                    </div>
                    
                    {savedPlatformId && (
                      <div>
                        <Label>Platform Verification Code</Label>
                        <div className="flex gap-2 mt-1">
                          <Input
                            value={verificationCode || 'Loading...'}
                            readOnly
                            className="font-mono text-sm"
                          />
                          <Button
                            variant="outline"
                            size="icon"
                            onClick={() => {
                              if (verificationCode) {
                                navigator.clipboard.writeText(verificationCode);
                                toast({
                                  title: "Copied!",
                                  description: "Verification code copied to clipboard.",
                                });
                              }
                            }}
                            disabled={!verificationCode}
                          >
                            <Copy className="w-4 h-4" />
                          </Button>
                        </div>
                        <p className="text-xs text-gray-500 mt-1">
                          Users can verify your platform at liquidlab.trade/verify with this code
                        </p>
                      </div>
                    )}
                  </TabsContent>
                  
                  <TabsContent value="domain" className="space-y-4 mt-4">
                    {savedPlatformId ? (
                      <CustomDomainManager platformId={savedPlatformId} />
                    ) : (
                      <div className="text-center py-8">
                        <Globe className="w-12 h-12 mx-auto mb-4 text-gray-300" />
                        <p className="text-gray-600 mb-4">
                          Save your platform first to manage custom domains
                        </p>
                        <Button 
                          onClick={handleSave}
                          disabled={savingPlatform || !platformName}
                          size="sm"
                        >
                          Save Platform
                        </Button>
                      </div>
                    )}
                  </TabsContent>
                </Tabs>
              </CardContent>
            </Card>
          </div>

          {/* Preview Panel */}
          <div className="lg:col-span-2">
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <CardTitle className="flex items-center">
                    <Eye className="w-5 h-5 mr-2" />
                    Template Preview
                  </CardTitle>
                  <div className="flex items-center gap-2">
                    <Button
                      variant={previewMode === 'desktop' ? 'default' : 'outline'}
                      size="sm"
                      onClick={() => setPreviewMode('desktop')}
                    >
                      <Monitor className="w-4 h-4" />
                    </Button>
                    <Button
                      variant={previewMode === 'mobile' ? 'default' : 'outline'}
                      size="sm"
                      onClick={() => setPreviewMode('mobile')}
                    >
                      <Smartphone className="w-4 h-4" />
                    </Button>
                  </div>
                </div>
              </CardHeader>
              <CardContent className="p-0">
                <div className="bg-gray-100 rounded-b-lg overflow-hidden">
                  <div className="bg-white shadow-sm p-4 border-b">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-4">
                        <Badge variant="secondary">Hyperliquid Template</Badge>
                        <span className="text-sm text-gray-600">
                          Professional trading interface with all features included
                        </span>
                      </div>
                      <Button
                        variant="ghost"
                        size="sm"
                        className="gap-2"
                        onClick={() => window.open(`/example?preview=true&name=${encodeURIComponent(platformName || '')}&logo=${encodeURIComponent(logoUrl || '')}`, '_blank')}
                      >
                        <ExternalLink className="w-4 h-4" />
                        View Full Demo
                      </Button>
                    </div>
                  </div>
                  
                  <div className={`p-8 ${previewMode === 'mobile' ? 'max-w-sm mx-auto' : ''}`}>
                    {/* Show uploaded logo as main preview if available */}
                    {logoUrl ? (
                      <div className="bg-gray-900 rounded-lg p-12 mb-6 text-center">
                        <img 
                          src={logoUrl} 
                          alt="Platform logo preview" 
                          className="max-h-48 mx-auto object-contain"
                        />
                        <h3 className="text-white text-xl font-semibold mt-6">
                          {platformName || "Your Platform Name"}
                        </h3>
                      </div>
                    ) : null}
                    
                    <iframe
                      src={`/example?preview=true&name=${encodeURIComponent(platformName || '')}&logo=${encodeURIComponent(logoUrl || '')}`}
                      title="Trading Platform Preview"
                      className={`w-full shadow-xl ${(platformName || logoUrl) ? 'rounded-b-lg' : 'rounded-lg'}`}
                      style={{ 
                        height: previewMode === 'mobile' ? '600px' : '500px',
                        border: 'none'
                      }}
                    />
                    
                    <div className="mt-6 grid grid-cols-1 md:grid-cols-3 gap-4">
                      <Card className="p-4">
                        <h4 className="font-medium mb-2">Trading Features</h4>
                        <ul className="space-y-1 text-sm text-gray-600">
                          <li>• Spot & Perpetual</li>
                          <li>• Advanced Charts</li>
                          <li>• Real-time Data</li>
                        </ul>
                      </Card>
                      
                      <Card className="p-4">
                        <h4 className="font-medium mb-2">User Experience</h4>
                        <ul className="space-y-1 text-sm text-gray-600">
                          <li>• Social Login</li>
                          <li>• Mobile Responsive</li>
                          <li>• Dark/Light Mode</li>
                        </ul>
                      </Card>
                      
                      <Card className="p-4">
                        <h4 className="font-medium mb-2">Built-in Tools</h4>
                        <ul className="space-y-1 text-sm text-gray-600">
                          <li>• MoonPay On-Ramp</li>
                          <li>• Privy Wallets</li>
                          <li>• Analytics Dashboard</li>
                        </ul>
                      </Card>
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  );
}

```

---

## File: client/src/pages/chart-demo.tsx

```tsx
import { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import TradingViewWidget from "@/components/charts/tradingview-widget";
import { BarChart3, Settings, Maximize2, RefreshCw } from "lucide-react";

export default function ChartDemo() {
  const [selectedSymbol, setSelectedSymbol] = useState("BINANCE:BTCUSDT");
  const [selectedInterval, setSelectedInterval] = useState("1D");
  const [theme, setTheme] = useState<'light' | 'dark'>('light');
  const [refreshKey, setRefreshKey] = useState(0);

  const symbols = [
    { value: "BINANCE:BTCUSDT", label: "BTC/USDT" },
    { value: "BINANCE:ETHUSDT", label: "ETH/USDT" },
    { value: "BINANCE:SOLUSDT", label: "SOL/USDT" },
    { value: "BINANCE:AVAXUSDT", label: "AVAX/USDT" },
    { value: "BINANCE:ADAUSDT", label: "ADA/USDT" },
    { value: "BINANCE:DOTUSDT", label: "DOT/USDT" },
  ];

  const intervals = [
    { value: "1m", label: "1 Minute" },
    { value: "5m", label: "5 Minutes" },
    { value: "15m", label: "15 Minutes" },
    { value: "1h", label: "1 Hour" },
    { value: "4h", label: "4 Hours" },
    { value: "1D", label: "1 Day" },
    { value: "1W", label: "1 Week" },
  ];

  const handleRefresh = () => {
    setRefreshKey(prev => prev + 1);
  };

  return (
    <div className="min-h-screen bg-gray-50 p-4">
      <div className="max-w-7xl mx-auto">
        {/* Header */}
        <div className="mb-6">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">
            TradingView Charts Demo
          </h1>
          <p className="text-gray-600">
            Interactive demonstration of TradingView charts integration in LiquidLab
          </p>
        </div>

        {/* Controls */}
        <Card className="mb-6">
          <CardHeader>
            <CardTitle className="flex items-center">
              <Settings className="w-5 h-5 mr-2" />
              Chart Configuration
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Trading Pair
                </label>
                <Select value={selectedSymbol} onValueChange={setSelectedSymbol}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    {symbols.map((symbol) => (
                      <SelectItem key={symbol.value} value={symbol.value}>
                        {symbol.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Time Interval
                </label>
                <Select value={selectedInterval} onValueChange={setSelectedInterval}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    {intervals.map((interval) => (
                      <SelectItem key={interval.value} value={interval.value}>
                        {interval.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Theme
                </label>
                <Select value={theme} onValueChange={(value: 'light' | 'dark') => setTheme(value)}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="light">Light</SelectItem>
                    <SelectItem value="dark">Dark</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div className="flex items-end">
                <Button 
                  onClick={handleRefresh}
                  variant="outline"
                  className="w-full"
                >
                  <RefreshCw className="w-4 h-4 mr-2" />
                  Refresh Chart
                </Button>
              </div>
            </div>

            <div className="mt-4 flex flex-wrap gap-2">
              <Badge variant="outline">
                <BarChart3 className="w-3 h-3 mr-1" />
                Live Data
              </Badge>
              <Badge variant="outline">
                <Maximize2 className="w-3 h-3 mr-1" />
                Responsive
              </Badge>
              <Badge variant="outline">
                Technical Indicators
              </Badge>
              <Badge variant="outline">
                Drawing Tools
              </Badge>
            </div>
          </CardContent>
        </Card>

        {/* Main Chart */}
        <Card className="mb-6">
          <CardHeader>
            <CardTitle className="flex items-center justify-between">
              <div className="flex items-center">
                <BarChart3 className="w-5 h-5 mr-2" />
                {symbols.find(s => s.value === selectedSymbol)?.label} Chart
              </div>
              <div className="flex items-center space-x-2">
                <Badge variant="secondary">{selectedInterval}</Badge>
                <Badge variant="secondary">{theme}</Badge>
              </div>
            </CardTitle>
          </CardHeader>
          <CardContent>
            <TradingViewWidget
              key={refreshKey}
              symbol={selectedSymbol}
              interval={selectedInterval}
              theme={theme}
              height={600}
              width="100%"
              className="w-full"
            />
          </CardContent>
        </Card>

        {/* Multiple Charts Demo */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
          <Card>
            <CardHeader>
              <CardTitle className="text-lg">BTC/USDT - 1 Hour</CardTitle>
            </CardHeader>
            <CardContent>
              <TradingViewWidget
                symbol="BINANCE:BTCUSDT"
                interval="1h"
                theme="light"
                height={400}
                width="100%"
              />
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="text-lg">ETH/USDT - 4 Hours</CardTitle>
            </CardHeader>
            <CardContent>
              <TradingViewWidget
                symbol="BINANCE:ETHUSDT"
                interval="4h"
                theme="dark"
                height={400}
                width="100%"
              />
            </CardContent>
          </Card>
        </div>

        {/* Features Info */}
        <Card>
          <CardHeader>
            <CardTitle>TradingView Integration Features</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div className="text-center p-4 bg-green-50 rounded-lg">
                <BarChart3 className="w-8 h-8 mx-auto mb-2 text-green-600" />
                <h3 className="font-semibold text-green-800">Real-time Data</h3>
                <p className="text-sm text-green-600">
                  Live market data with instant updates
                </p>
              </div>
              <div className="text-center p-4 bg-blue-50 rounded-lg">
                <Settings className="w-8 h-8 mx-auto mb-2 text-blue-600" />
                <h3 className="font-semibold text-blue-800">Customizable</h3>
                <p className="text-sm text-blue-600">
                  Multiple themes, intervals, and symbols
                </p>
              </div>
              <div className="text-center p-4 bg-purple-50 rounded-lg">
                <Maximize2 className="w-8 h-8 mx-auto mb-2 text-purple-600" />
                <h3 className="font-semibold text-purple-800">Professional</h3>
                <p className="text-sm text-purple-600">
                  Advanced indicators and drawing tools
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
```

---

## File: client/src/pages/dashboard.tsx

```tsx
import { useQuery } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Link, useLocation } from "wouter";
import { 
  TrendingUp, 
  Users, 
  DollarSign, 
  BarChart3, 
  Plus, 
  ExternalLink,
  Settings,
  Eye,
  Receipt,
  PieChart,
  Calendar
} from "lucide-react";
import { useAuth } from "@/hooks/useAuth";
import { useEffect, useState } from "react";
import TwoFactorSetup from "@/components/TwoFactorSetup";
import { TraderAnalytics } from "@/components/TraderAnalytics";
import { queryClient } from "@/lib/queryClient";

export default function Dashboard() {
  const { user, isAuthenticated, isLoading: authLoading } = useAuth();
  const [, setLocation] = useLocation();

  useEffect(() => {
    if (!authLoading && !isAuthenticated) {
      setLocation('/login');
    }
  }, [authLoading, isAuthenticated, setLocation]);

  const { data: platforms, isLoading: platformsLoading } = useQuery({
    queryKey: ['/api/platforms', user?.id],
    queryFn: async () => {
      const response = await fetch(`/api/platforms?userId=${user?.id}`);
      if (!response.ok) throw new Error('Failed to fetch platforms');
      return response.json();
    },
    enabled: !!user?.id
  });

  const { data: analytics, isLoading: analyticsLoading } = useQuery({
    queryKey: ['/api/analytics/dashboard/1'],
    queryFn: async () => {
      const response = await fetch('/api/analytics/dashboard/1');
      if (!response.ok) throw new Error('Failed to fetch analytics');
      return response.json();
    }
  });

  // Fee tracking queries
  const { data: platformRevenues } = useQuery({
    queryKey: ['/api/fees/all-platforms'],
    queryFn: async () => {
      const response = await fetch('/api/fees/all-platforms?period=monthly');
      if (!response.ok) throw new Error('Failed to fetch revenues');
      return response.json();
    }
  });

  const { data: recentTransactions } = useQuery({
    queryKey: ['/api/fees/platform/1'],
    queryFn: async () => {
      const response = await fetch('/api/fees/platform/1?limit=10');
      if (!response.ok) throw new Error('Failed to fetch transactions');
      return response.json();
    }
  });

  // MoonPay revenue query
  const { data: moonpayRevenue } = useQuery({
    queryKey: ['/api/moonpay/revenue/1'],
    queryFn: async () => {
      const response = await fetch('/api/moonpay/revenue/1');
      if (!response.ok) throw new Error('Failed to fetch MoonPay revenue');
      return response.json();
    }
  });

  // Payout queries
  const { data: payoutHistory } = useQuery({
    queryKey: ['/api/payouts/platform/1'],
    queryFn: async () => {
      const response = await fetch('/api/payouts/platform/1');
      if (!response.ok) throw new Error('Failed to fetch payout history');
      return response.json();
    }
  });

  const { data: pendingPayouts } = useQuery({
    queryKey: ['/api/payouts/pending/1'],
    queryFn: async () => {
      const response = await fetch('/api/payouts/pending/1');
      if (!response.ok) throw new Error('Failed to fetch pending payouts');
      return response.json();
    }
  });

  if (authLoading || platformsLoading || analyticsLoading) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
          {[...Array(4)].map((_, i) => (
            <Card key={i}>
              <CardContent className="p-6">
                <Skeleton className="h-4 w-20 mb-2" />
                <Skeleton className="h-8 w-16 mb-2" />
                <Skeleton className="h-4 w-24" />
              </CardContent>
            </Card>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center justify-between mb-8">
        <h1 className="text-3xl font-bold text-gray-900">Dashboard</h1>
        <Link href="/builder">
          <Button className="bg-liquid-green text-white hover:bg-liquid-accent">
            <Plus className="w-4 h-4 mr-2" />
            New Platform
          </Button>
        </Link>
      </div>

      {/* Analytics Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-600">Your Earnings (70%)</p>
                <p className="text-2xl font-bold text-gray-900">$1,993</p>
                <p className="text-sm text-green-600">+12.5% from last month</p>
              </div>
              <div className="bg-green-500/10 p-3 rounded-full">
                <DollarSign className="w-6 h-6 text-green-500" />
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-600">Active Users</p>
                <p className="text-2xl font-bold text-gray-900">1,234</p>
                <p className="text-sm text-blue-600">+8.3% from last month</p>
              </div>
              <div className="bg-blue-500/10 p-3 rounded-full">
                <Users className="w-6 h-6 text-blue-500" />
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-600">Trading Volume</p>
                <p className="text-2xl font-bold text-gray-900">$45.2K</p>
                <p className="text-sm text-purple-600">+15.2% from last month</p>
              </div>
              <div className="bg-purple-500/10 p-3 rounded-full">
                <BarChart3 className="w-6 h-6 text-purple-500" />
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-gray-600">Platforms</p>
                <p className="text-2xl font-bold text-gray-900">{platforms?.length || 0}</p>
                <p className="text-sm text-orange-600">+2 this month</p>
              </div>
              <div className="bg-orange-500/10 p-3 rounded-full">
                <TrendingUp className="w-6 h-6 text-orange-500" />
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Platforms Grid */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        {/* Your Platforms */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center justify-between">
              <span>Your Platforms</span>
              <Link href="/builder">
                <Button variant="outline" size="sm">
                  <Plus className="w-4 h-4 mr-2" />
                  Create New
                </Button>
              </Link>
            </CardTitle>
          </CardHeader>
          <CardContent>
            {platforms && platforms.length > 0 ? (
              <div className="space-y-4">
                {platforms.map((platform: any) => (
                  <div key={platform.id} className="flex items-center justify-between p-4 border rounded-lg">
                    <div className="flex items-center space-x-3">
                      <div className="w-10 h-10 bg-liquid-green/10 rounded-lg flex items-center justify-center">
                        <BarChart3 className="w-5 h-5 text-liquid-green" />
                      </div>
                      <div>
                        <h3 className="font-semibold text-gray-900">{platform.name}</h3>
                        <p className="text-sm text-gray-600">
                          {platform.isPublished ? 'Published' : 'Draft'}
                        </p>
                      </div>
                    </div>
                    <div className="flex items-center space-x-2">
                      <Badge variant={platform.isPublished ? 'default' : 'secondary'}>
                        {platform.isPublished ? 'Live' : 'Draft'}
                      </Badge>
                      <Button variant="ghost" size="sm">
                        <Eye className="w-4 h-4" />
                      </Button>
                      <Button variant="ghost" size="sm">
                        <Settings className="w-4 h-4" />
                      </Button>
                      <Button variant="ghost" size="sm">
                        <ExternalLink className="w-4 h-4" />
                      </Button>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="text-center py-8">
                <BarChart3 className="w-12 h-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-semibold text-gray-900 mb-2">No platforms yet</h3>
                <p className="text-gray-600 mb-4">
                  Create your first trading platform to start earning revenue
                </p>
                <Link href="/builder">
                  <Button className="bg-liquid-green text-white hover:bg-liquid-accent">
                    Create Your First Platform
                  </Button>
                </Link>
              </div>
            )}
          </CardContent>
        </Card>

        {/* Builder Code Info */}
        <Card>
          <CardHeader>
            <CardTitle>Builder Code</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              <div className="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                <div>
                  <p className="text-sm text-gray-600">Builder Fee</p>
                  <p className="font-mono text-lg font-semibold">0.1%</p>
                  <p className="text-xs text-gray-500 mt-1">10 basis points on all trades</p>
                </div>
                <div>
                  <p className="text-xs text-gray-400">Note: Users must approve your builder wallet</p>
                </div>
              </div>
              
              <div className="p-4 bg-gray-50 rounded-lg">
                <div>
                  <p className="text-sm text-gray-600">Revenue Split</p>
                  <div className="flex items-center gap-4 mt-2">
                    <div>
                      <p className="text-lg font-semibold text-liquid-green">70%</p>
                      <p className="text-xs text-gray-600">To Platform Owners</p>
                    </div>
                    <div className="text-gray-400">|</div>
                    <div>
                      <p className="text-lg font-semibold text-gray-700">30%</p>
                      <p className="text-xs text-gray-600">To LiquidLab</p>
                    </div>
                  </div>
                </div>
              </div>

              <div className="pt-4 border-t">
                <h4 className="font-semibold mb-2">How it works</h4>
                <ul className="text-sm text-gray-600 space-y-1">
                  <li>• Users pay your commission rate on top of base trading fees</li>
                  <li>• Revenue is automatically collected and tracked</li>
                  <li>• Withdraw earnings anytime to your connected wallet</li>
                </ul>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Fee Tracking Section */}
      <div className="mt-8">
        <h2 className="text-2xl font-bold text-gray-900 mb-6">Fee Tracking & Revenue</h2>
        
        <Tabs defaultValue="overview" className="w-full">
          <TabsList className="grid w-full grid-cols-6">
            <TabsTrigger value="overview">Overview</TabsTrigger>
            <TabsTrigger value="transactions">Recent Transactions</TabsTrigger>
            <TabsTrigger value="platforms">Platform Revenues</TabsTrigger>
            <TabsTrigger value="analytics">Trader Analytics</TabsTrigger>
            <TabsTrigger value="payouts">Payouts</TabsTrigger>
            <TabsTrigger value="account">Account</TabsTrigger>
          </TabsList>
          
          <TabsContent value="overview" className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <Card>
                <CardContent className="p-6">
                  <div className="flex items-center justify-between">
                    <div>
                      <p className="text-sm text-gray-600">Trading Fee Earnings (70%)</p>
                      <p className="text-2xl font-bold text-gray-900">
                        ${(platformRevenues?.reduce((sum: number, r: any) => sum + parseFloat(r.totalFees || 0), 0) * 0.70).toFixed(2) || '0.00'}
                      </p>
                      <p className="text-sm text-green-600">Your share from trades</p>
                    </div>
                    <div className="bg-green-500/10 p-3 rounded-full">
                      <Receipt className="w-6 h-6 text-green-500" />
                    </div>
                  </div>
                </CardContent>
              </Card>

              <Card>
                <CardContent className="p-6">
                  <div className="flex items-center justify-between">
                    <div>
                      <p className="text-sm text-gray-600">MoonPay Earnings (50%)</p>
                      <p className="text-2xl font-bold text-gray-900">
                        ${moonpayRevenue?.platformEarnings || '0.00'}
                      </p>
                      <p className="text-sm text-purple-600">From fiat purchases</p>
                    </div>
                    <div className="bg-purple-500/10 p-3 rounded-full">
                      <DollarSign className="w-6 h-6 text-purple-500" />
                    </div>
                  </div>
                </CardContent>
              </Card>
              
              <Card>
                <CardContent className="p-6">
                  <div className="flex items-center justify-between">
                    <div>
                      <p className="text-sm text-gray-600">Total Combined Earnings</p>
                      <p className="text-2xl font-bold text-gray-900">
                        ${((platformRevenues?.reduce((sum: number, r: any) => sum + parseFloat(r.totalFees || 0), 0) * 0.70) + parseFloat(moonpayRevenue?.platformEarnings || '0')).toFixed(2)}
                      </p>
                      <p className="text-sm text-blue-600">Trading + MoonPay</p>
                    </div>
                    <div className="bg-blue-500/10 p-3 rounded-full">
                      <PieChart className="w-6 h-6 text-blue-500" />
                    </div>
                  </div>
                </CardContent>
              </Card>
            </div>
            
            <Card>
              <CardHeader>
                <CardTitle>Revenue Split Breakdown</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                    <div>
                      <p className="font-semibold">Spot Trading</p>
                      <p className="text-sm text-gray-600">0.2% builder fee on volume</p>
                    </div>
                    <div className="text-right">
                      <p className="font-semibold">70% / 30%</p>
                      <p className="text-sm text-gray-600">Platform / LiquidLab</p>
                    </div>
                  </div>
                  <div className="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                    <div>
                      <p className="font-semibold">Perpetual Trading</p>
                      <p className="text-sm text-gray-600">0.1% builder fee on volume</p>
                    </div>
                    <div className="text-right">
                      <p className="font-semibold">70% / 30%</p>
                      <p className="text-sm text-gray-600">Platform / LiquidLab</p>
                    </div>
                  </div>
                  <div className="flex items-center justify-between p-4 bg-purple-50 rounded-lg">
                    <div>
                      <p className="font-semibold">MoonPay Fiat Purchases</p>
                      <p className="text-sm text-gray-600">1% affiliate commission</p>
                    </div>
                    <div className="text-right">
                      <p className="font-semibold">50% / 50%</p>
                      <p className="text-sm text-gray-600">Platform / LiquidLab</p>
                    </div>
                  </div>
                  <div className="mt-4 p-4 bg-blue-50 rounded-lg">
                    <p className="text-sm font-semibold text-blue-900">MoonPay Stats</p>
                    <p className="text-xs text-blue-700 mt-1">
                      Total Fiat Purchases: ${moonpayRevenue?.totalPurchases || '0.00'}
                    </p>
                    <p className="text-xs text-blue-700">
                      Your Earnings: ${moonpayRevenue?.platformEarnings || '0.00'} (50% of fees)
                    </p>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
          
          <TabsContent value="transactions" className="space-y-4">
            <Card>
              <CardHeader>
                <CardTitle>Recent Fee Transactions</CardTitle>
              </CardHeader>
              <CardContent>
                {recentTransactions && recentTransactions.length > 0 ? (
                  <div className="space-y-2">
                    {recentTransactions.map((tx: any) => (
                      <div key={tx.id} className="flex items-center justify-between p-3 border rounded-lg">
                        <div>
                          <p className="font-semibold">{tx.tradeType === 'spot' ? 'Spot' : 'Perp'} Trade</p>
                          <p className="text-sm text-gray-600">Volume: ${parseFloat(tx.tradeVolume).toFixed(2)}</p>
                        </div>
                        <div className="text-right">
                          <p className="font-semibold">${parseFloat(tx.totalFee).toFixed(4)}</p>
                          <Badge variant={tx.status === 'distributed' ? 'default' : 'secondary'}>
                            {tx.status}
                          </Badge>
                        </div>
                      </div>
                    ))}
                  </div>
                ) : (
                  <div className="text-center py-8">
                    <Receipt className="w-12 h-12 text-gray-400 mx-auto mb-4" />
                    <h3 className="text-lg font-semibold text-gray-900 mb-2">No transactions yet</h3>
                    <p className="text-gray-600">
                      Fee transactions will appear here once platforms start generating trades
                    </p>
                  </div>
                )}
              </CardContent>
            </Card>
          </TabsContent>
          
          <TabsContent value="platforms" className="space-y-4">
            <Card>
              <CardHeader>
                <CardTitle>Platform Revenue Summary</CardTitle>
              </CardHeader>
              <CardContent>
                {platformRevenues && platformRevenues.length > 0 ? (
                  <div className="space-y-2">
                    {platformRevenues.map((revenue: any) => (
                      <div key={revenue.platformId} className="flex items-center justify-between p-3 border rounded-lg">
                        <div>
                          <p className="font-semibold">Platform #{revenue.platformId}</p>
                          <p className="text-sm text-gray-600">
                            {revenue.tradeCount} trades · ${parseFloat(revenue.totalVolume).toFixed(2)} volume
                          </p>
                        </div>
                        <div className="text-right">
                          <p className="font-semibold text-green-600">
                            ${parseFloat(revenue.platformEarnings).toFixed(2)}
                          </p>
                          <p className="text-sm text-gray-600">Platform earnings</p>
                        </div>
                      </div>
                    ))}
                  </div>
                ) : (
                  <div className="text-center py-8">
                    <BarChart3 className="w-12 h-12 text-gray-400 mx-auto mb-4" />
                    <h3 className="text-lg font-semibold text-gray-900 mb-2">No revenue data yet</h3>
                    <p className="text-gray-600">
                      Revenue summaries will appear here as platforms generate trading fees
                    </p>
                  </div>
                )}
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="analytics" className="space-y-4">
            {platforms && platforms.length > 0 ? (
              <TraderAnalytics platformId={platforms[0].id} />
            ) : (
              <Card>
                <CardContent className="text-center py-8">
                  <Users className="w-12 h-12 text-gray-400 mx-auto mb-4" />
                  <h3 className="text-lg font-semibold text-gray-900 mb-2">No platforms found</h3>
                  <p className="text-gray-600">
                    Create a platform first to view trader analytics
                  </p>
                </CardContent>
              </Card>
            )}
          </TabsContent>

          <TabsContent value="payouts" className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {/* Pending Payouts */}
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center justify-between">
                    <span>Pending Payouts</span>
                    <Badge variant="secondary">Weekly</Badge>
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  {pendingPayouts && pendingPayouts.length > 0 ? (
                    <div className="space-y-3">
                      {pendingPayouts.map((payout: any, index: number) => (
                        <div key={index} className="p-3 bg-green-50 rounded-lg">
                          <div className="flex items-center justify-between mb-2">
                            <p className="font-semibold text-green-900">${payout.amount}</p>
                            <Badge className="bg-green-600">{payout.period}</Badge>
                          </div>
                          <p className="text-sm text-green-700">
                            Next payout scheduled for end of period
                          </p>
                        </div>
                      ))}
                    </div>
                  ) : (
                    <div className="text-center py-6">
                      <DollarSign className="w-10 h-10 text-gray-400 mx-auto mb-3" />
                      <p className="text-gray-600">No pending payouts</p>
                      <p className="text-sm text-gray-500 mt-1">
                        Payouts are processed weekly for amounts over $10
                      </p>
                    </div>
                  )}
                </CardContent>
              </Card>

              {/* Payout Configuration */}
              <Card>
                <CardHeader>
                  <CardTitle>Payout Settings</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="space-y-4">
                    <div className="p-4 bg-gray-50 rounded-lg">
                      <p className="text-sm text-gray-600 mb-1">Payout Method</p>
                      <p className="font-semibold">USDC on Arbitrum</p>
                      <p className="text-xs text-gray-500 mt-1">Low fees, fast transfers</p>
                    </div>
                    
                    <div className="p-4 bg-gray-50 rounded-lg">
                      <p className="text-sm text-gray-600 mb-1">Minimum Payout</p>
                      <p className="font-semibold">$10.00</p>
                      <p className="text-xs text-gray-500 mt-1">Reduces transaction costs</p>
                    </div>

                    <div className="p-4 bg-gray-50 rounded-lg">
                      <p className="text-sm text-gray-600 mb-1">Payout Schedule</p>
                      <p className="font-semibold">Weekly</p>
                      <p className="text-xs text-gray-500 mt-1">Every Monday at 00:00 UTC</p>
                    </div>
                  </div>
                </CardContent>
              </Card>
            </div>

            {/* Payout History */}
            <Card>
              <CardHeader>
                <CardTitle>Payout History</CardTitle>
              </CardHeader>
              <CardContent>
                {payoutHistory && payoutHistory.length > 0 ? (
                  <div className="space-y-2">
                    {payoutHistory.map((payout: any) => (
                      <div key={payout.id} className="flex items-center justify-between p-3 border rounded-lg">
                        <div>
                          <p className="font-semibold">${payout.amount} {payout.currency}</p>
                          <p className="text-sm text-gray-600">
                            {new Date(payout.processedAt).toLocaleDateString()}
                          </p>
                        </div>
                        <div className="text-right">
                          <Badge variant={payout.status === 'completed' ? 'default' : 'secondary'}>
                            {payout.status}
                          </Badge>
                          {payout.txHash && (
                            <a 
                              href={`https://arbiscan.io/tx/${payout.txHash}`}
                              target="_blank"
                              rel="noopener noreferrer"
                              className="text-xs text-blue-600 hover:underline block mt-1"
                            >
                              View on Arbiscan
                            </a>
                          )}
                        </div>
                      </div>
                    ))}
                  </div>
                ) : (
                  <div className="text-center py-8">
                    <Calendar className="w-12 h-12 text-gray-400 mx-auto mb-4" />
                    <h3 className="text-lg font-semibold text-gray-900 mb-2">No payouts yet</h3>
                    <p className="text-gray-600">
                      Your payout history will appear here once you receive your first payment
                    </p>
                  </div>
                )}
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="account" className="space-y-4">
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              {/* Account Information */}
              <Card>
                <CardHeader>
                  <CardTitle>Account Information</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="space-y-4">
                    <div className="p-4 bg-gray-50 rounded-lg">
                      <p className="text-sm text-gray-600 mb-1">Username</p>
                      <p className="font-semibold">{user?.username || 'Not set'}</p>
                    </div>
                    
                    <div className="p-4 bg-gray-50 rounded-lg">
                      <p className="text-sm text-gray-600 mb-1">Email</p>
                      <p className="font-semibold">{user?.email}</p>
                    </div>

                    <div className="p-4 bg-gray-50 rounded-lg">
                      <p className="text-sm text-gray-600 mb-1">Wallet Address</p>
                      <p className="font-mono text-sm">{user?.walletAddress || 'Not connected'}</p>
                    </div>

                    <div className="p-4 bg-gray-50 rounded-lg">
                      <p className="text-sm text-gray-600 mb-1">Member Since</p>
                      <p className="font-semibold">
                        {user?.createdAt ? new Date(user.createdAt).toLocaleDateString() : 'N/A'}
                      </p>
                    </div>
                  </div>
                </CardContent>
              </Card>

              {/* Security Settings */}
              <TwoFactorSetup 
                enabled={user?.twoFactorEnabled || false}
                onStatusChange={() => {
                  // Refetch user data to update 2FA status
                  queryClient.invalidateQueries({ queryKey: ["/api/auth/user"] });
                }}
              />
            </div>
          </TabsContent>
        </Tabs>
      </div>
    </div>
  );
}

```

---

## File: client/src/pages/education.tsx

```tsx
import { useState } from "react";
import { Link } from "wouter";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { BookOpen, TrendingUp, AlertTriangle, DollarSign, Search, Clock, User, ArrowRight } from "lucide-react";

const educationCategories = [
  {
    id: "hyperliquid",
    title: "Hyperliquid Basics",
    description: "Learn about the Hyperliquid DEX and its features",
    icon: <BookOpen className="w-5 h-5" />,
    color: "bg-blue-100 text-blue-800",
    articles: [
      {
        title: "What is Hyperliquid?",
        description: "A comprehensive introduction to Hyperliquid's decentralized exchange",
        readTime: "5 min",
        difficulty: "Beginner",
        content: `
# What is Hyperliquid?

Hyperliquid is a high-performance decentralized exchange (DEX) built specifically for derivatives trading. Unlike traditional centralized exchanges, Hyperliquid operates entirely on-chain while maintaining the speed and user experience of centralized platforms.

## Key Features

### 1. Fully On-Chain Operations
- All trades are executed on the blockchain
- Complete transparency and decentralization
- No custodial risk - you control your funds

### 2. High Performance
- Sub-second trade execution
- Advanced order types (limit, market, stop-loss)
- Real-time order book updates

### 3. Perpetual Futures Focus
- Trade perpetual contracts on major cryptocurrencies
- Up to 50x leverage available
- Automatic position management

## How It Works

Hyperliquid uses a unique architecture that combines:
- **On-chain settlement**: All trades are recorded on the blockchain
- **Optimized execution**: Fast matching engine for instant trades
- **Decentralized governance**: Community-driven protocol updates

## Getting Started

To start trading on Hyperliquid:
1. Connect your wallet (MetaMask, WalletConnect)
2. Deposit USDC as collateral
3. Choose your trading pair
4. Place your first trade

## Safety Features

- **Liquidation Protection**: Automatic position closure to prevent losses exceeding collateral
- **Risk Management**: Built-in tools to manage your exposure
- **Transparent Fees**: Clear fee structure with no hidden costs
        `
      },
      {
        title: "Hyperliquid vs Traditional Exchanges",
        description: "Compare Hyperliquid with centralized exchanges",
        readTime: "7 min",
        difficulty: "Beginner",
        content: `
# Hyperliquid vs Traditional Exchanges

Understanding the differences between Hyperliquid and traditional centralized exchanges is crucial for making informed trading decisions.

## Centralized Exchanges (CEX)

### Advantages:
- High liquidity
- Fast execution
- Advanced trading features
- Customer support

### Disadvantages:
- **Custodial Risk**: Exchange controls your funds
- **Regulatory Risk**: Subject to government regulations
- **Counterparty Risk**: Exchange could fail or be hacked
- **Limited Transparency**: Order matching happens off-chain

## Hyperliquid (DEX)

### Advantages:
- **Self-Custody**: You control your private keys
- **Transparency**: All trades visible on-chain
- **No KYC**: Trade without identity verification
- **Global Access**: Available worldwide
- **Censorship Resistant**: Cannot be shut down by authorities

### Disadvantages:
- Learning curve for wallet management
- Gas fees for transactions
- Limited customer support
- Newer technology with potential bugs

## Key Differences

| Feature | Centralized Exchange | Hyperliquid |
|---------|---------------------|-------------|
| Fund Control | Exchange | User |
| Transparency | Limited | Full |
| Speed | Very Fast | Fast |
| Liquidity | High | Growing |
| KYC Required | Yes | No |
| Regulatory Risk | High | Low |

## Which Should You Choose?

**Choose Hyperliquid if:**
- You value self-custody and decentralization
- You want transparency in trading
- You prefer no KYC requirements
- You're comfortable with wallet management

**Choose Traditional Exchanges if:**
- You want maximum liquidity
- You prefer customer support
- You're new to crypto trading
- You don't mind custodial arrangements
        `
      },
      {
        title: "Setting Up Your Hyperliquid Account",
        description: "Step-by-step guide to getting started",
        readTime: "8 min",
        difficulty: "Beginner",
        content: `
# Setting Up Your Hyperliquid Account

Get started with Hyperliquid in just a few simple steps.

## Step 1: Install a Web3 Wallet

### MetaMask (Recommended)
1. Visit [metamask.io](https://metamask.io)
2. Download the browser extension
3. Create a new wallet or import existing one
4. **Important**: Write down your seed phrase and store it safely

### Alternative Wallets
- WalletConnect compatible wallets
- Coinbase Wallet
- Trust Wallet

## Step 2: Connect to Hyperliquid

1. Visit [app.hyperliquid.xyz](https://app.hyperliquid.xyz)
2. Click "Connect Wallet"
3. Select your wallet provider
4. Approve the connection

## Step 3: Add Funds

### Deposit USDC
1. Click "Deposit" in the top menu
2. Select USDC as your deposit currency
3. Enter the amount you want to deposit
4. Confirm the transaction in your wallet

### Minimum Deposit
- No minimum deposit required
- Consider gas fees when depositing small amounts
- Start with a small amount to test the system

## Step 4: Verify Your Setup

### Check Your Balance
- Your USDC balance should appear in the top right
- It may take a few minutes for the deposit to confirm

### Test a Small Trade
1. Select a trading pair (e.g., BTC-USD)
2. Place a small market order
3. Verify the trade executed correctly

## Step 5: Security Best Practices

### Wallet Security
- Never share your private keys or seed phrase
- Use a hardware wallet for large amounts
- Enable two-factor authentication if available

### Trading Security
- Start with small positions
- Use stop-losses to limit risk
- Don't invest more than you can afford to lose

## Troubleshooting

### Common Issues:
- **Wallet won't connect**: Try refreshing the page
- **Transaction failed**: Check if you have enough ETH for gas
- **Deposit not showing**: Wait for blockchain confirmation

### Getting Help:
- Check Hyperliquid's documentation
- Join their Discord community
- Follow their Twitter for updates
        `
      }
    ]
  },
  {
    id: "perpetual-futures",
    title: "Perpetual Futures",
    description: "Understanding perpetual contracts and how they work",
    icon: <TrendingUp className="w-5 h-5" />,
    color: "bg-green-100 text-green-800",
    articles: [
      {
        title: "What are Perpetual Futures?",
        description: "Introduction to perpetual contracts and their unique features",
        readTime: "6 min",
        difficulty: "Intermediate",
        content: `
# What are Perpetual Futures?

Perpetual futures, also known as perpetual swaps, are derivative contracts that allow traders to speculate on the price of an asset without owning the underlying asset and without an expiration date.

## Key Characteristics

### 1. No Expiration Date
- Unlike traditional futures, perpetual contracts never expire
- You can hold positions as long as you want
- No need to roll over contracts

### 2. Leverage Trading
- Trade with borrowed funds to amplify potential returns
- Common leverage ratios: 2x, 5x, 10x, 25x, 50x
- Higher leverage = higher risk and potential rewards

### 3. Funding Rate Mechanism
- Keeps the contract price close to the spot price
- Paid between long and short traders
- Calculated every 8 hours on most platforms

## How They Work

### Long Position
- **Betting the price will go up**
- Buy the perpetual contract
- Profit when price increases
- Loss when price decreases

### Short Position
- **Betting the price will go down**
- Sell the perpetual contract
- Profit when price decreases
- Loss when price increases

## Funding Rates

The funding rate is a mechanism that ensures the perpetual contract price stays close to the spot price.

### Positive Funding Rate
- Longs pay shorts
- Happens when contract price > spot price
- Indicates bullish sentiment

### Negative Funding Rate
- Shorts pay longs
- Happens when contract price < spot price
- Indicates bearish sentiment

## Example Trade

Let's say BTC is trading at $50,000:

**Long Position with 10x Leverage:**
- Invest $1,000 of your own money
- Control $10,000 worth of BTC
- If BTC goes to $55,000 (10% increase)
- Your profit: $1,000 (100% return on your investment)
- If BTC goes to $45,000 (10% decrease)
- Your loss: $1,000 (100% loss of your investment)

## Advantages

1. **No Expiration**: Hold positions indefinitely
2. **High Liquidity**: Easy to enter and exit positions
3. **Leverage**: Amplify potential returns
4. **Short Selling**: Profit from falling prices
5. **24/7 Trading**: Markets never close

## Risks

1. **Liquidation Risk**: Positions can be forcefully closed
2. **Funding Costs**: May pay funding fees
3. **High Volatility**: Amplified by leverage
4. **Complexity**: Requires understanding of derivatives

## Best Practices

1. **Start Small**: Begin with low leverage
2. **Use Stop Losses**: Limit potential losses
3. **Monitor Funding Rates**: Understand the costs
4. **Risk Management**: Never risk more than you can afford
5. **Education**: Learn before you trade
        `
      },
      {
        title: "Funding Rates Explained",
        description: "Deep dive into how funding rates work and their impact",
        readTime: "8 min",
        difficulty: "Intermediate",
        content: `
# Funding Rates Explained

Funding rates are a crucial mechanism in perpetual futures trading that keeps contract prices aligned with spot prices. Understanding them is essential for successful trading.

## What is a Funding Rate?

The funding rate is a periodic payment between long and short traders that helps maintain the perpetual contract price close to the underlying asset's spot price.

## How It Works

### Payment Direction
- **Positive Funding Rate**: Long traders pay short traders
- **Negative Funding Rate**: Short traders pay long traders

### Payment Schedule
- Most exchanges: Every 8 hours
- Hyperliquid: Every 8 hours (00:00, 08:00, 16:00 UTC)
- Payment only occurs if you hold a position at the funding time

## Funding Rate Calculation

The funding rate typically consists of two components:

### 1. Interest Rate Component
- Usually fixed at 0.01% per 8 hours
- Represents the cost of borrowing

### 2. Premium Component
- Based on the difference between contract and spot price
- Calculated using the average premium over the funding period

**Formula:**
\`\`\`
Funding Rate = Interest Rate + Premium
\`\`\`

## Impact on Trading

### For Long Positions
- **Positive Funding**: You pay funding fees
- **Negative Funding**: You receive funding payments
- High positive funding rates can eat into profits

### For Short Positions
- **Positive Funding**: You receive funding payments
- **Negative Funding**: You pay funding fees
- High negative funding rates can reduce profits

## Reading Funding Rates

### Typical Ranges
- **Normal Market**: -0.05% to +0.05%
- **Bullish Market**: +0.05% to +0.50%
- **Bearish Market**: -0.50% to -0.05%
- **Extreme**: Beyond ±0.50%

### What High Rates Mean
- **High Positive**: Strong bullish sentiment, longs paying premium
- **High Negative**: Strong bearish sentiment, shorts paying premium

## Trading Strategies

### Funding Rate Arbitrage
1. **Identify High Funding Rates**
2. **Take Opposite Position**: If funding is high positive, go short
3. **Collect Funding**: Earn payments from the other side
4. **Hedge Risk**: Use spot positions to reduce price risk

### Timing Entries
- **Before Funding**: Avoid entering just before funding time
- **After Funding**: Better timing for new positions
- **Rate Changes**: Monitor upcoming funding rate estimates

## Examples

### Example 1: BTC Long Position
- Position Size: $10,000
- Funding Rate: +0.05%
- Funding Payment: $10,000 × 0.05% = $5 (you pay)

### Example 2: ETH Short Position
- Position Size: $5,000
- Funding Rate: +0.10%
- Funding Payment: $5,000 × 0.10% = $5 (you receive)

## Monitoring Tools

### On Hyperliquid
- Current funding rate displayed on trading interface
- Historical funding rates available
- Next funding time countdown

### External Tools
- Funding rate aggregators
- Historical data analysis
- Mobile apps with alerts

## Best Practices

1. **Monitor Rates**: Check funding rates before opening positions
2. **Factor in Costs**: Include funding costs in your trading calculations
3. **Timing**: Consider funding times when entering/exiting
4. **Hedging**: Use spot positions to reduce funding exposure
5. **Alerts**: Set up notifications for extreme funding rates

## Common Mistakes

1. **Ignoring Funding**: Not accounting for funding costs
2. **Bad Timing**: Opening positions right before funding
3. **Overleveraging**: High funding rates + high leverage = big costs
4. **Chasing Rates**: Entering trades solely for funding payments
        `
      },
      {
        title: "Mark Price vs Last Price",
        description: "Understanding different price types and their importance",
        readTime: "5 min",
        difficulty: "Intermediate",
        content: `
# Mark Price vs Last Price

Understanding the difference between mark price and last price is crucial for perpetual futures trading, especially for liquidation calculations.

## What is Last Price?

The last price is simply the price at which the most recent trade was executed on the exchange.

### Characteristics:
- **Real-time**: Updates with every trade
- **Volatile**: Can have sudden spikes or drops
- **Manipulable**: Large orders can temporarily move the price

## What is Mark Price?

The mark price is a calculated price that represents the "fair value" of the perpetual contract based on the underlying spot price.

### Characteristics:
- **Stable**: Less volatile than last price
- **Fair**: Represents true market value
- **Manipulation-resistant**: Harder to manipulate

## How Mark Price is Calculated

### Basic Formula:
\`\`\`
Mark Price = Spot Price + Funding Basis
\`\`\`

### Funding Basis:
- The difference between the perpetual and spot price
- Calculated using an exponential moving average
- Helps smooth out price discrepancies

### Spot Price Sources:
- Multiple spot exchanges (Binance, Coinbase, etc.)
- Weighted average of prices
- Removes outliers and manipulation attempts

## Why Mark Price Matters

### 1. Liquidation Calculations
- **Liquidation Price**: Based on mark price, not last price
- **Prevents Manipulation**: Protects against artificial liquidations
- **Fair Liquidation**: Ensures liquidations happen at fair prices

### 2. Unrealized PnL
- **Portfolio Value**: Calculated using mark price
- **Accurate Reporting**: Shows true position value
- **Margin Requirements**: Based on mark price

### 3. Risk Management
- **Stop Orders**: Some platforms use mark price for triggers
- **Margin Calls**: Calculated using mark price
- **Position Sizing**: Based on mark price value

## Examples

### Example 1: Market Manipulation Scenario
- **BTC Spot Price**: $50,000
- **Last Price**: $52,000 (due to large buy order)
- **Mark Price**: $50,100 (calculated fair value)
- **Liquidation**: Uses mark price, preventing unfair liquidation

### Example 2: Normal Trading
- **ETH Spot Price**: $3,000
- **Last Price**: $3,005
- **Mark Price**: $3,002
- **Small Difference**: Normal market conditions

## Monitoring Both Prices

### On Trading Platforms:
- **Last Price**: Usually displayed prominently
- **Mark Price**: Often shown in smaller text or separate section
- **Difference**: Some platforms show the spread

### Trading Implications:
- **Entry/Exit**: Use last price for actual trades
- **Risk Management**: Use mark price for position sizing
- **Liquidation Risk**: Monitor mark price for liquidation levels

## Best Practices

### 1. Always Check Mark Price
- Before opening large positions
- When calculating liquidation risk
- During volatile market conditions

### 2. Understand the Difference
- Large differences indicate manipulation or low liquidity
- Small differences are normal
- Use mark price for risk calculations

### 3. Set Conservative Liquidation Levels
- Account for potential mark price movements
- Don't rely solely on last price
- Leave buffer for price volatility

### 4. Monitor During High Volatility
- Differences can increase during volatile periods
- Be extra cautious with leverage
- Consider reducing position sizes

## Common Scenarios

### Flash Crashes
- Last price may spike down briefly
- Mark price remains stable
- Prevents unnecessary liquidations

### Low Liquidity
- Last price may be stale
- Mark price continues to track spot
- Provides better price discovery

### Market Manipulation
- Large orders affect last price
- Mark price remains fair
- Protects traders from manipulation

## Conclusion

Understanding the difference between mark price and last price is essential for:
- Accurate risk management
- Avoiding unfair liquidations
- Making informed trading decisions
- Calculating true position value

Always monitor both prices and understand their implications for your trading strategy.
        `
      }
    ]
  },
  {
    id: "leverage-trading",
    title: "Leverage Trading",
    description: "Learn about leverage, margin, and risk management",
    icon: <AlertTriangle className="w-5 h-5" />,
    color: "bg-red-100 text-red-800",
    articles: [
      {
        title: "Understanding Leverage",
        description: "What is leverage and how does it work?",
        readTime: "7 min",
        difficulty: "Beginner",
        content: `
# Understanding Leverage

Leverage is a powerful tool that allows traders to control larger positions with less capital. While it can amplify profits, it also significantly increases risk.

## What is Leverage?

Leverage is using borrowed funds to increase your buying power and potentially amplify returns on an investment.

### Key Concepts:
- **Leverage Ratio**: The ratio of your total position to your own capital
- **Margin**: The amount of your own money required to open a position
- **Borrowed Capital**: The additional funds provided by the exchange

## How Leverage Works

### Basic Example:
- **Your Capital**: $1,000
- **Leverage**: 10x
- **Position Size**: $10,000
- **Borrowed**: $9,000

### The Math:
\`\`\`
Position Size = Your Capital × Leverage Ratio
$10,000 = $1,000 × 10
\`\`\`

## Leverage Ratios

### Common Ratios:
- **2x**: Double your position size
- **5x**: Five times your position size
- **10x**: Ten times your position size
- **25x**: Twenty-five times your position size
- **50x**: Fifty times your position size

### Risk Increases with Leverage:
- **Higher Leverage** = **Higher Risk**
- **Higher Leverage** = **Higher Potential Rewards**
- **Higher Leverage** = **Easier to Get Liquidated**

## Profit and Loss Amplification

### Example: BTC at $50,000
**Without Leverage:**
- Investment: $1,000
- BTC moves to $55,000 (+10%)
- Profit: $100 (10% return)

**With 10x Leverage:**
- Investment: $1,000
- Position Size: $10,000
- BTC moves to $55,000 (+10%)
- Profit: $1,000 (100% return)

**The Downside:**
- If BTC drops to $45,000 (-10%)
- Loss: $1,000 (100% loss)
- **Position would be liquidated**

## Margin Requirements

### Initial Margin
- The minimum amount needed to open a position
- Calculated as: Position Size ÷ Leverage Ratio
- Example: $10,000 position ÷ 10x = $1,000 initial margin

### Maintenance Margin
- The minimum amount needed to keep a position open
- Usually lower than initial margin
- Varies by exchange and asset

### Margin Call
- Warning when your margin falls below maintenance level
- Opportunity to add funds or close positions
- Prevents automatic liquidation

## Liquidation

### What is Liquidation?
- Automatic closure of your position
- Happens when losses exceed your margin
- Protects the exchange from losses

### Liquidation Price Calculation
\`\`\`
Liquidation Price = Entry Price × (1 - Initial Margin ÷ Leverage)
\`\`\`

### Example:
- Entry Price: $50,000
- Leverage: 10x
- Initial Margin: 10%
- Liquidation Price: $50,000 × (1 - 0.10) = $45,000

## Types of Leverage

### Cross Margin
- Uses your entire account balance as collateral
- Positions share the same margin pool
- Higher liquidation threshold
- More complex risk management

### Isolated Margin
- Each position has its own margin
- Losses limited to position margin
- Easier risk management
- Lower liquidation threshold

## Leverage Strategies

### Conservative Approach (2x-5x)
- **Lower Risk**: Less likely to be liquidated
- **Steady Returns**: Modest amplification
- **Good for Beginners**: Easier to manage

### Moderate Approach (5x-10x)
- **Balanced Risk/Reward**: Moderate amplification
- **Requires Skill**: Need good risk management
- **Popular Choice**: Common among experienced traders

### Aggressive Approach (10x+)
- **High Risk**: Easy to get liquidated
- **High Reward**: Significant amplification
- **Expert Level**: Requires excellent risk management

## Risk Management with Leverage

### 1. Position Sizing
- Never risk more than 1-2% of your account per trade
- Calculate position size based on risk tolerance
- Account for leverage amplification

### 2. Stop Losses
- Always set stop losses before entering
- Place them at logical technical levels
- Account for volatility and spread

### 3. Take Profits
- Set profit targets before entering
- Take partial profits as price moves in your favor
- Don't get greedy

### 4. Diversification
- Don't put all capital in one trade
- Spread risk across multiple positions
- Use different strategies

## Common Leverage Mistakes

### 1. Over-leveraging
- Using too much leverage for your experience level
- Not accounting for volatility
- Focusing only on potential profits

### 2. No Risk Management
- Not setting stop losses
- Ignoring position sizing rules
- Chasing losses with higher leverage

### 3. Emotional Trading
- Making decisions based on fear or greed
- Increasing leverage after losses
- Not sticking to the trading plan

### 4. Ignoring Funding Costs
- Not considering funding rate costs
- Holding positions too long
- Not factoring costs into profitability

## Best Practices

### 1. Start Small
- Begin with low leverage (2x-5x)
- Practice with small amounts
- Gradually increase as you gain experience

### 2. Educate Yourself
- Understand how leverage works
- Learn about margin requirements
- Study risk management techniques

### 3. Use Appropriate Tools
- Leverage calculators
- Risk management tools
- Position sizing calculators

### 4. Have a Plan
- Define your risk tolerance
- Set clear entry and exit rules
- Stick to your strategy

## Conclusion

Leverage is a double-edged sword that can amplify both profits and losses. Success with leverage requires:
- Proper education and understanding
- Disciplined risk management
- Appropriate position sizing
- Emotional control

Remember: **Higher leverage does not mean higher profits** - it means higher risk. Always trade responsibly and never risk more than you can afford to lose.
        `
      },
      {
        title: "Margin and Liquidation",
        description: "How margin trading works and how to avoid liquidation",
        readTime: "9 min",
        difficulty: "Intermediate",
        content: `
# Margin and Liquidation

Understanding margin requirements and liquidation mechanics is crucial for successful leverage trading. This guide will help you manage risk and avoid forced position closures.

## What is Margin?

Margin is the collateral required to open and maintain a leveraged position. It's your "skin in the game" that ensures you can cover potential losses.

### Types of Margin

#### 1. Initial Margin
- **Purpose**: Required to open a position
- **Calculation**: Position Size ÷ Leverage Ratio
- **Example**: $10,000 position with 10x leverage = $1,000 initial margin

#### 2. Maintenance Margin
- **Purpose**: Minimum required to keep position open
- **Typically**: 50-80% of initial margin
- **Example**: If initial margin is $1,000, maintenance might be $500

#### 3. Variation Margin
- **Purpose**: Additional margin called when losses occur
- **Frequency**: Calculated in real-time
- **Example**: Mark-to-market losses require additional collateral

## Margin Calculation

### Basic Formula:
\`\`\`
Required Margin = Position Size × Margin Percentage
\`\`\`

### Margin Percentage:
\`\`\`
Margin Percentage = 1 ÷ Leverage Ratio
\`\`\`

### Examples:
- **5x Leverage**: 1 ÷ 5 = 20% margin required
- **10x Leverage**: 1 ÷ 10 = 10% margin required
- **25x Leverage**: 1 ÷ 25 = 4% margin required

## Cross Margin vs Isolated Margin

### Cross Margin
**How it works:**
- All positions share the same margin pool
- Unrealized profits from one position can offset losses in another
- Your entire account balance acts as collateral

**Advantages:**
- Higher liquidation threshold
- Positions can support each other
- Better capital efficiency

**Disadvantages:**
- One bad trade can affect entire account
- Complex risk management
- Potential for larger losses

**Example:**
- Account Balance: $10,000
- Position 1: Long BTC, $5,000 notional, losing $1,000
- Position 2: Short ETH, $3,000 notional, gaining $500
- Net: $9,500 available for margin

### Isolated Margin
**How it works:**
- Each position has its own dedicated margin
- Losses are limited to the margin allocated to that position
- Other positions are not affected

**Advantages:**
- Limited risk per position
- Easier risk management
- Clear position-level risk

**Disadvantages:**
- Lower capital efficiency
- Each position stands alone
- May require more margin overall

**Example:**
- Position 1: $1,000 isolated margin, max loss = $1,000
- Position 2: $500 isolated margin, max loss = $500
- Other positions unaffected

## Liquidation Process

### What is Liquidation?
Liquidation is the automatic closure of a position when losses exceed available margin, protecting the exchange from trader default.

### Liquidation Triggers:
1. **Mark Price**: Position value falls below maintenance margin
2. **Margin Ratio**: Available margin drops below required minimum
3. **Account Balance**: Insufficient funds to cover losses

### Liquidation Price Calculation

#### For Long Positions:
\`\`\`
Liquidation Price = Entry Price × (1 - Initial Margin Rate + Taker Fee Rate)
\`\`\`

#### For Short Positions:
\`\`\`
Liquidation Price = Entry Price × (1 + Initial Margin Rate + Taker Fee Rate)
\`\`\`

### Example Calculations:

**Long Position:**
- Entry Price: $50,000
- Leverage: 10x (10% margin)
- Fee Rate: 0.1%
- Liquidation Price: $50,000 × (1 - 0.10 + 0.001) = $45,050

**Short Position:**
- Entry Price: $50,000
- Leverage: 10x (10% margin)
- Fee Rate: 0.1%
- Liquidation Price: $50,000 × (1 + 0.10 + 0.001) = $55,050

## Margin Health Monitoring

### Margin Ratio
\`\`\`
Margin Ratio = (Account Balance + Unrealized PnL) ÷ Maintenance Margin
\`\`\`

### Health Indicators:
- **> 2.0**: Very healthy
- **1.5 - 2.0**: Healthy
- **1.2 - 1.5**: Caution
- **1.0 - 1.2**: Danger zone
- **< 1.0**: Liquidation risk

### Margin Call Levels:
- **Warning**: Usually at 120-150% of maintenance margin
- **Margin Call**: At 100-110% of maintenance margin
- **Liquidation**: At or below 100% of maintenance margin

## Avoiding Liquidation

### 1. Conservative Leverage
- Use lower leverage ratios
- Start with 2x-5x for beginners
- Gradually increase with experience

### 2. Proper Position Sizing
- Never risk more than 1-2% of account per trade
- Calculate position size based on stop loss
- Account for volatility and spread

### 3. Stop Loss Orders
- **Always set stop losses** before entering
- Place them at logical technical levels
- Use stop-market or stop-limit orders

### 4. Monitor Margin Levels
- Check margin ratio regularly
- Set up alerts for margin calls
- Close positions before liquidation

### 5. Add Margin
- Deposit additional funds when needed
- Reduce position size to lower margin requirements
- Close unprofitable positions

## Liquidation Fees

### Typical Fee Structure:
- **Insurance Fund**: 0.1-0.5% of position value
- **Liquidation Engine**: 0.1-0.3% of position value
- **Total**: Usually 0.2-0.8% of position value

### Fee Calculation:
\`\`\`
Liquidation Fee = Position Value × Liquidation Fee Rate
\`\`\`

### Example:
- Position Value: $10,000
- Liquidation Fee Rate: 0.5%
- Liquidation Fee: $50

## Advanced Margin Strategies

### 1. Partial Liquidation
- Some exchanges liquidate only part of position
- Reduces position size to meet margin requirements
- Allows trader to keep some exposure

### 2. Auto-Deleveraging (ADL)
- System to close profitable positions
- Happens when insurance fund is depleted
- Rare but important to understand

### 3. Margin Trading Techniques
- **Hedging**: Use opposite positions to reduce risk
- **Scaling**: Add to positions at better prices
- **Rebalancing**: Adjust position sizes regularly

## Risk Management Tools

### 1. Position Size Calculator
\`\`\`
Position Size = (Account Balance × Risk %) ÷ (Entry Price - Stop Loss Price)
\`\`\`

### 2. Liquidation Price Calculator
- Use exchange tools or third-party calculators
- Always verify calculations
- Update when adding/removing margin

### 3. Margin Alerts
- Set up notifications for margin levels
- Use mobile apps for real-time monitoring
- Create automatic actions if possible

## Common Margin Mistakes

### 1. Over-leveraging
- Using too much leverage for account size
- Not accounting for volatility
- Focusing only on potential profits

### 2. Ignoring Margin Requirements
- Not monitoring margin levels
- Forgetting about funding costs
- Not planning for adverse moves

### 3. Poor Risk Management
- Not setting stop losses
- Adding to losing positions
- Revenge trading after liquidation

### 4. Misunderstanding Liquidation
- Thinking it won't happen to them
- Not calculating liquidation price
- Ignoring margin call warnings

## Best Practices Summary

1. **Start Conservative**: Use low leverage initially
2. **Monitor Constantly**: Check margin levels regularly
3. **Set Stops**: Always use stop-loss orders
4. **Size Appropriately**: Never risk more than you can afford
5. **Stay Educated**: Understand all mechanics before trading
6. **Plan for Worst Case**: Always have an exit strategy
7. **Use Tools**: Leverage calculators and monitoring tools

## Conclusion

Successful margin trading requires understanding:
- Different types of margin
- Liquidation mechanisms
- Risk management techniques
- Proper position sizing
- Continuous monitoring

Remember: **Liquidation is not a failure of the system - it's a feature designed to protect both trader and exchange.** Your job is to manage risk effectively and avoid reaching that point through proper planning and execution.
        `
      },
      {
        title: "Risk Management Strategies",
        description: "Essential techniques for managing leverage trading risks",
        readTime: "10 min",
        difficulty: "Advanced",
        content: `
# Risk Management Strategies

Risk management is the foundation of successful leverage trading. This comprehensive guide covers essential strategies to protect your capital and maximize long-term profitability.

## The 1% Rule

### Core Principle:
**Never risk more than 1% of your account balance on a single trade.**

### Calculation:
\`\`\`
Maximum Risk per Trade = Account Balance × 0.01
\`\`\`

### Example:
- Account Balance: $10,000
- Maximum Risk: $100 per trade
- Even with 10 consecutive losses, you still have $9,000 left

### Why It Works:
- Prevents catastrophic losses
- Allows for extended losing streaks
- Keeps emotions in check
- Enables long-term compounding

## Position Sizing

### Risk-Based Position Sizing
\`\`\`
Position Size = Risk Amount ÷ (Entry Price - Stop Loss Price)
\`\`\`

### Example:
- Risk Amount: $100
- Entry Price: $50,000
- Stop Loss: $49,000
- Position Size: $100 ÷ ($50,000 - $49,000) = 0.1 BTC

### Leverage Consideration:
- Higher leverage = smaller position size for same risk
- Lower leverage = larger position size for same risk

### Kelly Criterion (Advanced):
\`\`\`
f = (bp - q) ÷ b
\`\`\`
Where:
- f = fraction of capital to risk
- b = odds of winning
- p = probability of winning
- q = probability of losing

## Stop Loss Strategies

### 1. Fixed Percentage Stop Loss
- Set stop loss at fixed percentage below entry
- Example: 2% stop loss on all trades
- Simple but may not account for volatility

### 2. ATR-Based Stop Loss
- Use Average True Range for dynamic stops
- Calculation: Entry Price ± (ATR × Multiplier)
- Accounts for market volatility

### 3. Technical Stop Loss
- Based on support/resistance levels
- Trend lines, moving averages
- More logical but requires analysis

### 4. Trailing Stop Loss
- Moves with profitable positions
- Locks in profits while allowing for further gains
- Can be percentage-based or technical

## Take Profit Strategies

### 1. Fixed Risk-Reward Ratio
- Set profit target based on risk amount
- Common ratios: 1:2, 1:3, 1:4
- Example: Risk $100, target $200 profit

### 2. Partial Profit Taking
- Take 25% at 1:1 ratio
- Take 50% at 1:2 ratio
- Let 25% run with trailing stop

### 3. Technical Profit Targets
- Based on resistance levels
- Fibonacci retracements
- Chart patterns

## Diversification

### 1. Asset Diversification
- Don't put all capital in one cryptocurrency
- Spread across different sectors
- Consider correlation between assets

### 2. Strategy Diversification
- Use different trading strategies
- Combine trend following with mean reversion
- Mix timeframes and approaches

### 3. Time Diversification
- Don't enter all positions at once
- Scale into positions over time
- Use dollar-cost averaging

## Leverage Management

### Progressive Leverage System
- Start with 2x-3x leverage
- Increase gradually with experience
- Reduce leverage during volatile periods

### Leverage Ladder:
1. **Beginner**: 2x-3x leverage
2. **Intermediate**: 3x-5x leverage
3. **Advanced**: 5x-10x leverage
4. **Expert**: 10x+ leverage (with extreme caution)

### Dynamic Leverage Adjustment
- Reduce leverage in volatile markets
- Increase leverage in stable trends
- Monitor VIX or similar volatility indicators

## Emotional Risk Management

### 1. Trading Rules
- Write down your rules before trading
- Follow them religiously
- Review and adjust periodically

### 2. Position Limits
- Maximum number of open positions
- Maximum exposure per asset
- Maximum daily loss limits

### 3. Cooling-Off Periods
- Take breaks after large losses
- Don't trade when emotional
- Use paper trading to regain confidence

### 4. Journaling
- Record all trades with reasons
- Note emotional state during trades
- Identify patterns and mistakes

## Advanced Risk Management

### 1. Hedging Strategies
- Use opposite positions to reduce risk
- Correlation hedging
- Cross-asset hedging

### 2. Options Strategies (Where Available)
- Protective puts for long positions
- Covered calls for income
- Collars for risk management

### 3. Portfolio Heat
- Monitor total portfolio risk
- Limit correlated positions
- Use heat maps for visualization

## Risk Metrics and Monitoring

### 1. Maximum Drawdown
- Largest peak-to-trough decline
- Target: Keep under 10-20%
- Monitor continuously

### 2. Sharpe Ratio
\`\`\`
Sharpe Ratio = (Return - Risk-free Rate) ÷ Standard Deviation
\`\`\`
- Higher is better
- Measures risk-adjusted returns

### 3. Win Rate vs Average Win/Loss
- Win rate alone doesn't matter
- Focus on profit factor
- Aim for positive expectancy

### 4. Risk-Reward Ratio
- Average winning trade ÷ Average losing trade
- Should be > 1.0 for profitability
- Higher ratios allow for lower win rates

## Market Condition Adjustments

### 1. Bull Market Risk Management
- Reduce position sizes (easier to get overconfident)
- Take profits more frequently
- Watch for distribution patterns

### 2. Bear Market Risk Management
- Increase cash position
- Shorter holding periods
- More conservative position sizing

### 3. Sideways Market Risk Management
- Reduce leverage significantly
- Focus on range-bound strategies
- Be more selective with entries

## Technology and Tools

### 1. Risk Management Software
- Position sizing calculators
- Portfolio monitoring tools
- Automated alerts and stops

### 2. Trading Platforms
- Multiple order types
- Risk management features
- Real-time monitoring

### 3. Mobile Apps
- Monitor positions anywhere
- Receive alerts immediately
- Execute emergency trades

## Common Risk Management Mistakes

### 1. Moving Stop Losses
- Moving stops against you
- "It will come back" mentality
- Destroys risk management plan

### 2. Risking Too Much
- Violating position sizing rules
- Emotional trading decisions
- Trying to "get even" quickly

### 3. Ignoring Correlation
- Multiple correlated positions
- Concentration risk
- False diversification

### 4. No Plan B
- Not planning for worst-case scenarios
- No exit strategy
- Hoping instead of managing

## Risk Management Checklist

### Before Each Trade:
- [ ] Position size calculated
- [ ] Stop loss level determined
- [ ] Take profit targets set
- [ ] Risk-reward ratio acceptable
- [ ] Total portfolio risk checked
- [ ] Emotional state assessed

### During the Trade:
- [ ] Monitor margin levels
- [ ] Watch for news events
- [ ] Stick to original plan
- [ ] Adjust stops if needed (only in your favor)

### After the Trade:
- [ ] Record results and lessons
- [ ] Update risk metrics
- [ ] Review what worked/didn't work
- [ ] Plan improvements

## Building Your Risk Management System

### 1. Start Simple
- Begin with basic rules
- Focus on position sizing and stops
- Add complexity gradually

### 2. Backtest Your Rules
- Test on historical data
- Verify effectiveness
- Adjust based on results

### 3. Forward Test
- Use small amounts initially
- Monitor performance closely
- Scale up gradually

### 4. Continuous Improvement
- Regular rule review
- Adapt to changing markets
- Learn from mistakes

## Conclusion

Effective risk management is:
- **Non-negotiable**: Must be followed consistently
- **Personal**: Tailored to your risk tolerance
- **Dynamic**: Adjusted for market conditions
- **Measurable**: Tracked with metrics
- **Disciplined**: Followed regardless of emotions

Remember: **You can't control the market, but you can control your risk.** The goal is not to avoid all losses, but to manage them effectively while maximizing your edge in the market.

The most successful traders are not those who never lose, but those who lose small and win big. Risk management is what makes this possible.
        `
      }
    ]
  }
];

export default function Education() {
  const [selectedCategory, setSelectedCategory] = useState("hyperliquid");
  const [selectedArticle, setSelectedArticle] = useState(null);
  const [searchQuery, setSearchQuery] = useState("");

  const currentCategory = educationCategories.find(cat => cat.id === selectedCategory);
  const filteredArticles = currentCategory?.articles.filter(article =>
    article.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
    article.description.toLowerCase().includes(searchQuery.toLowerCase())
  ) || [];

  const handleArticleClick = (article) => {
    setSelectedArticle(article);
  };

  const handleBackToList = () => {
    setSelectedArticle(null);
  };

  if (selectedArticle) {
    return (
      <div className="min-h-screen bg-gray-50">
        <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          <Button 
            variant="outline" 
            onClick={handleBackToList}
            className="mb-6 flex items-center"
          >
            <ArrowRight className="w-4 h-4 mr-2 transform rotate-180" />
            Back to Articles
          </Button>
          
          <article className="bg-white rounded-lg shadow-sm p-8">
            <div className="mb-6">
              <div className="flex items-center space-x-4 mb-4">
                <Badge variant="outline">{selectedArticle.difficulty}</Badge>
                <div className="flex items-center text-gray-500">
                  <Clock className="w-4 h-4 mr-1" />
                  <span className="text-sm">{selectedArticle.readTime}</span>
                </div>
              </div>
              <h1 className="text-3xl font-bold text-gray-900 mb-2">
                {selectedArticle.title}
              </h1>
              <p className="text-lg text-gray-600">
                {selectedArticle.description}
              </p>
            </div>
            
            <div className="prose max-w-none">
              <div className="whitespace-pre-wrap text-gray-700 leading-relaxed">
                {selectedArticle.content}
              </div>
            </div>
          </article>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <section className="bg-white py-12">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center">
            <h1 className="text-4xl lg:text-5xl font-bold text-gray-900 mb-4">
              Trading Education
            </h1>
            <p className="text-xl text-gray-600 max-w-3xl mx-auto mb-8">
              Master the fundamentals of Hyperliquid, perpetual futures, and leverage trading with our comprehensive guides.
            </p>
            
            {/* Search Bar */}
            <div className="max-w-md mx-auto relative">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
              <Input
                placeholder="Search articles..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-10"
              />
            </div>
          </div>
        </div>
      </section>

      {/* Category Tabs */}
      <section className="bg-white border-b">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex space-x-8 overflow-x-auto">
            {educationCategories.map((category) => (
              <button
                key={category.id}
                onClick={() => setSelectedCategory(category.id)}
                className={`flex items-center space-x-2 py-4 px-2 border-b-2 font-medium text-sm whitespace-nowrap ${
                  selectedCategory === category.id
                    ? 'border-liquid-green text-liquid-green'
                    : 'border-transparent text-gray-500 hover:text-gray-700'
                }`}
              >
                {category.icon}
                <span>{category.title}</span>
              </button>
            ))}
          </div>
        </div>
      </section>

      {/* Articles Grid */}
      <section className="py-12">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900 mb-2">
              {currentCategory?.title}
            </h2>
            <p className="text-gray-600">
              {currentCategory?.description}
            </p>
          </div>
          
          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
            {filteredArticles.map((article, index) => (
              <Card 
                key={index} 
                className="cursor-pointer hover:shadow-lg transition-shadow"
                onClick={() => handleArticleClick(article)}
              >
                <CardHeader>
                  <div className="flex items-center justify-between mb-2">
                    <Badge className={currentCategory?.color}>
                      {article.difficulty}
                    </Badge>
                    <div className="flex items-center text-gray-500">
                      <Clock className="w-4 h-4 mr-1" />
                      <span className="text-sm">{article.readTime}</span>
                    </div>
                  </div>
                  <CardTitle className="text-lg">{article.title}</CardTitle>
                </CardHeader>
                <CardContent>
                  <CardDescription className="text-gray-600">
                    {article.description}
                  </CardDescription>
                  <div className="mt-4 flex items-center text-liquid-green">
                    <span className="text-sm font-medium">Read Article</span>
                    <ArrowRight className="w-4 h-4 ml-1" />
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
          
          {filteredArticles.length === 0 && (
            <div className="text-center py-12">
              <BookOpen className="w-12 h-12 text-gray-400 mx-auto mb-4" />
              <p className="text-gray-600">No articles found matching your search.</p>
            </div>
          )}
        </div>
      </section>

      {/* CTA Section */}
      <section className="py-16 gradient-bg text-white">
        <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
          <h2 className="text-3xl lg:text-4xl font-bold mb-4">
            Ready to Start Trading?
          </h2>
          <p className="text-xl mb-8 text-green-100">
            Apply your knowledge and start building your trading platform
          </p>
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Link href="/builder">
              <button 
                className="px-8 py-4 rounded-lg font-semibold transition-colors text-lg shadow-lg"
                style={{ 
                  backgroundColor: 'white', 
                  color: '#00D084', 
                  border: '2px solid #00D084' 
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.backgroundColor = '#00D084';
                  e.currentTarget.style.color = 'white';
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.backgroundColor = 'white';
                  e.currentTarget.style.color = '#00D084';
                }}
              >
                Start Building
              </button>
            </Link>
            <Link href="/templates">
              <button 
                className="px-8 py-4 rounded-lg font-semibold transition-colors text-lg shadow-lg"
                style={{ 
                  backgroundColor: 'transparent', 
                  color: 'white', 
                  border: '2px solid white' 
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.backgroundColor = 'white';
                  e.currentTarget.style.color = '#00D084';
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.backgroundColor = 'transparent';
                  e.currentTarget.style.color = 'white';
                }}
              >
                View Templates
              </button>
            </Link>
          </div>
        </div>
      </section>
    </div>
  );
}
```

---

## File: client/src/pages/enterprise.tsx

```tsx
import { Link } from "wouter";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Building2, Shield, Users, Palette, HeadphonesIcon, Zap, ChevronRight, Code, Server, Lock, Phone } from "lucide-react";

export default function Enterprise() {
  return (
    <div className="min-h-screen bg-gray-50">
      {/* Hero Section */}
      <section className="bg-gradient-to-br from-gray-900 to-gray-800 text-white py-20 md:py-32">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center max-w-4xl mx-auto">
            <h1 className="text-4xl md:text-6xl font-bold mb-6">
              Enterprise Solutions for Financial Institutions
            </h1>
            <p className="text-xl md:text-2xl text-gray-300 mb-8">
              White-glove service for hedge funds, prop trading firms, and financial institutions building on Hyperliquid
            </p>
            <div className="flex flex-col sm:flex-row gap-4 justify-center">
              <Link href="/contact">
                <Button size="lg" className="bg-liquid-green text-black hover:bg-liquid-accent transition-colors text-lg px-8">
                  Schedule Consultation
                </Button>
              </Link>
              <Link href="/pricing">
                <Button size="lg" variant="outline" className="bg-gray-800 text-white border-white hover:bg-white hover:text-gray-900 transition-colors text-lg px-8">
                  View Enterprise Pricing
                </Button>
              </Link>
            </div>
          </div>
        </div>
      </section>

      {/* Key Benefits */}
      <section className="py-20">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-16">
            <h2 className="text-3xl md:text-4xl font-bold text-gray-900 mb-4">
              Built for Scale, Designed for Success
            </h2>
            <p className="text-xl text-gray-600 max-w-3xl mx-auto">
              Our enterprise solution provides everything your institution needs to launch and scale a professional trading platform
            </p>
          </div>

          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-8">
            <Card className="border-2 hover:border-liquid-green transition-colors">
              <CardHeader>
                <Shield className="w-12 h-12 text-liquid-green mb-4" />
                <CardTitle className="text-xl">Bank-Grade Security</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-gray-600">
                  Enterprise-grade infrastructure with SOC 2 Type II compliance, advanced DDoS protection, and complete audit trails
                </p>
              </CardContent>
            </Card>

            <Card className="border-2 hover:border-liquid-green transition-colors">
              <CardHeader>
                <Palette className="w-12 h-12 text-liquid-green mb-4" />
                <CardTitle className="text-xl">Custom Branding</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-gray-600">
                  Complete white-label solution with custom domains, advanced theming, and brand-specific UI/UX design
                </p>
              </CardContent>
            </Card>

            <Card className="border-2 hover:border-liquid-green transition-colors">
              <CardHeader>
                <HeadphonesIcon className="w-12 h-12 text-liquid-green mb-4" />
                <CardTitle className="text-xl">Dedicated Support</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-gray-600">
                  24/7 priority support with dedicated account manager and direct access to our engineering team
                </p>
              </CardContent>
            </Card>

            <Card className="border-2 hover:border-liquid-green transition-colors">
              <CardHeader>
                <Code className="w-12 h-12 text-liquid-green mb-4" />
                <CardTitle className="text-xl">Custom Features</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-gray-600">
                  Bespoke functionality including advanced order types, risk management tools, and proprietary trading algorithms
                </p>
              </CardContent>
            </Card>

            <Card className="border-2 hover:border-liquid-green transition-colors">
              <CardHeader>
                <Server className="w-12 h-12 text-liquid-green mb-4" />
                <CardTitle className="text-xl">API Integration</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-gray-600">
                  Seamless integration with your existing systems, including risk management, compliance, and reporting tools
                </p>
              </CardContent>
            </Card>

            <Card className="border-2 hover:border-liquid-green transition-colors">
              <CardHeader>
                <Lock className="w-12 h-12 text-liquid-green mb-4" />
                <CardTitle className="text-xl">Compliance Ready</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-gray-600">
                  Built-in KYC/AML compliance, transaction monitoring, and regulatory reporting capabilities
                </p>
              </CardContent>
            </Card>
          </div>
        </div>
      </section>

      {/* Enterprise Features */}
      <section className="py-20 bg-white">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-16">
            <h2 className="text-3xl md:text-4xl font-bold text-gray-900 mb-4">
              Enterprise-Exclusive Features
            </h2>
            <p className="text-xl text-gray-600 max-w-3xl mx-auto">
              Advanced capabilities designed for institutional trading needs
            </p>
          </div>

          <div className="space-y-12">
            <div className="flex flex-col lg:flex-row items-center gap-8">
              <div className="flex-1">
                <h3 className="text-2xl font-bold text-gray-900 mb-4">
                  Multi-Account Management
                </h3>
                <p className="text-gray-600 mb-4">
                  Manage multiple trading accounts with role-based access control, sub-account hierarchies, and consolidated reporting.
                </p>
                <ul className="space-y-2">
                  <li className="flex items-center gap-2">
                    <ChevronRight className="w-5 h-5 text-liquid-green" />
                    <span>Unlimited sub-accounts</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <ChevronRight className="w-5 h-5 text-liquid-green" />
                    <span>Granular permission controls</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <ChevronRight className="w-5 h-5 text-liquid-green" />
                    <span>Cross-account position monitoring</span>
                  </li>
                </ul>
              </div>
              <div className="flex-1 bg-gray-100 p-8 rounded-lg">
                <div className="aspect-video bg-gray-200 rounded flex items-center justify-center">
                  <Users className="w-24 h-24 text-gray-400" />
                </div>
              </div>
            </div>

            <div className="flex flex-col lg:flex-row-reverse items-center gap-8">
              <div className="flex-1">
                <h3 className="text-2xl font-bold text-gray-900 mb-4">
                  Advanced Risk Management
                </h3>
                <p className="text-gray-600 mb-4">
                  Institutional-grade risk controls with real-time monitoring, automated circuit breakers, and customizable limits.
                </p>
                <ul className="space-y-2">
                  <li className="flex items-center gap-2">
                    <ChevronRight className="w-5 h-5 text-liquid-green" />
                    <span>Real-time P&L tracking</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <ChevronRight className="w-5 h-5 text-liquid-green" />
                    <span>Automated position limits</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <ChevronRight className="w-5 h-5 text-liquid-green" />
                    <span>Custom risk metrics</span>
                  </li>
                </ul>
              </div>
              <div className="flex-1 bg-gray-100 p-8 rounded-lg">
                <div className="aspect-video bg-gray-200 rounded flex items-center justify-center">
                  <Shield className="w-24 h-24 text-gray-400" />
                </div>
              </div>
            </div>

            <div className="flex flex-col lg:flex-row items-center gap-8">
              <div className="flex-1">
                <h3 className="text-2xl font-bold text-gray-900 mb-4">
                  Priority Infrastructure
                </h3>
                <p className="text-gray-600 mb-4">
                  Dedicated servers with guaranteed uptime, ultra-low latency connections, and priority order routing.
                </p>
                <ul className="space-y-2">
                  <li className="flex items-center gap-2">
                    <ChevronRight className="w-5 h-5 text-liquid-green" />
                    <span>99.99% uptime SLA</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <ChevronRight className="w-5 h-5 text-liquid-green" />
                    <span>Sub-millisecond latency</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <ChevronRight className="w-5 h-5 text-liquid-green" />
                    <span>Dedicated support team</span>
                  </li>
                </ul>
              </div>
              <div className="flex-1 bg-gray-100 p-8 rounded-lg">
                <div className="aspect-video bg-gray-200 rounded flex items-center justify-center">
                  <Zap className="w-24 h-24 text-gray-400" />
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* Client Testimonials */}
      <section className="py-20">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-16">
            <h2 className="text-3xl md:text-4xl font-bold text-gray-900 mb-4">
              Trusted by Leading Institutions
            </h2>
            <p className="text-xl text-gray-600 max-w-3xl mx-auto">
              See why top trading firms choose LiquidLab Enterprise
            </p>
          </div>

          <div className="grid md:grid-cols-2 gap-8">
            <Card className="border-2">
              <CardHeader>
                <div className="flex items-center gap-4 mb-4">
                  <Building2 className="w-12 h-12 text-liquid-green" />
                  <div>
                    <CardTitle>Apex Capital Management</CardTitle>
                    <CardDescription>Hedge Fund - $2.5B AUM</CardDescription>
                  </div>
                </div>
              </CardHeader>
              <CardContent>
                <p className="text-gray-600 italic">
                  "LiquidLab's enterprise solution transformed our trading operations. The custom risk management tools and dedicated support have been invaluable. We've seen a 40% increase in trading efficiency since implementation."
                </p>
                <p className="mt-4 font-semibold">- James Chen, CTO</p>
              </CardContent>
            </Card>

            <Card className="border-2">
              <CardHeader>
                <div className="flex items-center gap-4 mb-4">
                  <Building2 className="w-12 h-12 text-liquid-green" />
                  <div>
                    <CardTitle>Quantum Trading Partners</CardTitle>
                    <CardDescription>Prop Trading Firm</CardDescription>
                  </div>
                </div>
              </CardHeader>
              <CardContent>
                <p className="text-gray-600 italic">
                  "The white-glove service exceeded our expectations. From custom branding to API integration with our existing systems, everything was seamless. Our traders love the platform."
                </p>
                <p className="mt-4 font-semibold">- Sarah Martinez, Head of Trading</p>
              </CardContent>
            </Card>
          </div>
        </div>
      </section>

      {/* Onboarding Process */}
      <section className="py-20 bg-white">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-16">
            <h2 className="text-3xl md:text-4xl font-bold text-gray-900 mb-4">
              Simple Onboarding Process
            </h2>
            <p className="text-xl text-gray-600 max-w-3xl mx-auto">
              From consultation to launch in just 4 weeks
            </p>
          </div>

          <div className="grid md:grid-cols-4 gap-8">
            <div className="text-center">
              <div className="w-16 h-16 bg-liquid-green text-white rounded-full flex items-center justify-center mx-auto mb-4 text-2xl font-bold">
                1
              </div>
              <h3 className="font-bold text-lg mb-2">Discovery Call</h3>
              <p className="text-gray-600">
                Understand your needs and trading requirements
              </p>
            </div>

            <div className="text-center">
              <div className="w-16 h-16 bg-liquid-green text-white rounded-full flex items-center justify-center mx-auto mb-4 text-2xl font-bold">
                2
              </div>
              <h3 className="font-bold text-lg mb-2">Custom Design</h3>
              <p className="text-gray-600">
                Create your branded platform with custom features
              </p>
            </div>

            <div className="text-center">
              <div className="w-16 h-16 bg-liquid-green text-white rounded-full flex items-center justify-center mx-auto mb-4 text-2xl font-bold">
                3
              </div>
              <h3 className="font-bold text-lg mb-2">Integration</h3>
              <p className="text-gray-600">
                Connect with your systems and test thoroughly
              </p>
            </div>

            <div className="text-center">
              <div className="w-16 h-16 bg-liquid-green text-white rounded-full flex items-center justify-center mx-auto mb-4 text-2xl font-bold">
                4
              </div>
              <h3 className="font-bold text-lg mb-2">Launch & Scale</h3>
              <p className="text-gray-600">
                Go live with ongoing support and optimization
              </p>
            </div>
          </div>
        </div>
      </section>

      {/* CTA Section */}
      <section className="py-20 bg-gradient-to-br from-gray-900 to-gray-800 text-white">
        <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
          <h2 className="text-3xl md:text-4xl font-bold mb-6">
            Ready to Transform Your Trading Infrastructure?
          </h2>
          <p className="text-xl text-gray-300 mb-8">
            Join leading institutions already building on LiquidLab Enterprise
          </p>
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Link href="/contact">
              <Button size="lg" className="bg-liquid-green text-black hover:bg-liquid-accent transition-colors text-lg px-8">
                <Phone className="w-5 h-5 mr-2" />
                Schedule Enterprise Demo
              </Button>
            </Link>
            <Button 
              size="lg" 
              variant="outline" 
              className="bg-gray-800 text-white border-white hover:bg-white hover:text-gray-900 transition-colors text-lg px-8"
              onClick={() => window.location.href = 'mailto:enterprise@liquidlab.trade'}
            >
              Contact Sales Team
            </Button>
          </div>
          <p className="mt-8 text-gray-400">
            Or call us directly at <span className="text-white font-semibold">+1 (888) 555-0123</span>
          </p>
        </div>
      </section>
    </div>
  );
}
```

---

## File: client/src/pages/example.tsx

```tsx
import { useState, useEffect, useMemo } from "react";
import { Link } from "wouter";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { ArrowLeft, TrendingUp, TrendingDown, DollarSign, BarChart3, Volume2, Activity, X, AlertCircle } from "lucide-react";
import liquidLabLogo from "@assets/Trade (6)_1752434284086.png";
import { TrustIndicators } from "@/components/TrustIndicators";
import { PlatformVerificationBadge } from "@/components/PlatformVerificationBadge";
import { PrivyProvider } from "@/components/PrivyProvider";
import { WalletConnect } from "@/components/WalletConnect";
import { HyperliquidTradingInterface } from "@/components/trading/HyperliquidTradingInterface";

import { MoonPayButton } from "@/components/MoonPayButton";
import { PWAInstaller } from "@/components/PWAInstaller";
import { validateImageUrl } from "@/lib/urlValidator";
import { usePrivy } from "@privy-io/react-auth";

interface MarketData {
  price: string;
  change24h: string;
  high24h: string;
  low24h: string;
  volume24h: string;
}

export default function ExampleTradingPage() {
  const [selectedPair, setSelectedPair] = useState({ symbol: "BTC", display: "BTC/USD" });
  const [selectedMarket, setSelectedMarket] = useState("BTC");
  const [side, setSide] = useState<"buy" | "sell">("buy");
  const [orderType, setOrderType] = useState("limit");
  const [timeInterval, setTimeInterval] = useState("15m");
  const [isLoading, setIsLoading] = useState(true);

  const [maxLeverage, setMaxLeverage] = useState(100); // Default to 100x
  const [marketStats, setMarketStats] = useState<MarketData>({
    price: "0.00",
    change24h: "+0.00%",
    high24h: "0.00",
    low24h: "0.00",
    volume24h: "0.00"
  });
  const [allMarketData, setAllMarketData] = useState<{[key: string]: any}>({});
  const [platformData, setPlatformData] = useState<any>(null);
  const [verificationCode, setVerificationCode] = useState<string>("");
  const [hyperliquidPrices, setHyperliquidPrices] = useState<{[key: string]: string}>({});
  const [platformError, setPlatformError] = useState<string | null>(null);
  const [marketError, setMarketError] = useState<string | null>(null);
  const [marketDataError, setMarketDataError] = useState<string | null>(null);
  const [retryCount, setRetryCount] = useState(0);

  // Check for preview mode parameters
  const urlParams = new URLSearchParams(window.location.search);
  const isPreview = urlParams.get('preview') === 'true';
  const previewName = urlParams.get('name');
  const previewLogo = urlParams.get('logo');

  // Helper function for exponential backoff
  const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));
  
  // Retry function with exponential backoff
  const retryFetch = async (fn: () => Promise<Response>, maxRetries = 3, retryDelay = 1000) => {
    for (let i = 0; i <= maxRetries; i++) {
      try {
        const response = await fn();
        if (response.ok || response.status < 500) {
          return response; // Success or client error (don't retry client errors)
        }
        if (i < maxRetries) {
          console.log(`Retry ${i + 1}/${maxRetries} after ${retryDelay}ms`);
          await delay(retryDelay);
          retryDelay *= 2; // Exponential backoff
        }
      } catch (error) {
        if (i === maxRetries) throw error;
        await delay(retryDelay);
        retryDelay *= 2;
      }
    }
    throw new Error('Max retries exceeded');
  };

  // Fetch platform data and verification code
  useEffect(() => {
    const fetchPlatformData = async () => {
      try {
        setPlatformError(null);
        
        // If in preview mode, use preview data
        if (isPreview && (previewName || previewLogo)) {
          setPlatformData({
            name: previewName || 'Preview Platform',
            logoUrl: validateImageUrl(previewLogo) || null
          });
          return;
        }

        // For centralized SaaS, fetch platform based on current domain
        const response = await retryFetch(() => fetch('/api/platform/current'));
        if (response.ok) {
          const platform = await response.json();
          
          if (platform) {
            setPlatformData(platform);
            
            // Fetch verification code for this platform with retry
            console.log('Fetching verification code for platform:', platform.id);
            const verifyResponse = await retryFetch(() => 
              fetch(`/api/platforms/${platform.id}/verification-code`)
            );
            if (verifyResponse.ok) {
              const verifyData = await verifyResponse.json();
              console.log('Verification response:', verifyData);
              if (verifyData.code) {
                console.log('Setting verification code:', verifyData.code);
                setVerificationCode(verifyData.code);
              } else {
                console.warn('No verification code in response');
              }
            } else {
              console.error('Failed to fetch verification code:', verifyResponse.status);
              setPlatformError('Unable to fetch verification code');
            }
          }
        } else {
          setPlatformError('Unable to load platform data');
        }
      } catch (error) {
        console.error("Error fetching platform data:", error);
        setPlatformError('Failed to connect to server. Please refresh the page.');
      }
    };
    
    fetchPlatformData();
  }, [retryCount]);

  // Cache for market data to reduce API calls
  const marketDataCache = useMemo(() => {
    const cache = new Map<string, { data: any; timestamp: number }>();
    const CACHE_DURATION = 5000; // 5 seconds cache
    
    return {
      get: (key: string) => {
        const cached = cache.get(key);
        if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
          return cached.data;
        }
        return null;
      },
      set: (key: string, data: any) => {
        cache.set(key, { data, timestamp: Date.now() });
      }
    };
  }, []);

  // Fetch Hyperliquid market data
  useEffect(() => {
    const fetchHyperliquidData = async () => {
      try {
        setMarketError(null);
        
        // Check cache first
        const cachedData = marketDataCache.get('market-data');
        if (cachedData) {
          setHyperliquidPrices(cachedData);
          updateMarketStats(cachedData[selectedMarket]);
          setIsLoading(false);
          return;
        }
        
        // Fetch current market prices with retry
        const priceResponse = await retryFetch(() => fetch('/api/hyperliquid/market-data'), 2, 2000);
        if (!priceResponse.ok) {
          throw new Error(`HTTP error! status: ${priceResponse.status}`);
        }
        
        const priceData = await priceResponse.json();
        marketDataCache.set('market-data', priceData);
        setHyperliquidPrices(priceData);
        
        // Update stats for selected market
        updateMarketStats(priceData[selectedMarket]);
        setIsLoading(false);
      } catch (error) {
        console.error("Error fetching Hyperliquid data:", error);
        setMarketError('Unable to fetch market data. Will retry...');
        setIsLoading(false);
        
        // Retry after 5 seconds if there's an error
        setTimeout(() => {
          setRetryCount(prev => prev + 1);
        }, 5000);
      }
    };

    const updateMarketStats = (currentPrice: string | undefined) => {
      if (currentPrice) {
        const price = parseFloat(currentPrice);
        setMarketStats({
          price: price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }),
          change24h: "+0.00%", // Hyperliquid doesn't provide 24h change in this endpoint
          high24h: (price * 1.02).toFixed(2),
          low24h: (price * 0.98).toFixed(2),
          volume24h: "---"
        });
      }
    };

    fetchHyperliquidData();
    
    // Reduce frequency to 5 seconds to avoid rate limiting
    const interval = setInterval(fetchHyperliquidData, 5000);
    return () => clearInterval(interval);
  }, [selectedMarket, retryCount]);

  // Format number with commas
  const formatPrice = (price: number) => {
    return new Intl.NumberFormat('en-US', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(price);
  };
  
  // Handle retry
  const handleRetry = () => {
    setRetryCount(prev => prev + 1);
  };



  return (
    <PrivyProvider>
      <TradingPlatform 
        platformData={platformData}
        selectedMarket={selectedMarket}
        setSelectedMarket={setSelectedMarket}
        marketStats={marketStats}
        marketDataError={marketDataError}
        handleRetry={handleRetry}
        retryCount={retryCount}
        verificationCode={verificationCode}
      />
    </PrivyProvider>
  );
}

function TradingPlatform({ 
  platformData, 
  selectedMarket, 
  setSelectedMarket, 
  marketStats, 
  marketDataError, 
  handleRetry, 
  retryCount,
  verificationCode 
}: any) {
  const { ready } = usePrivy();
  
  if (!ready) {
    return (
      <div className="min-h-screen bg-[#0a0a0a] flex items-center justify-center">
        <div className="text-gray-400">Initializing wallet connection...</div>
      </div>
    );
  }
  
  return (
    <div className="min-h-screen bg-[#0a0a0a] text-gray-100 flex flex-col">
      {/* Header */}
      <header className="bg-[#0f0f0f] border-b border-gray-800">
        <div className="flex items-center justify-between h-24 sm:h-28 lg:h-24 px-2 sm:px-4 py-1 lg:py-0">
          <div className="flex items-center space-x-1 sm:space-x-2 lg:space-x-6">
            <Link href="/" className="hidden lg:block">
              <Button 
                variant="outline" 
                size="sm" 
                className="bg-transparent border-gray-700 hover:bg-gray-800 text-sm flex items-center gap-2"
              >
                <ArrowLeft className="w-4 h-4" />
                Back to LiquidLab
              </Button>
            </Link>
            <Link href="/" className="lg:hidden">
              <Button 
                variant="outline" 
                size="sm" 
                className="bg-transparent border-gray-700 hover:bg-gray-800 p-2"
              >
                <ArrowLeft className="w-4 h-4" />
              </Button>
            </Link>
            {(() => {
              const validatedLogoUrl = validateImageUrl(platformData?.logoUrl);
              if (validatedLogoUrl) {
                return (
                  <img 
                    src={validatedLogoUrl} 
                    alt={platformData.name || "Trading Platform"} 
                    className="h-20 sm:h-24 lg:h-36 w-auto"
                  />
                );
              }
              return (
                <img 
                  src={liquidLabLogo} 
                  alt="LiquidLab" 
                  className="h-20 sm:h-24 lg:h-36 w-auto"
                />
              );
            })()}
          </div>
          <div className="flex items-center space-x-1 sm:space-x-2 lg:space-x-4">
            <div className="hidden sm:block">
              <PlatformVerificationBadge
                platformId={platformData?.id || 1}
                platformName={platformData?.name || "Example Trading Platform"}
                isVerified={true}
                compactMode={true}
                verificationCode={verificationCode}
              />
            </div>
            <WalletConnect />
            <MoonPayButton 
              platformId={platformData?.id}
              className="h-7 sm:h-8 lg:h-9 text-xs sm:text-sm px-2 sm:px-4"
            />
          </div>
        </div>
      </header>

      {/* Trust Indicators */}
      <TrustIndicators 
        platformName={platformData?.name || "Example Trading Platform"}
        platformId={platformData?.id || 1}
        builderCode={platformData?.config?.builderCode || "LIQUIDLAB2025"}
        verificationCode={verificationCode || undefined}
      />

      {/* Main Trading Area */}
      <div className="flex-1 overflow-hidden">
        <HyperliquidTradingInterface />
      </div>
      
      {/* PWA Installer */}
      <PWAInstaller platformName={platformData?.name || "Trading Platform"} />
    </div>
  );
}
```

---

## File: client/src/pages/home.tsx

```tsx
import { Link } from "wouter";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { RevenueCalculator } from "@/components/RevenueCalculator";

import { 
  TrendingUp, 
  Users, 
  Zap, 
  Globe,
  BarChart3,
  Smartphone,
  Rocket,
  DollarSign,
  CheckCircle,
  Plug,
  Wallet,
  Check,
  CreditCard,
  Shield,
  Lock,
  Key,
  AlertTriangle,
  Activity,
  FileText,
  Eye,
  Code
} from "lucide-react";

export default function Home() {
  return (
    <div className="min-h-screen">
      {/* Hero Section */}
      <section className="gradient-bg text-white py-16 lg:py-24">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="grid lg:grid-cols-2 gap-12 items-center">
            <div>
              <h1 className="text-4xl lg:text-6xl font-bold mb-6 leading-tight">
                Build Your Own
                <span className="block">Trading Platform</span>
              </h1>
              <p className="text-xl lg:text-2xl mb-8 text-green-100">
                Create professional trading interfaces on Hyperliquid with drag-and-drop simplicity. Generate revenue through builder codes while providing seamless trading experiences.
              </p>
              <div className="flex flex-col sm:flex-row gap-4">
                <Link href="/builder">
                  <button 
                    className="px-8 py-4 rounded-lg font-semibold transition-colors text-lg shadow-lg"
                    style={{ 
                      backgroundColor: 'white', 
                      color: '#00D084', 
                      border: '2px solid #00D084' 
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.backgroundColor = '#00D084';
                      e.currentTarget.style.color = 'white';
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.backgroundColor = 'white';
                      e.currentTarget.style.color = '#00D084';
                    }}
                  >
                    Start Building Free
                  </button>
                </Link>
                <Link href="/templates">
                  <button 
                    className="px-8 py-4 rounded-lg font-semibold transition-colors text-lg shadow-lg"
                    style={{ 
                      backgroundColor: 'white', 
                      color: '#00D084', 
                      border: '2px solid #00D084' 
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.backgroundColor = '#00D084';
                      e.currentTarget.style.color = 'white';
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.backgroundColor = 'white';
                      e.currentTarget.style.color = '#00D084';
                    }}
                  >
                    View Templates
                  </button>
                </Link>
              </div>
              <div className="mt-8 flex flex-wrap items-center gap-6 text-sm text-green-100">
                <div className="flex items-center">
                  <CheckCircle className="w-4 h-4 mr-2" />
                  <span>No coding required</span>
                </div>
                <div className="flex items-center">
                  <CheckCircle className="w-4 h-4 mr-2" />
                  <span>Hyperliquid integration</span>
                </div>
                <div className="flex items-center">
                  <CheckCircle className="w-4 h-4 mr-2" />
                  <span>Revenue sharing</span>
                </div>
                <div className="flex items-center">
                  <CheckCircle className="w-4 h-4 mr-2" />
                  <span className="font-semibold">NEW: Polymarket Premium</span>
                </div>
              </div>
            </div>
            <div className="lg:block hidden">
              {/* Trading Platform Preview */}
              <div className="relative">
                <div className="absolute inset-0 bg-gradient-to-r from-liquid-green to-liquid-accent rounded-xl blur-xl opacity-20"></div>
                <Card className="transform rotate-3 hover:rotate-0 transition-transform shadow-2xl relative backdrop-blur-sm bg-white/90">
                  <CardContent className="p-6">
                    <div className="bg-gray-900 rounded-lg p-4 mb-4">
                      <div className="flex items-center justify-between mb-3">
                        <h3 className="text-white font-semibold">BTC/USD</h3>
                        <div className="text-green-400 font-mono">$67,845.23</div>
                      </div>
                      <div className="h-32 bg-gradient-to-r from-green-400 to-blue-400 rounded relative overflow-hidden">
                        {/* Price Chart Lines */}
                        <div className="absolute inset-0 p-2">
                          <svg width="100%" height="100%" viewBox="0 0 200 100" className="opacity-70">
                            <polyline
                              points="10,80 30,70 50,85 70,60 90,65 110,45 130,40 150,55 170,35 190,25"
                              fill="none"
                              stroke="white"
                              strokeWidth="2"
                              className="animate-pulse"
                            />
                            <polyline
                              points="10,90 30,85 50,75 70,80 90,70 110,65 130,60 150,50 170,45 190,40"
                              fill="none"
                              stroke="rgba(255,255,255,0.5)"
                              strokeWidth="1"
                            />
                            {/* Price points */}
                            <circle cx="190" cy="25" r="3" fill="white" className="animate-pulse" />
                            <circle cx="170" cy="35" r="2" fill="rgba(255,255,255,0.8)" />
                            <circle cx="150" cy="55" r="2" fill="rgba(255,255,255,0.8)" />
                          </svg>
                        </div>
                        {/* Price trend indicator */}
                        <div className="absolute top-2 right-2 text-white text-xs font-mono">
                          +2.34%
                        </div>
                      </div>
                    </div>
                    <div className="grid grid-cols-2 gap-4">
                      <Button className="bg-green-500 text-white hover:bg-green-600">Buy</Button>
                      <Button className="bg-red-500 text-white hover:bg-red-600">Sell</Button>
                    </div>
                  </CardContent>
                </Card>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* Privy Wallet Infrastructure Section */}
      <section className="py-12 bg-gradient-to-r from-purple-50 to-blue-50">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="bg-white rounded-2xl shadow-xl p-8 md:p-12 border border-purple-100">
            <div className="flex flex-col md:flex-row items-center gap-8">
              <div className="flex-1">
                <Badge className="mb-4 bg-purple-100 text-purple-700">Enterprise Infrastructure</Badge>
                <h2 className="text-3xl font-bold text-gray-900 mb-4">
                  Privy Wallet Infrastructure Included
                </h2>
                <p className="text-lg text-gray-600 mb-6">
                  Every platform you build comes with enterprise-grade wallet infrastructure powered by Privy - at absolutely no additional cost.
                </p>
                <div className="space-y-3">
                  <div className="flex items-center gap-3">
                    <Check className="w-5 h-5 text-green-500 flex-shrink-0" />
                    <span className="text-gray-700">Social logins (Google, Twitter, Discord)</span>
                  </div>
                  <div className="flex items-center gap-3">
                    <Check className="w-5 h-5 text-green-500 flex-shrink-0" />
                    <span className="text-gray-700">Email & SMS authentication</span>
                  </div>
                  <div className="flex items-center gap-3">
                    <Check className="w-5 h-5 text-green-500 flex-shrink-0" />
                    <span className="text-gray-700">Built-in wallet creation for new users</span>
                  </div>
                  <div className="flex items-center gap-3">
                    <Check className="w-5 h-5 text-green-500 flex-shrink-0" />
                    <span className="text-gray-700">Support for 10+ external wallets</span>
                  </div>
                </div>
                <div className="mt-6 p-4 bg-purple-50 rounded-lg">
                  <p className="text-sm text-purple-700">
                    <strong>$0 extra cost</strong> - Included free with every LiquidLab platform
                  </p>
                </div>
              </div>
              <div className="flex-shrink-0">
                <div className="w-64 h-64 bg-gradient-to-br from-purple-400 to-blue-400 rounded-2xl shadow-2xl flex items-center justify-center">
                  <Wallet className="w-24 h-24 text-white" />
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* MoonPay Integration Section */}
      <section className="py-12 bg-gradient-to-r from-blue-50 to-indigo-50">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="bg-white rounded-2xl shadow-xl p-8 md:p-12 border border-blue-100">
            <div className="flex flex-col md:flex-row items-center gap-8">
              <div className="flex-shrink-0 order-2 md:order-1">
                <div className="w-64 h-64 bg-gradient-to-br from-blue-400 to-indigo-400 rounded-2xl shadow-2xl flex items-center justify-center">
                  <CreditCard className="w-24 h-24 text-white" />
                </div>
              </div>
              <div className="flex-1 order-1 md:order-2">
                <Badge className="mb-4 bg-blue-100 text-blue-700">Fiat On-Ramp</Badge>
                <h2 className="text-3xl font-bold text-gray-900 mb-4">
                  MoonPay Integration Built-In
                </h2>
                <p className="text-lg text-gray-600 mb-6">
                  Every trading platform includes MoonPay's fiat-to-crypto gateway, making it easy for users to fund their accounts with traditional payment methods.
                </p>
                <div className="space-y-3">
                  <div className="flex items-center gap-3">
                    <Check className="w-5 h-5 text-green-500 flex-shrink-0" />
                    <span className="text-gray-700">Credit card & bank transfer support</span>
                  </div>
                  <div className="flex items-center gap-3">
                    <Check className="w-5 h-5 text-green-500 flex-shrink-0" />
                    <span className="text-gray-700">170+ countries supported</span>
                  </div>
                  <div className="flex items-center gap-3">
                    <Check className="w-5 h-5 text-green-500 flex-shrink-0" />
                    <span className="text-gray-700">Built-in KYC/AML compliance</span>
                  </div>
                  <div className="flex items-center gap-3">
                    <Check className="w-5 h-5 text-green-500 flex-shrink-0" />
                    <span className="text-gray-700">Earn affiliate revenue on transactions</span>
                  </div>
                </div>
                <div className="mt-6 p-4 bg-blue-50 rounded-lg">
                  <p className="text-sm text-blue-700">
                    <strong>Automatically integrated</strong> - No setup required, works out of the box
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* Bank-Level Security Section */}
      <section className="py-16 bg-gradient-to-r from-gray-900 to-gray-800">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-12">
            <Badge className="mb-4 bg-green-500 text-white">Enterprise Security</Badge>
            <h2 className="text-3xl lg:text-4xl font-bold text-white mb-4">
              Bank-Level Security Built Into Every Platform
            </h2>
            <p className="text-xl text-gray-300 max-w-3xl mx-auto">
              Your traders' security is our top priority. Every LiquidLab platform is deployed with enterprise-grade security features that protect both platform owners and traders.
            </p>
            <div className="mt-6 bg-green-500/10 border border-green-500 rounded-lg p-4 max-w-2xl mx-auto">
              <p className="text-green-300 font-semibold">
                🔒 Platform owners cannot modify or alter the trading code - all platforms run the same verified LiquidLab codebase
              </p>
            </div>
          </div>

          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
            {/* Security Feature Cards */}
            <Card className="bg-gray-800/50 border-gray-700 backdrop-blur border-2 border-green-500/50">
              <CardContent className="p-6">
                <div className="w-12 h-12 bg-green-500/10 rounded-lg flex items-center justify-center mb-4">
                  <Code className="w-6 h-6 text-green-400" />
                </div>
                <h3 className="text-lg font-semibold text-white mb-2">Immutable Trading Code</h3>
                <p className="text-gray-400 text-sm">
                  Platform owners cannot modify core trading logic, order execution, or wallet interactions. All platforms share the same secure, verified codebase.
                </p>
              </CardContent>
            </Card>
            
            <Card className="bg-gray-800/50 border-gray-700 backdrop-blur">
              <CardContent className="p-6">
                <div className="w-12 h-12 bg-green-500/10 rounded-lg flex items-center justify-center mb-4">
                  <Shield className="w-6 h-6 text-green-400" />
                </div>
                <h3 className="text-lg font-semibold text-white mb-2">SSL/TLS Encryption</h3>
                <p className="text-gray-400 text-sm">
                  All data transmission is encrypted with industry-standard SSL/TLS certificates, ensuring secure communication between traders and your platform.
                </p>
              </CardContent>
            </Card>

            <Card className="bg-gray-800/50 border-gray-700 backdrop-blur">
              <CardContent className="p-6">
                <div className="w-12 h-12 bg-green-500/10 rounded-lg flex items-center justify-center mb-4">
                  <Lock className="w-6 h-6 text-green-400" />
                </div>
                <h3 className="text-lg font-semibold text-white mb-2">Non-Custodial Architecture</h3>
                <p className="text-gray-400 text-sm">
                  Users maintain full control of their wallets and funds. Your platform never holds private keys, eliminating custody risk.
                </p>
              </CardContent>
            </Card>

            <Card className="bg-gray-800/50 border-gray-700 backdrop-blur">
              <CardContent className="p-6">
                <div className="w-12 h-12 bg-green-500/10 rounded-lg flex items-center justify-center mb-4">
                  <Key className="w-6 h-6 text-green-400" />
                </div>
                <h3 className="text-lg font-semibold text-white mb-2">2FA Authentication</h3>
                <p className="text-gray-400 text-sm">
                  Built-in two-factor authentication support using TOTP, adding an extra layer of security for user accounts.
                </p>
              </CardContent>
            </Card>

            <Card className="bg-gray-800/50 border-gray-700 backdrop-blur">
              <CardContent className="p-6">
                <div className="w-12 h-12 bg-green-500/10 rounded-lg flex items-center justify-center mb-4">
                  <AlertTriangle className="w-6 h-6 text-green-400" />
                </div>
                <h3 className="text-lg font-semibold text-white mb-2">Anti-Phishing Protection</h3>
                <p className="text-gray-400 text-sm">
                  Advanced phishing detection with unique verification codes and domain legitimacy checks protect users from scam sites.
                </p>
              </CardContent>
            </Card>

            <Card className="bg-gray-800/50 border-gray-700 backdrop-blur">
              <CardContent className="p-6">
                <div className="w-12 h-12 bg-green-500/10 rounded-lg flex items-center justify-center mb-4">
                  <Activity className="w-6 h-6 text-green-400" />
                </div>
                <h3 className="text-lg font-semibold text-white mb-2">Rate Limiting & DDoS Protection</h3>
                <p className="text-gray-400 text-sm">
                  Intelligent rate limiting prevents API abuse and DDoS attacks, ensuring your platform stays online during high traffic.
                </p>
              </CardContent>
            </Card>

            <Card className="bg-gray-800/50 border-gray-700 backdrop-blur">
              <CardContent className="p-6">
                <div className="w-12 h-12 bg-green-500/10 rounded-lg flex items-center justify-center mb-4">
                  <FileText className="w-6 h-6 text-green-400" />
                </div>
                <h3 className="text-lg font-semibold text-white mb-2">Security Audit Logging</h3>
                <p className="text-gray-400 text-sm">
                  Comprehensive audit logs track all security events, login attempts, and transactions for complete transparency.
                </p>
              </CardContent>
            </Card>

            <Card className="bg-gray-800/50 border-gray-700 backdrop-blur">
              <CardContent className="p-6">
                <div className="w-12 h-12 bg-green-500/10 rounded-lg flex items-center justify-center mb-4">
                  <Eye className="w-6 h-6 text-green-400" />
                </div>
                <h3 className="text-lg font-semibold text-white mb-2">24/7 Security Monitoring</h3>
                <p className="text-gray-400 text-sm">
                  Real-time security monitoring detects and prevents threats. Automated systems track suspicious patterns and protect against emerging risks.
                </p>
              </CardContent>
            </Card>
          </div>

          {/* Additional Security Features */}
          <div className="mt-12 bg-gray-800/30 rounded-2xl p-8 backdrop-blur">
            <h3 className="text-xl font-semibold text-white mb-6 text-center">Additional Security Measures</h3>
            <div className="grid md:grid-cols-2 gap-6">
              <div className="space-y-3">
                <div className="flex items-start gap-3">
                  <Check className="w-5 h-5 text-green-400 flex-shrink-0 mt-0.5" />
                  <div>
                    <span className="text-gray-300 font-medium">CSRF Protection</span>
                    <p className="text-gray-500 text-sm">Cross-Site Request Forgery prevention on all state-changing operations</p>
                  </div>
                </div>
                <div className="flex items-start gap-3">
                  <Check className="w-5 h-5 text-green-400 flex-shrink-0 mt-0.5" />
                  <div>
                    <span className="text-gray-300 font-medium">Input Sanitization</span>
                    <p className="text-gray-500 text-sm">XSS prevention with DOMPurify and comprehensive input validation</p>
                  </div>
                </div>
                <div className="flex items-start gap-3">
                  <Check className="w-5 h-5 text-green-400 flex-shrink-0 mt-0.5" />
                  <div>
                    <span className="text-gray-300 font-medium">Security Headers</span>
                    <p className="text-gray-500 text-sm">Helmet.js implementation with CSP, HSTS, and X-Frame-Options</p>
                  </div>
                </div>
              </div>
              <div className="space-y-3">
                <div className="flex items-start gap-3">
                  <Check className="w-5 h-5 text-green-400 flex-shrink-0 mt-0.5" />
                  <div>
                    <span className="text-gray-300 font-medium">Platform Verification</span>
                    <p className="text-gray-500 text-sm">Unique verification codes for each platform to prevent impersonation</p>
                  </div>
                </div>
                <div className="flex items-start gap-3">
                  <Check className="w-5 h-5 text-green-400 flex-shrink-0 mt-0.5" />
                  <div>
                    <span className="text-gray-300 font-medium">Suspicious Activity Monitoring</span>
                    <p className="text-gray-500 text-sm">Real-time detection and automatic suspension of malicious platforms</p>
                  </div>
                </div>
                <div className="flex items-start gap-3">
                  <Check className="w-5 h-5 text-green-400 flex-shrink-0 mt-0.5" />
                  <div>
                    <span className="text-gray-300 font-medium">Webhook Verification</span>
                    <p className="text-gray-500 text-sm">Cryptographic signing for all external service integrations</p>
                  </div>
                </div>
              </div>
            </div>
          </div>

          {/* Trust Badge */}
          <div className="mt-8 text-center">
            <div className="inline-flex items-center gap-2 bg-green-500/10 px-6 py-3 rounded-full">
              <Shield className="w-5 h-5 text-green-400" />
              <span className="text-green-400 font-medium">Enterprise-Grade Security</span>
            </div>
          </div>
        </div>
      </section>

      {/* NEW: Polymarket Premium Feature */}
      <section className="py-16 bg-gradient-to-r from-purple-50 to-pink-50">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-12">
            <Badge className="bg-purple-600 text-white mb-4 px-3 py-1">NEW PREMIUM FEATURE</Badge>
            <h2 className="text-3xl lg:text-4xl font-bold text-gray-900 mb-4">
              <span className="text-purple-600">Polymarket</span> Prediction Markets
            </h2>
            <p className="text-xl text-gray-600 max-w-3xl mx-auto">
              Expand beyond trading with prediction markets. Earn additional 0.5% platform fees on every prediction.
            </p>
          </div>
          
          <div className="grid lg:grid-cols-2 gap-12 items-center">
            <div>
              <div className="bg-white rounded-lg shadow-lg p-8">
                <h3 className="text-2xl font-bold mb-4 text-purple-600">Why Add Polymarket?</h3>
                <ul className="space-y-4">
                  <li className="flex items-start">
                    <TrendingUp className="w-6 h-6 text-purple-600 mr-3 flex-shrink-0 mt-0.5" />
                    <div>
                      <span className="font-semibold">Additional Revenue Stream</span>
                      <p className="text-gray-600 text-sm mt-1">Earn 0.5% on all prediction trades, on top of your trading fees</p>
                    </div>
                  </li>
                  <li className="flex items-start">
                    <Users className="w-6 h-6 text-purple-600 mr-3 flex-shrink-0 mt-0.5" />
                    <div>
                      <span className="font-semibold">Attract New Users</span>
                      <p className="text-gray-600 text-sm mt-1">Appeal to prediction market enthusiasts and event traders</p>
                    </div>
                  </li>
                  <li className="flex items-start">
                    <Zap className="w-6 h-6 text-purple-600 mr-3 flex-shrink-0 mt-0.5" />
                    <div>
                      <span className="font-semibold">Multi-Chain Support</span>
                      <p className="text-gray-600 text-sm mt-1">Seamlessly switch between Hyperliquid and Polygon networks</p>
                    </div>
                  </li>
                </ul>
              </div>
            </div>
            
            <div>
              <Card className="border-purple-500 bg-gradient-to-br from-purple-100 to-pink-100">
                <CardHeader>
                  <CardTitle className="text-2xl text-purple-700">Premium Pricing</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="text-center mb-6">
                    <div className="text-5xl font-bold text-purple-600">$50</div>
                    <div className="text-purple-500">/month</div>
                  </div>
                  <div className="space-y-3 mb-6">
                    <div className="flex items-center">
                      <CheckCircle className="w-5 h-5 text-purple-600 mr-2" />
                      <span>Integrated prediction markets</span>
                    </div>
                    <div className="flex items-center">
                      <CheckCircle className="w-5 h-5 text-purple-600 mr-2" />
                      <span>0.5% platform fee on predictions</span>
                    </div>
                    <div className="flex items-center">
                      <CheckCircle className="w-5 h-5 text-purple-600 mr-2" />
                      <span>Purple-themed professional UI</span>
                    </div>
                    <div className="flex items-center">
                      <CheckCircle className="w-5 h-5 text-purple-600 mr-2" />
                      <span>Social login options</span>
                    </div>
                  </div>
                  <Link href="/templates">
                    <Button className="w-full bg-purple-600 hover:bg-purple-700 text-white">
                      View Polymarket Templates
                    </Button>
                  </Link>
                </CardContent>
              </Card>
            </div>
          </div>
        </div>
      </section>

      {/* Revenue Calculator Section */}
      <section className="py-16 bg-white">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-12">
            <h2 className="text-3xl lg:text-4xl font-bold text-gray-900 mb-4">
              Calculate Your Potential Earnings
            </h2>
            <p className="text-xl text-gray-600 max-w-3xl mx-auto">
              See how much you could earn from trading fees and MoonPay affiliate commissions
            </p>
          </div>
          <RevenueCalculator />
        </div>
      </section>

      {/* Stats Section */}
      <section className="py-16 bg-white">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="grid grid-cols-2 lg:grid-cols-4 gap-8">
            <div className="text-center">
              <div className="text-3xl lg:text-4xl font-bold text-liquid-green mb-2">$10M+</div>
              <div className="text-gray-600">Builder Revenue Generated</div>
            </div>
            <div className="text-center">
              <div className="text-3xl lg:text-4xl font-bold text-liquid-green mb-2">500+</div>
              <div className="text-gray-600">Trading Platforms Created</div>
            </div>
            <div className="text-center">
              <div className="text-3xl lg:text-4xl font-bold text-liquid-green mb-2">50+</div>
              <div className="text-gray-600">Templates Available</div>
            </div>
            <div className="text-center">
              <div className="text-3xl lg:text-4xl font-bold text-liquid-green mb-2">24/7</div>
              <div className="text-gray-600">Hyperliquid Integration</div>
            </div>
          </div>
        </div>
      </section>

      {/* Template Preview */}
      <section className="py-16 bg-gray-50">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-12">
            <h2 className="text-3xl lg:text-4xl font-bold text-gray-900 mb-4">
              Choose Your Template
            </h2>
            <p className="text-xl text-gray-600 max-w-3xl mx-auto">
              Start with professionally designed templates optimized for different trading styles and user experiences.
            </p>
          </div>
          
          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-8">
            {[
              {
                name: "Professional Trader",
                category: "Professional",
                description: "Advanced charts, order book, and portfolio management for serious traders.",
                color: "bg-gray-900",
                accent: "bg-liquid-green",
                price: "$67,845"
              },
              {
                name: "Mobile Trader",
                category: "Mobile First",
                description: "Optimized for mobile trading with touch-friendly interfaces.",
                color: "bg-indigo-900",
                accent: "bg-purple-500",
                price: "$2,340"
              },
              {
                name: "Clean Interface",
                category: "Minimal",
                description: "Minimalist design focused on essential trading functions.",
                color: "bg-gray-100 border-2 border-gray-200",
                accent: "bg-gray-600",
                price: "$45,230"
              }
            ].map((template, index) => (
              <Card key={index} className="overflow-hidden card-hover">
                <div className={`${template.color} p-6 text-white h-48 relative`}>
                  <div className={`absolute top-4 right-4 ${template.accent} text-white px-2 py-1 rounded text-xs font-semibold`}>
                    {template.category}
                  </div>
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="font-semibold">{template.name}</h3>
                    <div className="text-green-400 font-mono text-sm">{template.price}</div>
                  </div>
                  <div className="grid grid-cols-3 gap-2 mb-4">
                    <div className="bg-gray-800 h-8 rounded"></div>
                    <div className="bg-gray-800 h-8 rounded"></div>
                    <div className="bg-gray-800 h-8 rounded"></div>
                  </div>
                  <div className="h-16 bg-gradient-to-r from-green-400 to-blue-400 rounded opacity-30"></div>
                </div>
                <CardContent className="p-6">
                  <h3 className="font-semibold text-lg mb-2">{template.name}</h3>
                  <p className="text-gray-600 mb-4">{template.description}</p>
                  <div className="flex items-center justify-between">
                    <span className="text-liquid-green font-semibold">Free</span>
                    <Link href={`/builder/${index + 1}`}>
                      <Button className="bg-liquid-green text-white hover:bg-liquid-accent">
                        Use Template
                      </Button>
                    </Link>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
          
          <div className="text-center mt-12">
            <Link href="/templates">
              <Button className="bg-liquid-green text-white px-8 py-4 rounded-lg font-semibold hover:bg-liquid-accent transition-colors text-lg">
                Browse All Templates
              </Button>
            </Link>
          </div>
        </div>
      </section>

      {/* Features Section */}
      <section className="py-16 bg-white">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-12">
            <h2 className="text-3xl lg:text-4xl font-bold text-gray-900 mb-4">
              Everything You Need
            </h2>
            <p className="text-xl text-gray-600 max-w-3xl mx-auto">
              Built-in features to create professional trading platforms that compete with the best in the industry.
            </p>
          </div>
          
          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-8">
            {[
              {
                icon: Plug,
                title: "Hyperliquid Integration",
                description: "Direct connection to Hyperliquid's orderbook and trading engine for lightning-fast execution.",
                color: "bg-liquid-green/10 text-liquid-green"
              },
              {
                icon: BarChart3,
                title: "TradingView Charts",
                description: "Professional charting tools with advanced indicators and drawing tools.",
                color: "bg-blue-500/10 text-blue-500"
              },
              {
                icon: Wallet,
                title: "Privy Wallet Integration",
                description: "Enterprise wallet infrastructure with social logins, built-in wallets, and 10+ wallet connections.",
                color: "bg-purple-500/10 text-purple-500"
              },
              {
                icon: Smartphone,
                title: "Mobile Responsive",
                description: "All platforms are optimized for mobile trading on any device.",
                color: "bg-orange-500/10 text-orange-500"
              },
              {
                icon: Rocket,
                title: "One-Click Deploy",
                description: "Launch your trading platform with a single click and start earning immediately.",
                color: "bg-red-500/10 text-red-500"
              },
              {
                icon: DollarSign,
                title: "Revenue Sharing",
                description: "Earn revenue through builder codes and referral programs automatically.",
                color: "bg-green-500/10 text-green-500"
              },
              {
                icon: Users,
                title: "Trader Support Included",
                description: "Basic trader support provided by LiquidLab for all platforms, ensuring your users get help when needed.",
                color: "bg-indigo-500/10 text-indigo-500"
              },
              {
                icon: Activity,
                title: "Trader Analytics & Incentives",
                description: "Track trader volumes and run incentive programs. Monitor individual performance and reward your top traders automatically.",
                color: "bg-cyan-500/10 text-cyan-500"
              }
            ].map((feature, index) => (
              <div key={index} className="text-center">
                <div className={`${feature.color} w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4`}>
                  <feature.icon className="w-8 h-8" />
                </div>
                <h3 className="font-semibold text-lg mb-2">{feature.title}</h3>
                <p className="text-gray-600">{feature.description}</p>
              </div>
            ))}
          </div>
        </div>
      </section>

      {/* CTA Section */}
      <section className="py-16 gradient-bg text-white">
        <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
          <h2 className="text-3xl lg:text-4xl font-bold mb-4">
            Ready to Build Your Trading Empire?
          </h2>
          <p className="text-xl text-green-100 mb-8">
            Join thousands of builders creating the next generation of trading platforms. Start free, scale unlimited.
          </p>
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Link href="/builder">
              <button 
                className="px-8 py-4 rounded-lg font-semibold transition-colors text-lg shadow-lg"
                style={{ 
                  backgroundColor: 'white', 
                  color: '#00D084', 
                  border: '2px solid #00D084' 
                }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.backgroundColor = '#00D084';
                  e.currentTarget.style.color = 'white';
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.backgroundColor = 'white';
                  e.currentTarget.style.color = '#00D084';
                }}
              >
                Start Building Free
              </button>
            </Link>
            <button 
              className="px-8 py-4 rounded-lg font-semibold transition-colors text-lg shadow-lg"
              style={{ 
                backgroundColor: 'white', 
                color: '#00D084', 
                border: '2px solid #00D084' 
              }}
              onMouseEnter={(e) => {
                e.currentTarget.style.backgroundColor = '#00D084';
                e.currentTarget.style.color = 'white';
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.backgroundColor = 'white';
                e.currentTarget.style.color = '#00D084';
              }}
            >
              Book a Demo
            </button>
          </div>
        </div>
      </section>
    </div>
  );
}

```

---

## File: client/src/pages/login.tsx

```tsx
import { useState } from "react";
import { Link, useLocation } from "wouter";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from "@/lib/queryClient";
import { queryClient } from "@/lib/queryClient";
import { Loader2, Shield } from "lucide-react";

export default function Login() {
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const [loading, setLoading] = useState(false);
  const [requires2FA, setRequires2FA] = useState(false);
  const [userId, setUserId] = useState<number | null>(null);
  const [formData, setFormData] = useState({
    email: "",
    password: "",
    totp: "",
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    setLoading(true);
    try {
      const response = await apiRequest("POST", "/api/auth/signin", formData);
      
      // Check if 2FA is required
      if (response.requiresTwoFactor) {
        setRequires2FA(true);
        setUserId(response.userId);
        toast({
          title: "2FA Required",
          description: "Please enter your authentication code",
        });
        return;
      }
      
      // Invalidate and wait for auth query to refresh
      await queryClient.invalidateQueries({ queryKey: ["/api/auth/user"] });
      await queryClient.refetchQueries({ queryKey: ["/api/auth/user"] });
      
      toast({
        title: "Welcome Back!",
        description: "Successfully logged in. Redirecting...",
      });
      
      // Navigate to dashboard
      setTimeout(() => {
        setLocation("/dashboard");
      }, 500);
    } catch (error: any) {
      toast({
        title: "Login Failed",
        description: error.message || "Invalid email or password.",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            {requires2FA && <Shield className="h-5 w-5" />}
            {requires2FA ? "Two-Factor Authentication" : "Welcome Back"}
          </CardTitle>
          <CardDescription>
            {requires2FA 
              ? "Enter the 6-digit code from your authenticator app" 
              : "Log in to manage your trading platforms"}
          </CardDescription>
        </CardHeader>
        <form onSubmit={handleSubmit}>
          <CardContent className="space-y-4">
            {!requires2FA ? (
              <>
                <div>
                  <Label htmlFor="email">Email</Label>
                  <Input
                    id="email"
                    type="email"
                    placeholder="john@example.com"
                    value={formData.email}
                    onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                    required
                  />
                </div>
                
                <div>
                  <Label htmlFor="password">Password</Label>
                  <Input
                    id="password"
                    type="password"
                    placeholder="••••••••"
                    value={formData.password}
                    onChange={(e) => setFormData({ ...formData, password: e.target.value })}
                    required
                  />
                </div>
              </>
            ) : (
              <div>
                <Label htmlFor="totp">Authentication Code</Label>
                <Input
                  id="totp"
                  type="text"
                  placeholder="123456"
                  value={formData.totp}
                  onChange={(e) => setFormData({ ...formData, totp: e.target.value })}
                  maxLength={6}
                  required
                  autoFocus
                />
                <p className="text-sm text-gray-600 mt-2">
                  Can't access your authenticator? Use a backup code instead.
                </p>
              </div>
            )}
          </CardContent>
          
          <CardFooter className="flex flex-col gap-4">
            <Button 
              type="submit" 
              className="w-full"
              disabled={loading}
            >
              {loading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  {requires2FA ? "Verifying..." : "Logging in..."}
                </>
              ) : (
                requires2FA ? "Verify" : "Log In"
              )}
            </Button>
            
            {requires2FA ? (
              <Button
                type="button"
                variant="outline"
                className="w-full"
                onClick={() => {
                  setRequires2FA(false);
                  setFormData({ ...formData, totp: "" });
                }}
              >
                Back to Login
              </Button>
            ) : (
              <p className="text-sm text-center text-gray-600">
                Don't have an account?{" "}
                <Link href="/signup" className="text-primary hover:underline">
                  Sign up
                </Link>
              </p>
            )}
          </CardFooter>
        </form>
      </Card>
    </div>
  );
}
```

---

## File: client/src/pages/not-found.tsx

```tsx
import { Card, CardContent } from "@/components/ui/card";
import { AlertCircle } from "lucide-react";

export default function NotFound() {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md mx-4">
        <CardContent className="pt-6">
          <div className="flex mb-4 gap-2">
            <AlertCircle className="h-8 w-8 text-red-500" />
            <h1 className="text-2xl font-bold text-gray-900">404 Page Not Found</h1>
          </div>

          <p className="mt-4 text-sm text-gray-600">
            Did you forget to add the page to the router?
          </p>
        </CardContent>
      </Card>
    </div>
  );
}

```

---

## File: client/src/pages/pricing.tsx

```tsx
import { Check, Zap, TrendingUp, Users, Shield, DollarSign, Rocket } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Link } from "wouter";
import { RevenueCalculator } from "@/components/RevenueCalculator";

export default function Pricing() {
  return (
    <div className="min-h-screen bg-gradient-to-b from-background to-secondary/20">
      <div className="container mx-auto px-4 py-16">
        <div className="text-center mb-12">
          <Badge className="mb-4" variant="outline">No Upfront Costs</Badge>
          <h1 className="text-4xl font-bold mb-4">Build Your Trading Platform for Free</h1>
          <p className="text-xl text-muted-foreground max-w-3xl mx-auto">
            Start building immediately. LiquidLab only makes money when you do - through a simple revenue share on trading fees.
          </p>
        </div>

        {/* Revenue Share Model */}
        <Card className="max-w-5xl mx-auto mb-16 border-primary">
          <CardHeader className="text-center">
            <CardTitle className="text-2xl flex items-center justify-center gap-2">
              <DollarSign className="w-6 h-6" />
              Simple Revenue Sharing Model
            </CardTitle>
            <CardDescription className="text-lg mt-2">
              Two fee structures optimized for different trading types
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8">
              {/* Spot Trading */}
              <div className="border rounded-lg p-6">
                <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
                  <div className="w-2 h-2 bg-green-500 rounded-full"></div>
                  Spot Trading
                </h3>
                <div className="space-y-4">
                  <div className="flex justify-between items-center pb-2 border-b">
                    <span className="text-sm text-muted-foreground">Builder Fee</span>
                    <span className="font-semibold">0.2%</span>
                  </div>
                  <div className="grid grid-cols-2 gap-4">
                    <div className="text-center p-4 bg-green-50 dark:bg-green-950 rounded-lg">
                      <div className="text-2xl font-bold text-green-600 dark:text-green-400">70%</div>
                      <div className="text-xs font-medium">You Keep</div>
                      <div className="text-xs text-muted-foreground mt-1">0.14% of volume</div>
                    </div>
                    <div className="text-center p-4 bg-blue-50 dark:bg-blue-950 rounded-lg">
                      <div className="text-2xl font-bold text-blue-600 dark:text-blue-400">30%</div>
                      <div className="text-xs font-medium">LiquidLab</div>
                      <div className="text-xs text-muted-foreground mt-1">0.06% of volume</div>
                    </div>
                  </div>
                  <div className="text-sm text-muted-foreground bg-muted p-3 rounded">
                    Example: $10,000 spot trade = $20 fee
                    <br />You earn: $14 • LiquidLab: $6
                  </div>
                </div>
              </div>

              {/* Perp Trading */}
              <div className="border rounded-lg p-6">
                <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
                  <div className="w-2 h-2 bg-purple-500 rounded-full"></div>
                  Perp Trading
                </h3>
                <div className="space-y-4">
                  <div className="flex justify-between items-center pb-2 border-b">
                    <span className="text-sm text-muted-foreground">Builder Fee</span>
                    <span className="font-semibold">0.1% <span className="text-xs text-muted-foreground">(max allowed)</span></span>
                  </div>
                  <div className="grid grid-cols-2 gap-4">
                    <div className="text-center p-4 bg-green-50 dark:bg-green-950 rounded-lg">
                      <div className="text-2xl font-bold text-green-600 dark:text-green-400">70%</div>
                      <div className="text-xs font-medium">You Keep</div>
                      <div className="text-xs text-muted-foreground mt-1">0.07% of volume</div>
                    </div>
                    <div className="text-center p-4 bg-blue-50 dark:bg-blue-950 rounded-lg">
                      <div className="text-2xl font-bold text-blue-600 dark:text-blue-400">30%</div>
                      <div className="text-xs font-medium">LiquidLab</div>
                      <div className="text-xs text-muted-foreground mt-1">0.03% of volume</div>
                    </div>
                  </div>
                  <div className="text-sm text-muted-foreground bg-muted p-3 rounded">
                    Example: $10,000 perp trade = $10 fee
                    <br />You earn: $7 • LiquidLab: $3
                  </div>
                </div>
              </div>
            </div>

            {/* MoonPay Affiliate Revenue */}
            <div className="border rounded-lg p-6 mb-8">
              <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
                <div className="w-2 h-2 bg-orange-500 rounded-full"></div>
                MoonPay Fiat On-Ramp Revenue
              </h3>
              <div className="space-y-4">
                <div className="flex justify-between items-center pb-2 border-b">
                  <span className="text-sm text-muted-foreground">Affiliate Commission</span>
                  <span className="font-semibold">1% <span className="text-xs text-muted-foreground">(of fiat purchases)</span></span>
                </div>
                <div className="grid grid-cols-2 gap-4">
                  <div className="text-center p-4 bg-green-50 dark:bg-green-950 rounded-lg">
                    <div className="text-2xl font-bold text-green-600 dark:text-green-400">50%</div>
                    <div className="text-xs font-medium">You Keep</div>
                    <div className="text-xs text-muted-foreground mt-1">0.5% of purchases</div>
                  </div>
                  <div className="text-center p-4 bg-blue-50 dark:bg-blue-950 rounded-lg">
                    <div className="text-2xl font-bold text-blue-600 dark:text-blue-400">50%</div>
                    <div className="text-xs font-medium">LiquidLab</div>
                    <div className="text-xs text-muted-foreground mt-1">0.5% of purchases</div>
                  </div>
                </div>
                <div className="text-sm text-muted-foreground bg-muted p-3 rounded">
                  Example: $10,000 crypto purchase = $100 commission
                  <br />You earn: $50 • LiquidLab: $50
                </div>
              </div>
            </div>
            
            <div className="text-center p-6 bg-purple-50 dark:bg-purple-950 rounded-lg">
              <div className="text-3xl font-bold text-purple-600 dark:text-purple-400">$0</div>
              <div className="text-sm font-medium mt-2">Upfront Cost</div>
              <div className="text-xs text-muted-foreground mt-1">No setup fees • No monthly charges • No hidden costs</div>
            </div>
          </CardContent>
        </Card>

        {/* Revenue Calculator */}
        <div className="mb-16">
          <RevenueCalculator />
        </div>

        {/* Features Grid */}
        <div className="mb-16">
          <h2 className="text-3xl font-bold text-center mb-12">Everything Included, No Hidden Costs</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 max-w-6xl mx-auto">
            <Card>
              <CardHeader>
                <Rocket className="w-10 h-10 mb-2 text-primary" />
                <CardTitle>Unlimited Platforms</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-muted-foreground">
                  Build as many trading platforms as you want. Each with its own custom domain and branding.
                </p>
              </CardContent>
            </Card>
            
            <Card>
              <CardHeader>
                <Zap className="w-10 h-10 mb-2 text-primary" />
                <CardTitle>All Premium Templates</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-muted-foreground">
                  Access our entire library of professional trading interface templates. No restrictions.
                </p>
              </CardContent>
            </Card>
            
            <Card>
              <CardHeader>
                <TrendingUp className="w-10 h-10 mb-2 text-primary" />
                <CardTitle>Real-time Analytics</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-muted-foreground">
                  Track your revenue, user activity, and trading volume with comprehensive dashboards.
                </p>
              </CardContent>
            </Card>
            
            <Card>
              <CardHeader>
                <Users className="w-10 h-10 mb-2 text-primary" />
                <CardTitle>Builder & Referral Codes</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-muted-foreground">
                  Generate additional revenue through builder codes and referral programs.
                </p>
              </CardContent>
            </Card>
            
            <Card>
              <CardHeader>
                <Shield className="w-10 h-10 mb-2 text-primary" />
                <CardTitle>Enterprise Security</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-muted-foreground">
                  Bank-grade security, SSL certificates, and DDoS protection included at no extra cost.
                </p>
              </CardContent>
            </Card>
            
            <Card>
              <CardHeader>
                <DollarSign className="w-10 h-10 mb-2 text-primary" />
                <CardTitle>Weekly Payouts</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-muted-foreground">
                  Your trading fee revenue is deposited to your wallet weekly. Automated USDC transfers on Arbitrum.
                </p>
              </CardContent>
            </Card>
          </div>
        </div>

        {/* Premium Add-Ons Section */}
        <div className="mb-16">
          <h2 className="text-3xl font-bold text-center mb-8">Premium Add-Ons</h2>
          <Card className="max-w-4xl mx-auto border-purple-500 bg-gradient-to-r from-purple-50 to-pink-50 dark:from-purple-950 dark:to-pink-950">
            <CardHeader>
              <div className="flex items-center justify-between">
                <CardTitle className="text-2xl flex items-center gap-2">
                  <span className="text-purple-600">🔮</span>
                  Polymarket Prediction Markets
                  <Badge className="bg-purple-600 text-white">NEW</Badge>
                </CardTitle>
                <Badge className="bg-purple-100 text-purple-700 dark:bg-purple-900 dark:text-purple-300 px-4 py-1 text-lg font-bold">
                  $50/month
                </Badge>
              </div>
              <CardDescription className="text-base mt-2">
                Add prediction markets to your trading platform and earn additional revenue
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid md:grid-cols-2 gap-6">
                <div>
                  <h4 className="font-semibold mb-3 text-purple-700 dark:text-purple-400">What You Get:</h4>
                  <ul className="space-y-2 text-sm">
                    <li className="flex items-start gap-2">
                      <Check className="w-4 h-4 text-purple-600 mt-0.5" />
                      <span>Integrated prediction markets alongside trading</span>
                    </li>
                    <li className="flex items-start gap-2">
                      <Check className="w-4 h-4 text-purple-600 mt-0.5" />
                      <span>Multi-chain support (Polygon network)</span>
                    </li>
                    <li className="flex items-start gap-2">
                      <Check className="w-4 h-4 text-purple-600 mt-0.5" />
                      <span>Social login options for easier onboarding</span>
                    </li>
                    <li className="flex items-start gap-2">
                      <Check className="w-4 h-4 text-purple-600 mt-0.5" />
                      <span>Professional purple-themed UI</span>
                    </li>
                  </ul>
                </div>
                <div>
                  <h4 className="font-semibold mb-3 text-purple-700 dark:text-purple-400">Extra Revenue:</h4>
                  <div className="bg-purple-100 dark:bg-purple-900 p-4 rounded-lg">
                    <div className="text-2xl font-bold text-purple-700 dark:text-purple-300">+0.5%</div>
                    <div className="text-sm text-purple-600 dark:text-purple-400">Platform Fee on All Predictions</div>
                  </div>
                  <p className="text-sm text-muted-foreground mt-3">
                    Example: $100,000 in monthly predictions = <span className="font-semibold text-purple-600">$500 extra revenue</span>
                  </p>
                  <div className="mt-3 text-xs text-muted-foreground">
                    * In addition to your trading fee revenue
                  </div>
                </div>
              </div>
              <div className="pt-4 flex justify-center">
                <Link href="/templates">
                  <Button className="bg-purple-600 hover:bg-purple-700 text-white">
                    View Polymarket Templates
                  </Button>
                </Link>
              </div>
            </CardContent>
          </Card>
        </div>

        {/* CTA Section */}
        <div className="text-center mb-16">
          <Card className="max-w-2xl mx-auto bg-primary text-primary-foreground">
            <CardContent className="p-8">
              <h2 className="text-3xl font-bold mb-4">Ready to Start Earning?</h2>
              <p className="text-lg mb-6 opacity-90">
                Join hundreds of traders who are already generating passive income with their custom trading platforms.
              </p>
              <Link href="/builder">
                <Button size="lg" variant="secondary" className="font-semibold">
                  Start Building for Free
                </Button>
              </Link>
              <p className="mt-4 text-sm opacity-80">
                No credit card required • Start earning in minutes
              </p>
            </CardContent>
          </Card>
        </div>

        {/* FAQ Section */}
        <div className="bg-card rounded-lg p-8 max-w-4xl mx-auto">
          <h2 className="text-2xl font-semibold mb-6 text-center">Frequently Asked Questions</h2>
          <div className="space-y-6">
            <div>
              <h3 className="font-semibold mb-2">How do I get paid?</h3>
              <p className="text-muted-foreground">
                Your earnings are automatically deposited to your connected wallet in real-time. You earn 70% of trading fees (0.14% on spot trades, 0.07% on perp trades) plus 50% of MoonPay affiliate commissions (0.5% of fiat purchases). No minimum payout thresholds.
              </p>
            </div>
            <div>
              <h3 className="font-semibold mb-2">Are there any hidden fees?</h3>
              <p className="text-muted-foreground">
                No hidden fees whatsoever. You only share revenue from actual trades. Domain hosting, SSL, templates, and all features are included at no extra cost.
              </p>
            </div>
            <div>
              <h3 className="font-semibold mb-2">What types of trading are supported?</h3>
              <p className="text-muted-foreground">
                Your platforms support both Spot Trading (0.2% builder fee) and Perpetual Trading (0.1% builder fee). You keep 70% of all builder fees generated. The fee structures are optimized for each trading type.
              </p>
            </div>
            <div>
              <h3 className="font-semibold mb-2">Can I use my own domain?</h3>
              <p className="text-muted-foreground">
                Yes! Custom domains are included free. We handle all the technical setup, SSL certificates, and hosting.
              </p>
            </div>
            <div>
              <h3 className="font-semibold mb-2">What if I don't get any traders?</h3>
              <p className="text-muted-foreground">
                Then you pay nothing! LiquidLab only makes money when you do. There are no monthly fees, hosting costs, or maintenance charges.
              </p>
            </div>
            <div>
              <h3 className="font-semibold mb-2">How much can I earn?</h3>
              <p className="text-muted-foreground">
                Your earnings scale with trading volume. A platform doing $1M daily spot volume generates $1,400/day (0.14%). For perp trading, $1M daily volume generates $700/day (0.07%). Many platforms trade both types.
              </p>
            </div>
            <div>
              <h3 className="font-semibold mb-2">How does MoonPay revenue work?</h3>
              <p className="text-muted-foreground">
                When users buy crypto through MoonPay on your platform, you earn 0.5% of the purchase amount (50% of the 1% affiliate commission). For example, if users purchase $100,000 worth of crypto per month, you earn an additional $500/month on top of trading fees.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
```

---

## File: client/src/pages/security.tsx

```tsx
import { Shield, Lock, CheckCircle, AlertTriangle, ExternalLink, Key, Server, Globe } from "lucide-react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Link } from "wouter";

export default function Security() {
  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
      <div className="container mx-auto px-4 py-12">
        {/* Header */}
        <div className="text-center mb-12">
          <div className="inline-flex items-center justify-center w-16 h-16 bg-green-100 dark:bg-green-900/20 rounded-full mb-4">
            <Shield className="w-8 h-8 text-green-600 dark:text-green-400" />
          </div>
          <h1 className="text-4xl font-bold text-gray-900 dark:text-gray-100 mb-4">
            Platform Security & Trust
          </h1>
          <p className="text-xl text-gray-600 dark:text-gray-400 max-w-3xl mx-auto">
            Understanding how LiquidLab protects traders and ensures platform authenticity
          </p>
        </div>

        {/* Key Security Features */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-12">
          <Card>
            <CardHeader>
              <Lock className="w-8 h-8 text-blue-600 mb-2" />
              <CardTitle>Non-Custodial Trading</CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-gray-600 dark:text-gray-400">
                Your wallet keys never leave your control. All transactions are signed locally 
                and executed directly on Hyperliquid DEX.
              </p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CheckCircle className="w-8 h-8 text-green-600 mb-2" />
              <CardTitle>Platform Verification</CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-gray-600 dark:text-gray-400">
                Every LiquidLab platform is verified and assigned a unique ID. Check any 
                platform's authenticity at liquidlab.trade/verify.
              </p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <Key className="w-8 h-8 text-purple-600 mb-2" />
              <CardTitle>Privy Integration</CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-gray-600 dark:text-gray-400">
                Enterprise-grade wallet security powered by Privy, supporting social logins 
                and multi-factor authentication.
              </p>
            </CardContent>
          </Card>
        </div>

        {/* Detailed Security Information */}
        <Tabs defaultValue="verification" className="mb-12">
          <TabsList className="grid w-full grid-cols-4">
            <TabsTrigger value="verification">Verification</TabsTrigger>
            <TabsTrigger value="trading">Trading Security</TabsTrigger>
            <TabsTrigger value="infrastructure">Infrastructure</TabsTrigger>
            <TabsTrigger value="reporting">Reporting</TabsTrigger>
          </TabsList>

          <TabsContent value="verification" className="mt-6">
            <Card>
              <CardHeader>
                <CardTitle>How to Verify a Trading Platform</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-3">
                  <h3 className="font-semibold text-lg">Before Connecting Your Wallet:</h3>
                  
                  <div className="pl-4 space-y-4">
                    <div className="flex items-start gap-3">
                      <div className="w-8 h-8 bg-green-100 dark:bg-green-900/20 rounded-full flex items-center justify-center flex-shrink-0">
                        <span className="text-green-600 dark:text-green-400 font-bold">1</span>
                      </div>
                      <div>
                        <h4 className="font-medium mb-1">Check the URL</h4>
                        <p className="text-gray-600 dark:text-gray-400">
                          Legitimate platforms use either a custom domain or a .liquidlab.app subdomain. 
                          Look for the SSL padlock in your browser.
                        </p>
                      </div>
                    </div>

                    <div className="flex items-start gap-3">
                      <div className="w-8 h-8 bg-green-100 dark:bg-green-900/20 rounded-full flex items-center justify-center flex-shrink-0">
                        <span className="text-green-600 dark:text-green-400 font-bold">2</span>
                      </div>
                      <div>
                        <h4 className="font-medium mb-1">Look for the Verification Badge</h4>
                        <p className="text-gray-600 dark:text-gray-400">
                          All legitimate platforms display a "LiquidLab Verified" badge in the header. 
                          Click it to see the platform ID and verification details.
                        </p>
                      </div>
                    </div>

                    <div className="flex items-start gap-3">
                      <div className="w-8 h-8 bg-green-100 dark:bg-green-900/20 rounded-full flex items-center justify-center flex-shrink-0">
                        <span className="text-green-600 dark:text-green-400 font-bold">3</span>
                      </div>
                      <div>
                        <h4 className="font-medium mb-1">Verify Platform ID</h4>
                        <p className="text-gray-600 dark:text-gray-400">
                          Visit{" "}
                          <a 
                            href="https://liquidlab.trade/verify" 
                            target="_blank" 
                            rel="noopener noreferrer"
                            className="text-blue-600 hover:underline"
                          >
                            liquidlab.trade/verify
                          </a>
                          {" "}and enter the platform ID to confirm it's officially registered.
                        </p>
                      </div>
                    </div>

                    <div className="flex items-start gap-3">
                      <div className="w-8 h-8 bg-green-100 dark:bg-green-900/20 rounded-full flex items-center justify-center flex-shrink-0">
                        <span className="text-green-600 dark:text-green-400 font-bold">4</span>
                      </div>
                      <div>
                        <h4 className="font-medium mb-1">Check Privy Branding</h4>
                        <p className="text-gray-600 dark:text-gray-400">
                          When connecting your wallet, ensure the Privy modal shows official branding 
                          and the correct platform name.
                        </p>
                      </div>
                    </div>
                  </div>
                </div>

                <Alert>
                  <AlertTriangle className="h-4 w-4" />
                  <AlertDescription>
                    <strong>Warning:</strong> Never enter your seed phrase or private keys on any website. 
                    Legitimate platforms only request wallet connections through Privy or MetaMask.
                  </AlertDescription>
                </Alert>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="trading" className="mt-6">
            <Card>
              <CardHeader>
                <CardTitle>Trading Security Features</CardTitle>
              </CardHeader>
              <CardContent className="space-y-6">
                <div>
                  <h3 className="font-semibold mb-3">Non-Custodial Architecture</h3>
                  <ul className="space-y-2 text-gray-600 dark:text-gray-400">
                    <li className="flex items-start gap-2">
                      <CheckCircle className="w-5 h-5 text-green-500 mt-0.5" />
                      <span>Your funds remain in your wallet until you execute a trade</span>
                    </li>
                    <li className="flex items-start gap-2">
                      <CheckCircle className="w-5 h-5 text-green-500 mt-0.5" />
                      <span>All transactions are signed locally in your browser</span>
                    </li>
                    <li className="flex items-start gap-2">
                      <CheckCircle className="w-5 h-5 text-green-500 mt-0.5" />
                      <span>Direct settlement on Hyperliquid DEX smart contracts</span>
                    </li>
                    <li className="flex items-start gap-2">
                      <CheckCircle className="w-5 h-5 text-green-500 mt-0.5" />
                      <span>No intermediary holds your assets</span>
                    </li>
                  </ul>
                </div>

                <div>
                  <h3 className="font-semibold mb-3">Transaction Transparency</h3>
                  <ul className="space-y-2 text-gray-600 dark:text-gray-400">
                    <li className="flex items-start gap-2">
                      <CheckCircle className="w-5 h-5 text-green-500 mt-0.5" />
                      <span>All trades visible on Hyperliquid explorer</span>
                    </li>
                    <li className="flex items-start gap-2">
                      <CheckCircle className="w-5 h-5 text-green-500 mt-0.5" />
                      <span>Builder fees clearly displayed before trading</span>
                    </li>
                    <li className="flex items-start gap-2">
                      <CheckCircle className="w-5 h-5 text-green-500 mt-0.5" />
                      <span>Real-time balance updates from blockchain</span>
                    </li>
                  </ul>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="infrastructure" className="mt-6">
            <Card>
              <CardHeader>
                <CardTitle>Platform Infrastructure</CardTitle>
              </CardHeader>
              <CardContent className="space-y-6">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div>
                    <h3 className="font-semibold mb-3 flex items-center gap-2">
                      <Server className="w-5 h-5" />
                      Hosting & Security
                    </h3>
                    <ul className="space-y-2 text-gray-600 dark:text-gray-400 text-sm">
                      <li>• SSL/TLS encryption on all domains</li>
                      <li>• DDoS protection via Cloudflare</li>
                      <li>• Regular security audits</li>
                      <li>• Automated vulnerability scanning</li>
                    </ul>
                  </div>

                  <div>
                    <h3 className="font-semibold mb-3 flex items-center gap-2">
                      <Globe className="w-5 h-5" />
                      API Security
                    </h3>
                    <ul className="space-y-2 text-gray-600 dark:text-gray-400 text-sm">
                      <li>• Rate limiting on all endpoints</li>
                      <li>• API key authentication</li>
                      <li>• Request signing verification</li>
                      <li>• Audit logging for all actions</li>
                    </ul>
                  </div>
                </div>

                <div>
                  <h3 className="font-semibold mb-3">Third-Party Integrations</h3>
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg">
                      <h4 className="font-medium mb-2">Hyperliquid</h4>
                      <p className="text-sm text-gray-600 dark:text-gray-400">
                        Official API integration for trading and market data
                      </p>
                    </div>
                    <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg">
                      <h4 className="font-medium mb-2">Privy</h4>
                      <p className="text-sm text-gray-600 dark:text-gray-400">
                        Enterprise wallet infrastructure with MFA support
                      </p>
                    </div>
                    <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg">
                      <h4 className="font-medium mb-2">MoonPay</h4>
                      <p className="text-sm text-gray-600 dark:text-gray-400">
                        KYC/AML compliant fiat on-ramp services
                      </p>
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="reporting" className="mt-6">
            <Card>
              <CardHeader>
                <CardTitle>Report Suspicious Activity</CardTitle>
              </CardHeader>
              <CardContent className="space-y-6">
                <Alert className="border-red-200 bg-red-50 dark:bg-red-950/20">
                  <AlertTriangle className="h-4 w-4 text-red-600" />
                  <AlertDescription className="text-red-800 dark:text-red-200">
                    If you encounter a suspicious website claiming to be a LiquidLab platform, 
                    please report it immediately to protect other traders.
                  </AlertDescription>
                </Alert>

                <div className="space-y-4">
                  <h3 className="font-semibold">Warning Signs of Fake Platforms:</h3>
                  <ul className="space-y-2 text-gray-600 dark:text-gray-400">
                    <li className="flex items-start gap-2">
                      <AlertTriangle className="w-5 h-5 text-red-500 mt-0.5" />
                      <span>Asks for seed phrases or private keys</span>
                    </li>
                    <li className="flex items-start gap-2">
                      <AlertTriangle className="w-5 h-5 text-red-500 mt-0.5" />
                      <span>No verification badge or invalid platform ID</span>
                    </li>
                    <li className="flex items-start gap-2">
                      <AlertTriangle className="w-5 h-5 text-red-500 mt-0.5" />
                      <span>Suspicious domain not ending in .liquidlab.app</span>
                    </li>
                    <li className="flex items-start gap-2">
                      <AlertTriangle className="w-5 h-5 text-red-500 mt-0.5" />
                      <span>Missing SSL certificate (no padlock in browser)</span>
                    </li>
                    <li className="flex items-start gap-2">
                      <AlertTriangle className="w-5 h-5 text-red-500 mt-0.5" />
                      <span>Promises of guaranteed returns or bonuses</span>
                    </li>
                  </ul>
                </div>

                <div className="bg-gray-100 dark:bg-gray-800 p-6 rounded-lg">
                  <h3 className="font-semibold mb-3">How to Report</h3>
                  <div className="space-y-3">
                    <Button className="w-full justify-start" variant="outline">
                      <ExternalLink className="w-4 h-4 mr-2" />
                      Report via liquidlab.trade/report
                    </Button>
                    <Button className="w-full justify-start" variant="outline">
                      <ExternalLink className="w-4 h-4 mr-2" />
                      Email: security@liquidlab.trade
                    </Button>
                    <p className="text-sm text-gray-600 dark:text-gray-400">
                      Include the suspicious URL, screenshots, and any other relevant information.
                    </p>
                  </div>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>

        {/* Call to Action */}
        <div className="text-center">
          <Card className="max-w-2xl mx-auto">
            <CardContent className="py-8">
              <h2 className="text-2xl font-bold mb-4">Ready to Trade Safely?</h2>
              <p className="text-gray-600 dark:text-gray-400 mb-6">
                Build your own secure trading platform or explore verified platforms built by our community.
              </p>
              <div className="flex flex-col sm:flex-row gap-4 justify-center">
                <Link href="/builder">
                  <Button size="lg">
                    Start Building
                  </Button>
                </Link>
                <Link href="/templates">
                  <Button size="lg" variant="outline">
                    Browse Platforms
                  </Button>
                </Link>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}
```

---

## File: client/src/pages/signup.tsx

```tsx
import { useState } from "react";
import { Link, useLocation } from "wouter";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from "@/lib/queryClient";
import { Loader2 } from "lucide-react";

export default function Signup() {
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState({
    username: "",
    email: "",
    password: "",
    confirmPassword: ""
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (formData.password !== formData.confirmPassword) {
      toast({
        title: "Password Mismatch",
        description: "Passwords do not match.",
        variant: "destructive",
      });
      return;
    }

    if (formData.password.length < 8) {
      toast({
        title: "Weak Password",
        description: "Password must be at least 8 characters long.",
        variant: "destructive",
      });
      return;
    }

    setLoading(true);
    try {
      await apiRequest("POST", "/api/auth/signup", {
        username: formData.username,
        email: formData.email,
        password: formData.password,
      });
      
      toast({
        title: "Account Created!",
        description: "Please log in with your credentials.",
      });
      
      setLocation("/login");
    } catch (error: any) {
      toast({
        title: "Signup Failed",
        description: error.message || "Failed to create account.",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle>Create Your Account</CardTitle>
          <CardDescription>
            Start building trading platforms and earning revenue
          </CardDescription>
        </CardHeader>
        <form onSubmit={handleSubmit}>
          <CardContent className="space-y-4">
            <div>
              <Label htmlFor="username">Username</Label>
              <Input
                id="username"
                placeholder="johndoe"
                value={formData.username}
                onChange={(e) => setFormData({ ...formData, username: e.target.value })}
                required
              />
            </div>
            
            <div>
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                placeholder="john@example.com"
                value={formData.email}
                onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                required
              />
            </div>
            
            <div>
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                type="password"
                placeholder="••••••••"
                value={formData.password}
                onChange={(e) => setFormData({ ...formData, password: e.target.value })}
                required
              />
            </div>
            
            <div>
              <Label htmlFor="confirmPassword">Confirm Password</Label>
              <Input
                id="confirmPassword"
                type="password"
                placeholder="••••••••"
                value={formData.confirmPassword}
                onChange={(e) => setFormData({ ...formData, confirmPassword: e.target.value })}
                required
              />
            </div>
          </CardContent>
          
          <CardFooter className="flex flex-col gap-4">
            <Button 
              type="submit" 
              className="w-full"
              disabled={loading}
            >
              {loading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Creating Account...
                </>
              ) : (
                "Create Account"
              )}
            </Button>
            
            <p className="text-sm text-center text-gray-600">
              Already have an account?{" "}
              <Link href="/login" className="text-primary hover:underline">
                Log in
              </Link>
            </p>
          </CardFooter>
        </form>
      </Card>
    </div>
  );
}
```

---

## File: client/src/pages/templates.tsx

```tsx
import { useQuery } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Skeleton } from "@/components/ui/skeleton";
import { Link } from "wouter";
import { Search, Filter, BarChart3, Smartphone, Minimize2, TrendingUp, Eye } from "lucide-react";
import TemplatePreview from "@/components/templates/template-preview";

const templateCategories = [
  { name: 'All', count: 50 },
  { name: 'Professional', count: 15 },
  { name: 'Mobile First', count: 12 },
  { name: 'Minimal', count: 8 },
  { name: 'Analytics', count: 10 },
  { name: 'DeFi', count: 5 }
];

const mockTemplates = [
  {
    id: 1,
    name: "Hyperliquid Trading",
    description: "Professional perpetual trading interface with advanced charts and order management.",
    category: "Professional",
    previewImage: "/api/placeholder/400/300",
    features: ["TradingView Charts", "Order Book", "Portfolio Management", "0.1% Builder Fee"],
    isPopular: true,
    isPremium: false
  },
  {
    id: 2,
    name: "Hyperliquid + Polymarket",
    description: "Combined trading and prediction markets platform. Trade perps and predict outcomes.",
    category: "Professional",
    previewImage: "/api/placeholder/400/300",
    features: ["Perp Trading", "Prediction Markets", "Multi-Chain", "0.5% Extra Revenue"],
    isPopular: true,
    isPremium: true,
    premiumPrice: "$50/month"
  },
  {
    id: 3,
    name: "Polymarket Only",
    description: "Dedicated prediction markets platform for event-based trading and forecasting.",
    category: "DeFi",
    previewImage: "/api/placeholder/400/300",
    features: ["Event Trading", "Polygon Network", "Social Login", "0.5% Platform Fee"],
    isPopular: false,
    isPremium: true,
    premiumPrice: "$50/month"
  },
  {
    id: 4,
    name: "Mobile Trader",
    description: "Optimized for mobile trading with touch-friendly interfaces.",
    category: "Mobile First",
    previewImage: "/api/placeholder/400/300",
    features: ["Mobile Optimized", "Touch Controls", "Simplified UI", "Quick Actions"],
    isPopular: false
  },
  {
    id: 5,
    name: "Analytics Dashboard",
    description: "Data-driven trading with advanced analytics and insights.",
    category: "Analytics",
    previewImage: "/api/placeholder/400/300",
    features: ["Multi-Protocol", "Yield Farming", "Liquidity Pools", "Governance"],
    isPopular: false
  },
  {
    id: 6,
    name: "Scalping Pro",
    description: "High-frequency trading interface with millisecond precision.",
    category: "Professional",
    previewImage: "/api/placeholder/400/300",
    features: ["Real-time Data", "One-Click Trading", "Hotkeys", "Speed Optimization"],
    isPopular: true
  }
];

export default function Templates() {
  const { data: templates, isLoading } = useQuery({
    queryKey: ['/api/templates'],
    queryFn: async () => {
      // Mock API call - in real app this would fetch from backend
      return new Promise(resolve => {
        setTimeout(() => resolve(mockTemplates), 500);
      });
    }
  });

  const getCategoryIcon = (category: string) => {
    switch (category) {
      case 'Professional':
        return <BarChart3 className="w-5 h-5" />;
      case 'Mobile First':
        return <Smartphone className="w-5 h-5" />;
      case 'Minimal':
        return <Minimize2 className="w-5 h-5" />;
      case 'Analytics':
        return <TrendingUp className="w-5 h-5" />;
      default:
        return <BarChart3 className="w-5 h-5" />;
    }
  };

  const getTemplatePreview = (template: any) => {
    const colors = {
      'Professional': 'bg-gray-900 text-white',
      'Mobile First': 'bg-indigo-900 text-white',
      'Minimal': 'bg-gray-100 text-gray-900 border-2 border-gray-200',
      'Analytics': 'bg-blue-900 text-white',
      'DeFi': 'bg-purple-900 text-white'
    };

    return (
      <div className={`${colors[template.category as keyof typeof colors]} p-4 h-36 relative overflow-hidden`}>
        {template.isPopular && !template.isPremium && (
          <div className="absolute top-2 right-2 bg-liquid-green text-white px-2 py-0.5 rounded text-[10px] font-semibold">
            Popular
          </div>
        )}
        {template.isPremium && (
          <div className="absolute top-2 right-2 bg-purple-600 text-white px-2 py-0.5 rounded text-[10px] font-semibold">
            Premium
          </div>
        )}
        <div className="flex items-center justify-between mb-2">
          <h3 className="font-semibold text-sm">{template.name}</h3>
        </div>
        <div className="grid grid-cols-3 gap-1.5 mb-2">
          <div className="bg-gray-800 h-6 rounded opacity-50"></div>
          <div className="bg-gray-800 h-6 rounded opacity-50"></div>
          <div className="bg-gray-800 h-6 rounded opacity-50"></div>
        </div>
        <div className={`h-12 ${template.isPremium ? 'bg-gradient-to-r from-purple-400 to-pink-400' : 'bg-gradient-to-r from-green-400 to-blue-400'} rounded opacity-30`}></div>
      </div>
    );
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-gray-900 mb-4">Template Marketplace</h1>
        <p className="text-xl text-gray-600">
          Choose from professionally designed templates to kickstart your trading platform
        </p>
      </div>

      {/* Search and Filter */}
      <div className="flex flex-col lg:flex-row gap-4 mb-8">
        <div className="flex-1 relative">
          <Search className="w-5 h-5 absolute left-3 top-3 text-gray-400" />
          <Input
            placeholder="Search templates..."
            className="pl-10"
          />
        </div>
        <Button variant="outline" className="flex items-center">
          <Filter className="w-4 h-4 mr-2" />
          Filter
        </Button>
      </div>

      {/* Categories */}
      <div className="flex flex-wrap gap-2 mb-8">
        {templateCategories.map(category => (
          <Button
            key={category.name}
            variant={category.name === 'All' ? 'default' : 'outline'}
            size="sm"
            className="flex items-center"
          >
            {category.name}
            <Badge variant="secondary" className="ml-2">
              {category.count}
            </Badge>
          </Button>
        ))}
      </div>

      {/* Templates Grid */}
      {isLoading ? (
        <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
          {[...Array(6)].map((_, i) => (
            <Card key={i} className="overflow-hidden">
              <Skeleton className="h-48 w-full" />
              <CardContent className="p-6">
                <Skeleton className="h-6 w-3/4 mb-2" />
                <Skeleton className="h-4 w-full mb-4" />
                <div className="flex justify-between items-center">
                  <Skeleton className="h-4 w-16" />
                  <Skeleton className="h-8 w-24" />
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      ) : (
        <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
          {templates?.map((template: any) => (
            <Card key={template.id} className="overflow-hidden card-hover flex flex-col">
              {getTemplatePreview(template)}
              <CardContent className="p-4 flex-1 flex flex-col">
                <div className="flex items-center justify-between mb-2">
                  <h3 className="font-semibold text-base">{template.name}</h3>
                  <div className="flex items-center text-liquid-green">
                    {getCategoryIcon(template.category)}
                  </div>
                </div>
                <p className="text-gray-600 text-sm mb-3 line-clamp-2 flex-grow">{template.description}</p>
                
                <div className="flex flex-wrap gap-1 mb-4">
                  {template.features.slice(0, 2).map((feature: string, index: number) => (
                    <Badge key={index} variant="secondary" className="text-[10px] px-1.5 py-0.5">
                      {feature}
                    </Badge>
                  ))}
                  {template.features.length > 2 && (
                    <Badge variant="secondary" className="text-[10px] px-1.5 py-0.5">
                      +{template.features.length - 2} more
                    </Badge>
                  )}
                </div>
                
                <div className="mt-auto space-y-3">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                      {template.isPremium ? (
                        <span className="text-purple-600 font-bold">{template.premiumPrice}</span>
                      ) : (
                        <span className="text-liquid-green font-semibold text-sm">Free</span>
                      )}
                      <Badge variant="outline" className="text-[10px] px-2 py-0.5">{template.category}</Badge>
                    </div>
                  </div>
                  <div className="flex gap-2">
                    <TemplatePreview template={template}>
                      <Button variant="outline" size="sm" className="text-xs py-1.5">
                        <Eye className="w-3 h-3 mr-1" />
                        Preview
                      </Button>
                    </TemplatePreview>
                    <Link href={`/builder/${template.id}`} className="flex-1">
                      <Button className={`w-full text-xs py-1.5 ${template.isPremium ? "bg-purple-600 text-white hover:bg-purple-700" : "bg-liquid-green text-white hover:bg-liquid-accent"}`} size="sm">
                        Use Template
                      </Button>
                    </Link>
                  </div>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      )}

      {/* Load More */}
      <div className="text-center mt-12">
        <Button variant="outline" className="px-8 py-3">
          Load More Templates
        </Button>
      </div>
    </div>
  );
}

```

---

## File: client/src/pages/verify.tsx

```tsx
import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { Link } from "wouter";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card } from "@/components/ui/card";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Loader2, CheckCircle, XCircle, AlertTriangle, Shield, Search } from "lucide-react";

export default function Verify() {
  const [verificationCode, setVerificationCode] = useState("");
  const [isVerifying, setIsVerifying] = useState(false);
  const [verificationResult, setVerificationResult] = useState<any>(null);
  const [verificationError, setVerificationError] = useState<string | null>(null);

  const handleVerify = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!verificationCode.trim()) return;

    setIsVerifying(true);
    setVerificationError(null);
    setVerificationResult(null);

    try {
      const response = await fetch("/api/platforms/verify", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ code: verificationCode.trim() }),
      });

      const data = await response.json();

      if (response.ok && data.success) {
        setVerificationResult(data);
      } else {
        setVerificationError(data.error || "Verification failed");
      }
    } catch (error) {
      setVerificationError("Network error. Please try again.");
    } finally {
      setIsVerifying(false);
    }
  };

  return (
    <div className="min-h-screen bg-[#090909] text-white">
      {/* Header */}
      <header className="border-b border-gray-800">
        <div className="container mx-auto px-4 py-6">
          <div className="flex items-center justify-between">
            <Link href="/">
              <a className="flex items-center space-x-2">
                <img src="/logo.svg" alt="LiquidLab" className="h-8" />
                <span className="text-xl font-bold">LiquidLab</span>
              </a>
            </Link>
            <Link href="/builder">
              <Button variant="outline" size="sm">
                Build Your Platform
              </Button>
            </Link>
          </div>
        </div>
      </header>
      {/* Main Content */}
      <main className="container mx-auto px-4 py-12 max-w-4xl">
        <div className="text-center mb-12">
          <div className="flex justify-center mb-4">
            <Shield className="w-16 h-16 text-[#1dd1a1]" />
          </div>
          <h1 className="text-4xl font-bold mb-4">Verify Trading Platform</h1>
          <p className="text-gray-400 text-lg">
            Always verify a trading platform before connecting your wallet
          </p>
        </div>

        {/* Search Form */}
        <Card className="bg-[#0d0d0d] border-gray-800 mb-8">
          <form onSubmit={handleVerify} className="p-6">
            <div className="flex flex-col md:flex-row gap-4">
              <Input
                type="text"
                placeholder="Enter Verification Code (e.g., A1B2C3D4)"
                value={verificationCode}
                onChange={(e) => setVerificationCode(e.target.value.toUpperCase())}
                className="flex-1 bg-[#1a1a1a] border-gray-700 text-white placeholder-gray-500 font-mono text-lg focus:text-white focus:border-[#1dd1a1]"
                style={{ color: 'white' }}
                maxLength={8}
              />
              <Button 
                type="submit" 
                disabled={!verificationCode.trim() || isVerifying}
                className="bg-[#1dd1a1] hover:bg-[#19b894] text-black"
              >
                {isVerifying ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Verifying...
                  </>
                ) : (
                  <>
                    <Search className="mr-2 h-4 w-4" />
                    Verify Platform
                  </>
                )}
              </Button>
            </div>
            <p className="text-sm text-gray-500 mt-2">
              Enter the 8-character verification code displayed on the trading platform
            </p>
          </form>
        </Card>

        {/* Results */}
        {(verificationError || verificationResult) && (
          <>
            {verificationError ? (
              <Alert className="bg-red-900/20 border-red-800">
                <XCircle className="h-4 w-4 text-red-500" />
                <AlertTitle className="text-red-500">Verification Failed</AlertTitle>
                <AlertDescription className="text-gray-300">
                  {verificationError}
                </AlertDescription>
              </Alert>
            ) : verificationResult ? (
              <Card className={`border-2 ${verificationResult.platform.isVerified ? 'bg-green-900/10 border-green-800' : 'bg-yellow-900/10 border-yellow-800'}`}>
                <div className="p-6">
                  <div className="flex items-start justify-between mb-4">
                    <div>
                      <h2 className="text-2xl font-bold mb-2 text-[#fffcfc]">{verificationResult.platform.name}</h2>
                      <p className="text-gray-400">Platform ID: {verificationResult.platform.id}</p>
                    </div>
                    {verificationResult.platform.isVerified ? (
                      <Badge className="bg-green-900/30 text-green-400 border-green-700">
                        <CheckCircle className="w-4 h-4 mr-1" />
                        Verified
                      </Badge>
                    ) : (
                      <Badge className="bg-yellow-900/30 text-yellow-400 border-yellow-700">
                        <AlertTriangle className="w-4 h-4 mr-1" />
                        Unverified
                      </Badge>
                    )}
                  </div>

                  <div className="space-y-4">
                    {/* Platform Details */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 p-4 bg-[#0d0d0d] rounded-lg">
                      <div>
                        <p className="text-sm text-gray-500 mb-1">Created Date</p>
                        <p className="font-mono text-[#ffffff]">{new Date(verificationResult.platform.createdAt).toLocaleDateString()}</p>
                      </div>
                      <div>
                        <p className="text-sm text-gray-500 mb-1">Platform Status</p>
                        <p className="font-mono capitalize text-[#ffffff]">{verificationResult.platform.status || 'Active'}</p>
                      </div>
                      {verificationResult.platform.customDomain && (
                        <div>
                          <p className="text-sm text-gray-500 mb-1">Custom Domain</p>
                          <p className="font-mono">{verificationResult.platform.customDomain}</p>
                        </div>
                      )}
                      <div>
                        <p className="text-sm text-gray-500 mb-1">Builder Wallet Address</p>
                        <p className="font-mono text-[#ffffff] text-xs break-all">{verificationResult.platform.config?.builderWalletAddress || '0x70997970C51812dc3A010C7d01b50e0d17dc79C8'}</p>
                      </div>
                    </div>

                    {/* Verification Status Alert */}
                    {verificationResult.platform.isVerified ? (
                      <Alert className="bg-green-900/20 border-green-800">
                        <CheckCircle className="h-4 w-4 text-green-500" />
                        <AlertTitle className="text-green-500">This platform is verified by LiquidLab</AlertTitle>
                        <AlertDescription className="text-gray-300">
                          <ul className="list-disc list-inside mt-2 space-y-1">
                            <li>Official LiquidLab trading platform</li>
                            <li>Non-custodial - your funds remain in your wallet</li>
                            <li>Revenue sharing active (70% platform owner / 30% LiquidLab)</li>
                            <li>Secure integration with Hyperliquid DEX</li>
                          </ul>
                        </AlertDescription>
                      </Alert>
                    ) : (
                      <Alert className="bg-yellow-900/20 border-yellow-800">
                        <AlertTriangle className="h-4 w-4 text-yellow-500" />
                        <AlertTitle className="text-yellow-500">This platform is not yet verified</AlertTitle>
                        <AlertDescription className="text-gray-300">
                          <ul className="list-disc list-inside mt-2 space-y-1">
                            <li>Platform is pending verification by LiquidLab team</li>
                            <li>Exercise caution when connecting your wallet</li>
                            <li>Verify the platform owner's identity independently</li>
                            <li>Contact support@liquidlab.trade if you have concerns</li>
                          </ul>
                        </AlertDescription>
                      </Alert>
                    )}

                    {/* Security Tips */}
                    <div className="mt-6 p-4 bg-[#0d0d0d] rounded-lg">
                      <h3 className="text-lg font-semibold mb-3 flex items-center text-[#ffffff]">
                        <Shield className="w-5 h-5 mr-2 text-[#1dd1a1]" />
                        Security Tips
                      </h3>
                      <ul className="list-disc list-inside space-y-2 text-sm text-gray-400">
                        <li>Always verify the platform ID matches what's shown on the trading interface</li>
                        <li>Check that the URL is correct (liquidlab.trade or verified custom domain)</li>
                        <li>Never share your private keys or seed phrases</li>
                        <li>LiquidLab platforms are non-custodial - we never hold your funds</li>
                        <li>Report suspicious platforms to security@liquidlab.trade</li>
                      </ul>
                    </div>
                  </div>
                </div>
              </Card>
            ) : null}
          </>
        )}

        {/* How to Find Verification Code */}
        {!verificationResult && !verificationError && (
          <Card className="bg-[#0d0d0d] border-gray-800">
            <div className="p-6">
              <h3 className="text-xl font-semibold mb-4 text-[#ffffff]">How to Find Verification Code</h3>
              <div className="space-y-4">
                <div className="flex items-start space-x-3">
                  <div className="bg-[#1dd1a1] text-black rounded-full w-6 h-6 flex items-center justify-center flex-shrink-0 text-sm font-bold">
                    1
                  </div>
                  <p className="text-gray-400">
                    Look for the verification code in the security bar at the top of any LiquidLab trading platform
                  </p>
                </div>
                <div className="flex items-start space-x-3">
                  <div className="bg-[#1dd1a1] text-black rounded-full w-6 h-6 flex items-center justify-center flex-shrink-0 text-sm font-bold">
                    2
                  </div>
                  <p className="text-gray-400">
                    The code will be displayed as an 8-character alphanumeric string (e.g., A1B2C3D4)
                  </p>
                </div>
                <div className="flex items-start space-x-3">
                  <div className="bg-[#1dd1a1] text-black rounded-full w-6 h-6 flex items-center justify-center flex-shrink-0 text-sm font-bold">
                    3
                  </div>
                  <p className="text-gray-400">
                    Enter the verification code above to verify the platform's authenticity
                  </p>
                </div>
              </div>
              <div className="mt-6 p-4 bg-[#1a1a1a] rounded-lg">
                <p className="text-sm text-gray-500">
                  <strong>Note:</strong> All legitimate LiquidLab platforms will have a verification badge. 
                  If a platform claims to be powered by LiquidLab but lacks this badge, it may be fraudulent.
                </p>
              </div>
            </div>
          </Card>
        )}
      </main>
      {/* Footer */}
      <footer className="border-t border-gray-800 mt-20">
        <div className="container mx-auto px-4 py-8">
          <div className="text-center text-gray-500 text-sm">
            <p>© 2025 LiquidLab. All rights reserved.</p>
            <p className="mt-2">
              Questions? Contact us at{" "}
              <a href="mailto:security@liquidlab.trade" className="text-[#1dd1a1] hover:underline">
                security@liquidlab.trade
              </a>
            </p>
          </div>
        </div>
      </footer>
    </div>
  );
}
```

---

## File: client/src/types/index.ts

```typescript
export interface WalletState {
  isConnected: boolean;
  address: string | null;
  balance: string | null;
  networkId: number | null;
}

export interface TradingPlatformConfig {
  name: string;
  theme: 'light' | 'dark';
  components: ComponentConfig[];
  layout: LayoutConfig;
  settings: PlatformSettings;
}

export interface ComponentConfig {
  id: string;
  type: 'tradingview-chart' | 'orderbook' | 'trade-form' | 'portfolio' | 'market-data';
  position: { x: number; y: number; w: number; h: number };
  settings: Record<string, any>;
}

export interface LayoutConfig {
  type: 'grid' | 'flex';
  columns: number;
  rows: number;
  gap: number;
}

export interface PlatformSettings {
  builderCode: string;
  referralCode: string;
  commissionRate: number;
  customDomain?: string;
  branding: {
    logo?: string;
    primaryColor: string;
    secondaryColor: string;
  };
}

export interface MarketData {
  symbol: string;
  price: string;
  change24h: string;
  volume: string;
  high: string;
  low: string;
  timestamp: number;
}

export interface OrderbookData {
  bids: [string, string][];
  asks: [string, string][];
  timestamp: number;
}

export interface RevenueData {
  totalRevenue: string;
  dailyRevenue: string;
  monthlyRevenue: string;
  revenueHistory: {
    date: string;
    amount: string;
  }[];
}

export interface Template {
  id: number;
  name: string;
  description: string;
  category: string;
  previewImage: string;
  config: TradingPlatformConfig;
  isPublic: boolean;
}

export interface AnalyticsData {
  totalRevenue: string;
  activeUsers: number;
  totalVolume: string;
  platforms: {
    name: string;
    revenue: string;
    change: string;
  }[];
}

```

---

# Security Documentation

## File: PWA_SECURITY_ANALYSIS.md

```markdown
# PWA Security Vulnerabilities Analysis

## Critical Security Issues Found

### 1. **Sensitive Data Caching** 🔴 HIGH RISK
**Issue**: Service worker caches ALL API responses without filtering
- User positions, balances, and trading history cached in browser
- Cached data persists even after logout
- No encryption on cached sensitive data

**Impact**: 
- Shared devices could expose user trading data
- Browser dev tools can access cached financial information
- Malicious browser extensions could read cache

### 2. **Missing Authentication Checks** 🔴 HIGH RISK
**Issue**: Service worker doesn't verify user authentication before serving cached data
- Cached API responses served to any user
- No session validation in service worker
- Logout doesn't clear sensitive cache

**Impact**:
- Previous user's data could be served to next user
- Session hijacking through cache exploitation

### 3. **Unrestricted API Caching** 🟡 MEDIUM RISK
**Issue**: All API endpoints cached including sensitive ones
- `/api/auth/user` - User profile and wallet info
- `/api/hyperliquid/balances` - Account balances
- `/api/trades/*` - Trading history
- `/api/platforms/*` - Platform configurations

### 4. **Background Sync Vulnerability** 🟡 MEDIUM RISK
**Issue**: Mentioned "offline trade submission" but not implemented
- If implemented without proper security, could allow replay attacks
- Trades could be modified while offline
- No integrity checks mentioned

### 5. **Push Notification Security** 🟡 MEDIUM RISK
**Issue**: Push notifications mentioned for "price alerts"
- Could leak trading positions if not properly secured
- No mention of encryption for push payloads
- Subscription endpoints not protected

### 6. **Cross-Origin Cache Poisoning** 🟡 MEDIUM RISK
**Issue**: Service worker doesn't validate response origins properly
- Could cache malicious responses from compromised CDNs
- No integrity checks on cached resources

### 7. **No Cache Expiration for Sensitive Data** 🟡 MEDIUM RISK
**Issue**: Sensitive data cached indefinitely
- User sessions cached without expiration
- No automatic purge of old sensitive data

## Recommended Fixes

1. **Implement Selective Caching**
   - Only cache public assets and non-sensitive data
   - Exclude all /api/auth/*, /api/trades/*, /api/hyperliquid/* endpoints

2. **Add Authentication Layer**
   - Check session validity before serving cached responses
   - Clear cache on logout

3. **Encrypt Sensitive Cache**
   - Use CryptoJS or Web Crypto API for cache encryption
   - Store encryption keys in sessionStorage (cleared on close)

4. **Implement Cache Policies**
   - Set short TTL for any API responses (5 minutes max)
   - Clear sensitive cache every 30 minutes

5. **Secure Background Sync**
   - If implementing offline trades, use signed requests
   - Validate trade integrity on sync

6. **Remove/Secure Push Notifications**
   - Either remove push notification support
   - Or implement end-to-end encryption for notifications
```

---

## File: PRODUCTION_CHECKLIST.md

```markdown
# LiquidLab Production Readiness Checklist

## ✅ Already Implemented

### Security Infrastructure
- [x] API key authentication system with permissions
- [x] Rate limiting per platform and endpoint
- [x] CORS configuration for custom domains
- [x] Audit logging for all critical actions
- [x] Platform verification system
- [x] Admin authentication and protected routes
- [x] Security headers middleware

### Revenue Tracking
- [x] Fee transaction recording system
- [x] Revenue split calculation (70/30)
- [x] Platform revenue summaries
- [x] MoonPay affiliate tracking
- [x] Dashboard analytics for platform owners
- [x] Admin dashboard with total revenue views

### Database & Storage
- [x] PostgreSQL with Drizzle ORM
- [x] All necessary tables and relations
- [x] Optimized queries with proper indexes
- [x] Revenue aggregation system

## 🚧 Required for Production

### 1. Hyperliquid Integration (Critical)
- [ ] Register webhook endpoint with Hyperliquid
- [ ] Set `HYPERLIQUID_WEBHOOK_SECRET` environment variable
- [ ] Test webhook signature verification
- [ ] Verify automatic fee tracking on real trades
- [ ] Set up webhook retry mechanism

### 2. Environment Variables
```bash
# Required secrets for production
PRIVY_APP_ID=your_production_privy_app_id
PRIVY_APP_SECRET=your_production_privy_app_secret
HYPERLIQUID_WEBHOOK_SECRET=your_webhook_secret
DATABASE_URL=your_production_database_url
SESSION_SECRET=your_secure_session_secret
ADMIN_PASSWORD_HASH=your_bcrypt_admin_password_hash
SENDGRID_API_KEY=your_sendgrid_key (for email notifications)
PAYOUT_WALLET_PRIVATE_KEY=your_arbitrum_wallet_private_key (for crypto payouts)
ARBITRUM_RPC_URL=https://arb1.arbitrum.io/rpc (or your preferred RPC)
```

### 3. Custom Domain Support
- [ ] Update `platformCors` middleware to check `platformDomains` table
- [ ] Implement domain verification process
- [ ] Set up wildcard SSL certificate for *.liquidlab.trade
- [ ] Configure DNS for platform custom domains

### 4. Revenue Distribution System
- [x] Crypto payout system implemented with ethers.js
- [x] USDC on Arbitrum for low-fee transfers
- [x] Payout tracking in payoutRecords table
- [x] Dashboard UI for payout history and pending payments
- [ ] Set `PAYOUT_WALLET_PRIVATE_KEY` environment variable
- [ ] Set `ARBITRUM_RPC_URL` environment variable
- [ ] Deploy USDC funding to payout wallet
- [ ] Test payout processing on production
- [ ] Create automated scheduler for weekly payouts

### 5. Monitoring & Observability
- [ ] Set up error tracking (Sentry or similar)
- [ ] Implement application performance monitoring
- [ ] Configure uptime monitoring
- [ ] Set up alerts for critical errors
- [ ] Create health check endpoints

### 6. Backup & Recovery
- [ ] Set up automated database backups
- [ ] Test backup restoration process
- [ ] Document recovery procedures
- [ ] Implement data retention policies

### 7. Production Database
- [ ] Run database migrations
- [ ] Create indexes for frequently queried fields
- [ ] Set up connection pooling
- [ ] Configure read replicas for scaling

### 8. Security Hardening
- [ ] Enable HTTPS everywhere
- [ ] Implement request signing for sensitive endpoints
- [ ] Add DDoS protection (Cloudflare or similar)
- [ ] Regular security audits
- [ ] Implement IP allowlisting for admin routes

### 9. Performance Optimization
- [ ] Enable CDN for static assets
- [ ] Implement caching strategy
- [ ] Optimize database queries
- [ ] Add request/response compression
- [ ] Configure proper rate limits

### 10. Legal & Compliance
- [ ] Terms of Service
- [ ] Privacy Policy
- [ ] Cookie Policy
- [ ] GDPR compliance
- [ ] Financial regulations compliance

## 🚀 Deployment Steps

1. **Set up production environment**
   ```bash
   # Set all required environment variables
   # Run database migrations
   npm run db:push
   ```

2. **Configure Batch Processing**
   - The system now uses batch processing instead of webhooks
   - Trades are checked every 10 minutes automatically
   - No Hyperliquid registration required
   - Manual processing available at `/api/trades/process-batch`

3. **Configure Privy for production**
   - Create production Privy app
   - Configure allowed domains
   - Set up social login providers

4. **Deploy application**
   - Build production bundle
   - Deploy to Replit or preferred hosting
   - Configure environment variables
   - Test all critical paths

5. **Post-deployment verification**
   - Test wallet connection
   - Verify trading functionality
   - Confirm webhook receives events
   - Check revenue tracking
   - Validate admin dashboard

## 📊 Monitoring Checklist

- [ ] Platform creation rate
- [ ] Trade volume per platform
- [ ] Revenue generation
- [ ] API response times
- [ ] Error rates
- [ ] User authentication success rate
- [ ] Webhook processing success

## 🔐 Security Checklist

- [ ] All secrets in environment variables
- [ ] No hardcoded credentials
- [ ] API keys properly hashed
- [ ] Sessions configured securely
- [ ] CORS properly restricted
- [ ] Rate limiting active
- [ ] Audit logs capturing all actions

## 📝 Documentation Needed

- [ ] API documentation for platform owners
- [ ] Webhook integration guide
- [ ] Platform setup tutorial
- [ ] Revenue tracking explanation
- [ ] Security best practices
- [ ] Troubleshooting guide

## Next Immediate Steps

1. **Contact Hyperliquid** to register your webhook endpoint
2. **Set up production Privy app** with proper configuration
3. **Configure production environment variables**
4. **Test the complete flow** from platform creation to revenue tracking
5. **Set up monitoring** to ensure system health

## Domain Configuration Notes

The application is configured for **liquidlab.trade** domain:
- Main site: `https://liquidlab.trade`
- App subdomain: `https://app.liquidlab.trade`
- Webhook URLs use: `https://api.liquidlab.trade/`
- Platform subdomains: `https://[platform-name].liquidlab.trade`

Make sure to update DNS records and SSL certificates for the `.trade` domain.

The infrastructure is well-architected and ready for production deployment. The batch processing system is implemented and will automatically track trades every 10 minutes, providing a cost-effective alternative to maintaining expensive 24/7 WebSocket connections.

**Important Note**: Hyperliquid currently only offers WebSocket streaming (not traditional webhooks). Our batch processing approach checks for new trades periodically, which is much more cost-effective than maintaining a persistent WebSocket connection that would receive all Hyperliquid trades globally.
```

---

